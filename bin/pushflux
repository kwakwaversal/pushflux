#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"IO/Socket/IP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_IP';
  package IO::Socket::IP;BEGIN {$VERSION='0.37'}use strict;use warnings;use base qw(IO::Socket);use Carp;use Socket 1.97 qw(getaddrinfo getnameinfo sockaddr_family AF_INET AI_PASSIVE IPPROTO_TCP IPPROTO_UDP IPPROTO_IPV6 IPV6_V6ONLY NI_DGRAM NI_NUMERICHOST NI_NUMERICSERV NIx_NOHOST NIx_NOSERV SO_REUSEADDR SO_REUSEPORT SO_BROADCAST SO_ERROR SOCK_DGRAM SOCK_STREAM SOL_SOCKET);my$AF_INET6=eval {Socket::AF_INET6()};my$AI_ADDRCONFIG=eval {Socket::AI_ADDRCONFIG()}|| 0;use POSIX qw(dup2);use Errno qw(EINVAL EINPROGRESS EISCONN ENOTCONN ETIMEDOUT EWOULDBLOCK);use constant HAVE_MSWIN32=>($^O eq "MSWin32");use constant HAVE_GETPROTOBYNAME=>defined eval {getprotobyname("tcp")};my$IPv6_re=do {my$IPv4address=do {my$dec_octet=q<(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])>;qq<$dec_octet(?: \\. $dec_octet){3}>};my$IPv6address=do {my$h16=qq<[0-9A-Fa-f]{1,4}>;my$ls32=qq<(?: $h16 : $h16 | $IPv4address)>;qq<(?:
                                              (?: $h16 : ){6} $ls32
           |                               :: (?: $h16 : ){5} $ls32
           | (?:                   $h16 )? :: (?: $h16 : ){4} $ls32
           | (?: (?: $h16 : ){0,1} $h16 )? :: (?: $h16 : ){3} $ls32
           | (?: (?: $h16 : ){0,2} $h16 )? :: (?: $h16 : ){2} $ls32
           | (?: (?: $h16 : ){0,3} $h16 )? ::     $h16 :      $ls32
           | (?: (?: $h16 : ){0,4} $h16 )? ::                 $ls32
           | (?: (?: $h16 : ){0,5} $h16 )? ::                 $h16
           | (?: (?: $h16 : ){0,6} $h16 )? ::
        )>};qr<$IPv6address>xo};sub import {my$pkg=shift;my@symbols;for (@_){if($_ eq "-register"){IO::Socket::IP::_ForINET->register_domain(AF_INET);IO::Socket::IP::_ForINET6->register_domain($AF_INET6)if defined$AF_INET6}else {push@symbols,$_}}@_=($pkg,@symbols);goto&IO::Socket::import}{my$can_disable_v6only;sub CAN_DISABLE_V6ONLY {return$can_disable_v6only if defined$can_disable_v6only;socket my$testsock,Socket::PF_INET6(),SOCK_STREAM,0 or die "Cannot socket(PF_INET6) - $!";if(setsockopt$testsock,IPPROTO_IPV6,IPV6_V6ONLY,0){return$can_disable_v6only=1}elsif($!==EINVAL){return$can_disable_v6only=0}else {die "Cannot setsockopt() - $!"}}}sub new {my$class=shift;my%arg=(@_==1)? (PeerHost=>$_[0]): @_;return$class->SUPER::new(%arg)}sub configure {my$self=shift;my ($arg)=@_;$arg->{PeerHost}=delete$arg->{PeerAddr}if exists$arg->{PeerAddr}&&!exists$arg->{PeerHost};$arg->{PeerService}=delete$arg->{PeerPort}if exists$arg->{PeerPort}&&!exists$arg->{PeerService};$arg->{LocalHost}=delete$arg->{LocalAddr}if exists$arg->{LocalAddr}&&!exists$arg->{LocalHost};$arg->{LocalService}=delete$arg->{LocalPort}if exists$arg->{LocalPort}&&!exists$arg->{LocalService};for my$type (qw(Peer Local)){my$host=$type .'Host';my$service=$type .'Service';if(defined$arg->{$host}){($arg->{$host},my$s)=$self->split_addr($arg->{$host});$arg->{$service}=$s if defined$s}}$self->_io_socket_ip__configure($arg)}sub _io_socket_ip__configure {my$self=shift;my ($arg)=@_;my%hints;my@localinfos;my@peerinfos;my$listenqueue=$arg->{Listen};if(defined$listenqueue and (defined$arg->{PeerHost}|| defined$arg->{PeerService}|| defined$arg->{PeerAddrInfo})){croak "Cannot Listen with a peer address"}if(defined$arg->{GetAddrInfoFlags}){$hints{flags}=$arg->{GetAddrInfoFlags}}else {$hints{flags}=$AI_ADDRCONFIG}if(defined(my$family=$arg->{Family})){$hints{family}=$family}if(defined(my$type=$arg->{Type})){$hints{socktype}=$type}if(defined(my$proto=$arg->{Proto})){unless($proto =~ m/^\d+$/){my$protonum=HAVE_GETPROTOBYNAME ? getprotobyname($proto): eval {Socket->${\"IPPROTO_\U$proto"}()};defined$protonum or croak "Unrecognised protocol $proto";$proto=$protonum}$hints{protocol}=$proto}if(!defined$hints{socktype}and!defined$hints{protocol}){$hints{socktype}=SOCK_STREAM;$hints{protocol}=IPPROTO_TCP}if(!defined$hints{socktype}and defined$hints{protocol}){$hints{socktype}=SOCK_STREAM if$hints{protocol}==IPPROTO_TCP;$hints{socktype}=SOCK_DGRAM if$hints{protocol}==IPPROTO_UDP}if(my$info=$arg->{LocalAddrInfo}){ref$info eq "ARRAY" or croak "Expected 'LocalAddrInfo' to be an ARRAY ref";@localinfos=@$info}elsif(defined$arg->{LocalHost}or defined$arg->{LocalService}or HAVE_MSWIN32 and $arg->{Listen}){my$host=$arg->{LocalHost};my$service=$arg->{LocalService};unless (defined$host or defined$service){$service=0}local $1;defined$service and $service =~ s/\((\d+)\)$// and my$fallback_port=$1;my%localhints=%hints;$localhints{flags}|= AI_PASSIVE;(my$err,@localinfos)=getaddrinfo($host,$service,\%localhints);if($err and defined$fallback_port){($err,@localinfos)=getaddrinfo($host,$fallback_port,\%localhints)}if($err){$@="$err";$!=EINVAL;return}}if(my$info=$arg->{PeerAddrInfo}){ref$info eq "ARRAY" or croak "Expected 'PeerAddrInfo' to be an ARRAY ref";@peerinfos=@$info}elsif(defined$arg->{PeerHost}or defined$arg->{PeerService}){defined(my$host=$arg->{PeerHost})or croak "Expected 'PeerHost'";defined(my$service=$arg->{PeerService})or croak "Expected 'PeerService'";local $1;defined$service and $service =~ s/\((\d+)\)$// and my$fallback_port=$1;(my$err,@peerinfos)=getaddrinfo($host,$service,\%hints);if($err and defined$fallback_port){($err,@peerinfos)=getaddrinfo($host,$fallback_port,\%hints)}if($err){$@="$err";$!=EINVAL;return}}my@sockopts_enabled;push@sockopts_enabled,SO_REUSEADDR if$arg->{ReuseAddr};push@sockopts_enabled,SO_REUSEPORT if$arg->{ReusePort};push@sockopts_enabled,SO_BROADCAST if$arg->{Broadcast};my$blocking=$arg->{Blocking};defined$blocking or $blocking=1;my$v6only=$arg->{V6Only};if(defined$arg->{MultiHomed}and!$arg->{MultiHomed}){croak "Cannot disable the MultiHomed parameter"}my@infos;for my$local (@localinfos ? @localinfos : {}){for my$peer (@peerinfos ? @peerinfos : {}){next if defined$local->{family}and defined$peer->{family}and $local->{family}!=$peer->{family};next if defined$local->{socktype}and defined$peer->{socktype}and $local->{socktype}!=$peer->{socktype};next if defined$local->{protocol}and defined$peer->{protocol}and $local->{protocol}!=$peer->{protocol};my$family=$local->{family}|| $peer->{family}or next;my$socktype=$local->{socktype}|| $peer->{socktype}or next;my$protocol=$local->{protocol}|| $peer->{protocol}|| 0;push@infos,{family=>$family,socktype=>$socktype,protocol=>$protocol,localaddr=>$local->{addr},peeraddr=>$peer->{addr},}}}if(!@infos){if(defined$hints{family}){@infos=({family=>$hints{family},socktype=>$hints{socktype},protocol=>$hints{protocol},})}else {(my$err,@infos)=getaddrinfo("","0",\%hints);if($err){$@="$err";$!=EINVAL;return}}}${*$self}{io_socket_ip_infos}=\@infos;${*$self}{io_socket_ip_idx}=-1;${*$self}{io_socket_ip_sockopts}=\@sockopts_enabled;${*$self}{io_socket_ip_v6only}=$v6only;${*$self}{io_socket_ip_listenqueue}=$listenqueue;${*$self}{io_socket_ip_blocking}=$blocking;${*$self}{io_socket_ip_errors}=[undef,undef,undef ];$self->setup or!$blocking or return undef;return$self}sub setup {my$self=shift;while(1){${*$self}{io_socket_ip_idx}++;last if ${*$self}{io_socket_ip_idx}>= @{${*$self}{io_socket_ip_infos}};my$info=${*$self}{io_socket_ip_infos}->[${*$self}{io_socket_ip_idx}];$self->socket(@{$info}{qw(family socktype protocol)})or (${*$self}{io_socket_ip_errors}[2]=$!,next);$self->blocking(0)unless ${*$self}{io_socket_ip_blocking};for my$sockopt (@{${*$self}{io_socket_ip_sockopts}}){$self->setsockopt(SOL_SOCKET,$sockopt,pack "i",1)or ($@="$!",return undef)}if(defined ${*$self}{io_socket_ip_v6only}and defined$AF_INET6 and $info->{family}==$AF_INET6){my$v6only=${*$self}{io_socket_ip_v6only};$self->setsockopt(IPPROTO_IPV6,IPV6_V6ONLY,pack "i",$v6only)or ($@="$!",return undef)}if(defined(my$addr=$info->{localaddr})){$self->bind($addr)or (${*$self}{io_socket_ip_errors}[1]=$!,next)}if(defined(my$listenqueue=${*$self}{io_socket_ip_listenqueue})){$self->listen($listenqueue)or ($@="$!",return undef)}if(defined(my$addr=$info->{peeraddr})){if($self->connect($addr)){$!=0;return 1}if($!==EINPROGRESS or $!==EWOULDBLOCK){${*$self}{io_socket_ip_connect_in_progress}=1;return 0}return 0 if!$!;${*$self}{io_socket_ip_errors}[0]=$!;next}return 1}$!=(grep defined,@{${*$self}{io_socket_ip_errors}})[0];$@="$!";return undef}sub connect :method {my$self=shift;if(@_){my ($addr)=@_;my$timeout=${*$self}{'io_socket_timeout'};return connect($self,$addr)unless defined$timeout;my$was_blocking=$self->blocking(0);my$err=defined connect($self,$addr)? 0 : $!+0;if(!$err){$self->blocking($was_blocking);return 1}elsif(not($err==EINPROGRESS or $err==EWOULDBLOCK)){return undef}elsif(!$was_blocking){return undef}my$vec='';vec($vec,$self->fileno,1)=1;if(!select(undef,$vec,$vec,$timeout)){$!=ETIMEDOUT;return undef}$err=$self->getsockopt(SOL_SOCKET,SO_ERROR);$err=0 if$err==EISCONN;$self->blocking($was_blocking);$!=$err,return undef if$err;return 1}return 1 if!${*$self}{io_socket_ip_connect_in_progress};if(my$errno=$self->getsockopt(SOL_SOCKET,SO_ERROR)){delete ${*$self}{io_socket_ip_connect_in_progress};${*$self}{io_socket_ip_errors}[0]=$!=$errno;return$self->setup}my$addr=${*$self}{io_socket_ip_infos}[${*$self}{io_socket_ip_idx}]{peeraddr};if(connect($self,$addr)or $!==EISCONN){delete ${*$self}{io_socket_ip_connect_in_progress};$!=0;return 1}else {$!=EINPROGRESS;return 0}}sub connected {my$self=shift;return defined$self->fileno && !${*$self}{io_socket_ip_connect_in_progress}&& defined getpeername($self)}sub _get_host_service {my$self=shift;my ($addr,$flags,$xflags)=@_;defined$addr or $!=ENOTCONN,return;$flags |= NI_DGRAM if$self->socktype==SOCK_DGRAM;my ($err,$host,$service)=getnameinfo($addr,$flags,$xflags || 0);croak "getnameinfo - $err" if$err;return ($host,$service)}sub _unpack_sockaddr {my ($addr)=@_;my$family=sockaddr_family$addr;if($family==AF_INET){return (Socket::unpack_sockaddr_in($addr))[1]}elsif(defined$AF_INET6 and $family==$AF_INET6){return (Socket::unpack_sockaddr_in6($addr))[1]}else {croak "Unrecognised address family $family"}}sub sockhost_service {my$self=shift;my ($numeric)=@_;$self->_get_host_service($self->sockname,$numeric ? NI_NUMERICHOST|NI_NUMERICSERV : 0)}sub sockhost {my$self=shift;scalar +($self->_get_host_service($self->sockname,NI_NUMERICHOST,NIx_NOSERV))[0]}sub sockport {my$self=shift;scalar +($self->_get_host_service($self->sockname,NI_NUMERICSERV,NIx_NOHOST))[1]}sub sockhostname {my$self=shift;scalar +($self->_get_host_service($self->sockname,0,NIx_NOSERV))[0]}sub sockservice {my$self=shift;scalar +($self->_get_host_service($self->sockname,0,NIx_NOHOST))[1]}sub sockaddr {my$self=shift;_unpack_sockaddr$self->sockname}sub peerhost_service {my$self=shift;my ($numeric)=@_;$self->_get_host_service($self->peername,$numeric ? NI_NUMERICHOST|NI_NUMERICSERV : 0)}sub peerhost {my$self=shift;scalar +($self->_get_host_service($self->peername,NI_NUMERICHOST,NIx_NOSERV))[0]}sub peerport {my$self=shift;scalar +($self->_get_host_service($self->peername,NI_NUMERICSERV,NIx_NOHOST))[1]}sub peerhostname {my$self=shift;scalar +($self->_get_host_service($self->peername,0,NIx_NOSERV))[0]}sub peerservice {my$self=shift;scalar +($self->_get_host_service($self->peername,0,NIx_NOHOST))[1]}sub peeraddr {my$self=shift;_unpack_sockaddr$self->peername}sub accept {my$self=shift;my ($new,$peer)=$self->SUPER::accept(@_)or return;${*$new}{$_}=${*$self}{$_}for qw(io_socket_domain io_socket_type io_socket_proto);return wantarray ? ($new,$peer): $new}sub socket :method {my$self=shift;return$self->SUPER::socket(@_)if not defined$self->fileno;socket(my$tmph,$_[0],$_[1],$_[2])or return undef;dup2($tmph->fileno,$self->fileno)or die "Unable to dup2 $tmph onto $self - $!"}BEGIN {if(eval($IO::Socket::VERSION)< 1.35){*socktype=sub {my$self=shift;my$type=$self->SUPER::socktype;if(!defined$type){$type=$self->sockopt(Socket::SO_TYPE())}return$type}}}sub as_inet {my$self=shift;croak "Cannot downgrade a non-PF_INET socket to IO::Socket::INET" unless$self->sockdomain==AF_INET;return IO::Socket::INET->new_from_fd($self->fileno,"r+")}sub split_addr {shift;my ($addr)=@_;local ($1,$2);if($addr =~ m/\A\[($IPv6_re)\](?::([^\s:]*))?\z/ or $addr =~ m/\A([^\s:]*):([^\s:]*)\z/){return ($1,$2)if defined $2 and length $2;return ($1,undef)}return ($addr,undef)}sub join_addr {shift;my ($host,$port)=@_;$host="[$host]" if$host =~ m/:/;return join ":",$host,$port if defined$port;return$host}package IO::Socket::IP::_ForINET;use base qw(IO::Socket::IP);sub configure {my$self=shift;my ($arg)=@_;bless$self,"IO::Socket::IP";$self->configure({%$arg,Family=>Socket::AF_INET()})}package IO::Socket::IP::_ForINET6;use base qw(IO::Socket::IP);sub configure {my$self=shift;my ($arg)=@_;bless$self,"IO::Socket::IP";$self->configure({%$arg,Family=>Socket::AF_INET6()})}0x55AA;
IO_SOCKET_IP

$fatpacked{"IPC/ConcurrencyLimit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_CONCURRENCYLIMIT';
  package IPC::ConcurrencyLimit;use 5.008001;use strict;use warnings;our$VERSION='0.14';use Carp qw(croak);sub new {my$class=shift;my%params=@_;my$type=delete$params{type};$type='Flock' if not defined$type;my$lock_class=$class ."::Lock::$type";if (not eval "require $lock_class; 1;"){my$err=$@ || 'Zombie error';croak("Invalid lock type '$type'. Could not load lock class '$lock_class': $err")}my$self=bless {opt=>{max_procs=>1,%params,},lock_class=>$lock_class,lock_obj=>undef,}=>$class;return$self}sub get_lock {my$self=shift;return$self->{lock_obj}->id()if$self->{lock_obj};my$class=$self->{lock_class};$self->{lock_obj}=$class->new($self->{opt});return$self->{lock_obj}? $self->{lock_obj}->id(): undef}sub is_locked {my$self=shift;return$self->{lock_obj}? 1 : 0}sub release_lock {my$self=shift;return undef if not $self->{lock_obj};$self->{lock_obj}=undef;return 1}sub lock_id {my$self=shift;return undef if not $self->{lock_obj};return$self->{lock_obj}->id}sub heartbeat {my$self=shift;my$lock=$self->{lock_obj};return if not $lock;if (not $lock->heartbeat){$self->release_lock;return()}return 1}1;
IPC_CONCURRENCYLIMIT

$fatpacked{"IPC/ConcurrencyLimit/Lock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_CONCURRENCYLIMIT_LOCK';
  package IPC::ConcurrencyLimit::Lock;use 5.008001;use strict;use warnings;sub id {$_[0]->{id}}sub heartbeat {1}1;
IPC_CONCURRENCYLIMIT_LOCK

$fatpacked{"IPC/ConcurrencyLimit/Lock/Flock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_CONCURRENCYLIMIT_LOCK_FLOCK';
  package IPC::ConcurrencyLimit::Lock::Flock;use 5.008001;use strict;use warnings;use Carp qw(croak);use File::Path qw();use File::Spec;use Fcntl qw(:DEFAULT :flock);use IO::File ();use IPC::ConcurrencyLimit::Lock;our@ISA=qw(IPC::ConcurrencyLimit::Lock);sub new {my$class=shift;my$opt=shift;my$max_procs=$opt->{max_procs}or croak("Need a 'max_procs' parameter");my$path=$opt->{path}or croak("Need a 'path' parameter");my$lock_mode=lc($opt->{lock_mode}|| 'exclusive');if ($lock_mode !~ /^(?:exclusive|shared)$/){croak("Invalid lock mode '$lock_mode'")}my$file_prefix=$opt->{file_prefix}// "";$file_prefix .= "." if length$file_prefix;my$file_ext=$opt->{file_ext}// "lock";$file_ext=~s/^\.?/./;my$self=bless {max_procs=>$max_procs,path=>$path,lock_fh=>undef,lock_file=>undef,id=>undef,file_prefix=>$file_prefix,file_ext=>$file_ext,lock_mode=>$lock_mode,}=>$class;$self->_get_lock()or return undef;return$self}sub _get_lock {my$self=shift;File::Path::mkpath($self->{path});my$lock_mode_flag=$self->{lock_mode}eq 'shared' ? LOCK_SH : LOCK_EX;for my$worker_id (reverse 1 .. $self->{max_procs}){my$lock_file=File::Spec->catfile($self->{path},join("",$self->{file_prefix},$worker_id,$self->{file_ext}));sysopen(my$fh,$lock_file,O_RDWR|O_CREAT)or die "can't open '$lock_file': $!";if (flock($fh,$lock_mode_flag|LOCK_NB)){$self->{lock_fh}=$fh;seek($fh,0,0);truncate($fh,0);print$fh $$;$fh->flush;$self->{id}=$worker_id;$self->{lock_file}=$lock_file;last}close$fh}return undef if not $self->{id};return 1}sub lock_file {$_[0]->{lock_file}}sub path {$_[0]->{path}}sub DESTROY {my$self=shift;close($self->{lock_fh})if$self->{lock_fh}}1;
IPC_CONCURRENCYLIMIT_LOCK_FLOCK

$fatpacked{"IPC/ConcurrencyLimit/WithStandby.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_CONCURRENCYLIMIT_WITHSTANDBY';
  package IPC::ConcurrencyLimit::WithStandby;use 5.008001;use strict;use warnings;use Carp qw(croak);use Time::HiRes qw(sleep);use IPC::ConcurrencyLimit;sub new {my$class=shift;my%params=@_;my$type=delete$params{type};$type='Flock' if not defined$type;my$standby_type=delete($params{standby_type})|| $type;for my$t ($type,$standby_type){my$lock_class="IPC::ConcurrencyLimit::Lock::$t";if (not eval "require $lock_class; 1;"){my$err=$@ || 'Zombie error';croak("Invalid lock type '$t'. Could not load lock class '$lock_class': $err")}}my%standby;for my$key (grep /^standby_/,keys%params){my$munged=$key;$munged =~ s/^standby_//;$standby{$munged}=delete$params{$key}}$standby{$_}=$params{$_}for grep!exists($standby{$_}),keys%params;my$main_lock=IPC::ConcurrencyLimit->new(%params,type=>$type);my$standby_lock=IPC::ConcurrencyLimit->new(%standby,type=>$standby_type);my$self=bless({main_lock=>$main_lock,standby_lock=>$standby_lock,retries=>defined($params{retries})? $params{retries}: 10,interval=>defined($params{interval})? $params{interval}: 1,process_name_change=>$params{process_name_change},}=>$class);return$self}sub get_lock {my$self=shift;my$main_lock=$self->{main_lock};if (ref$self->{retries}ne "CODE"){my$max_retries=$self->{retries};$self->{retries}=sub {return $_[0]!=$max_retries + 1}}my$id=$main_lock->get_lock;return$id if defined$id;my$st_lock=$self->{standby_lock};my$st_id=$st_lock->get_lock;return undef if not defined$st_id;my$old_proc_name;if ($self->{process_name_change}){$old_proc_name=$0;$0="$0 - standby"}my$interval=$self->{interval};eval {my$tries=0;while (1){$id=$main_lock->get_lock;if (defined$id){$st_lock->release_lock;last}last unless$self->{retries}->(++$tries);sleep($interval)if$interval}1}or do {my$err=$@ || 'Zombie error';$0=$old_proc_name if defined$old_proc_name;$st_lock->release_lock;die$err};$0=$old_proc_name if defined$old_proc_name;return$id}sub is_locked {my$self=shift;return$self->{main_lock}->is_locked(@_)}sub release_lock {my$self=shift;return$self->{main_lock}->release_lock(@_)}sub lock_id {my$self=shift;return$self->{main_lock}->lock_id(@_)}sub heartbeat {my$self=shift;return$self->{main_lock}->heartbeat}1;
IPC_CONCURRENCYLIMIT_WITHSTANDBY

$fatpacked{"Log/Unrotate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_UNROTATE';
  package Log::Unrotate;{$Log::Unrotate::VERSION='1.32'}use strict;use warnings;use Carp;use IO::Handle;use Digest::MD5 qw(md5_hex);use Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);use Log::Unrotate::Cursor::File;use Log::Unrotate::Cursor::Null;sub _defaults ($) {my ($class)=@_;return {start=>'begin',lock=>'none',end=>'fixed',check_inode=>0,check_lastline=>1,check_log=>0,autofix_cursor=>0,rollback_period=>300,}}our%_start_values=map {$_=>1}qw(begin end first);our%_end_values=map {$_=>1}qw(fixed future);sub new ($$) {my ($class,$args)=@_;my$self={%{$class->_defaults()},%$args,};croak "unknown start value: '$self->{start}'" unless$_start_values{$self->{start}};croak "unknown end value: '$self->{end}'" unless$_end_values{$self->{end}};croak "either check_inode or check_lastline should be on" unless$self->{check_inode}or $self->{check_lastline};bless$self=>$class;if ($self->{pos}and $self->{cursor}){croak "only one of 'pos' and 'cursor' should be specified"}unless ($self->{pos}or $self->{cursor}){croak "one of 'pos' and 'cursor' should be specified"}my$posfile=delete$self->{pos};if ($posfile){if ($posfile eq '-'){croak "Log not specified and posfile is '-'" if not defined$self->{log};$self->{cursor}=Log::Unrotate::Cursor::Null->new()}else {croak "Log not specified and posfile is not found" if not defined$self->{log}and not -e $posfile;$self->{cursor}=Log::Unrotate::Cursor::File->new($posfile,{lock=>$self->{lock},rollback_period=>$self->{rollback_period}})}}my$pos=$self->{cursor}->read();if ($pos){my$logfile=delete$pos->{LogFile};if ($self->{log}){die "logfile mismatch: $logfile ne $self->{log}" if$self->{check_log}and $logfile and $self->{log}ne $logfile}else {$self->{log}=$logfile or die "'logfile:' not found in cursor $self->{cursor} and log not specified"}}$self->_set_last_log_number();$self->_set_eof();if ($pos){my$error;while (){eval {$self->_find_log($pos)};$error=$@;last unless$error;last unless$self->{cursor}->rollback();$pos=$self->{cursor}->read()}if ($error){if ($self->{autofix_cursor}){warn$error;warn "autofix_cursor is enabled, cleaning $self->{cursor}";$self->{cursor}->clean();$self->_start()}else {die$error}}}else {$self->_start()}return$self}sub _seek_end_pos ($$) {my$self=shift;my ($handle)=@_;seek$handle,-1,SEEK_END;read$handle,my$last_byte,1;if ($last_byte eq "\n"){return tell$handle}my$position=tell$handle;while (1){return 0 if$position==0;my$read_portion=1024;$read_portion=$position if ($position < $read_portion);seek$handle,-$read_portion,SEEK_CUR;my$data;read$handle,$data,$read_portion;if ($data =~ /\n(.*)\z/){my$len=length $1;seek$handle,$position,SEEK_SET;return$position - $len}seek$handle,-$read_portion,SEEK_CUR;$position -= $read_portion}}sub _find_end_pos ($$) {my$self=shift;my ($handle)=@_;my$tell=tell$handle;my$end=$self->_seek_end_pos($handle);seek$handle,$tell,SEEK_SET;return$end}sub _get_last_line ($) {my ($self)=@_;my$handle=$self->{Handle};my$number=$self->{LogNumber};my$position=tell$handle if$handle;unless ($position){$number++;my$log=$self->_log_file($number);undef$handle;open$handle,'<',$log or return "";$position=$self->_seek_end_pos($handle)}my$backstep=256;$backstep=$position if$backstep > $position;seek$handle,-$backstep,SEEK_CUR;my$last_line;read$handle,$last_line,$backstep;return$last_line}sub _last_line ($) {my ($self)=@_;my$last_line=$self->{LastLine}|| $self->_get_last_line();$last_line =~ /(.{0,255})$/ and $last_line=$1;return$last_line}sub _start($) {my$self=shift;$self->{LogNumber}=0;if ($self->{start}eq 'end'){$self->_reopen(0);$self->_seek_end_pos($self->{Handle})if$self->{Handle}}elsif ($self->{start}eq 'begin'){$self->_reopen(0)}elsif ($self->{start}eq 'first'){$self->{LogNumber}=$self->{LastLogNumber};$self->_reopen(0)}else {die}}sub _reopen ($$) {my ($self,$position)=@_;my$log=$self->_log_file();if (open my$FILE,"<$log"){my@stat=stat$FILE;return 0 if$stat[7]< $position;return 0 if$stat[7]==0 and $self->{LogNumber}==0 and $self->{end}eq 'fixed';seek$FILE,$position,SEEK_SET;$self->{Handle}=$FILE;$self->{Inode}=$stat[1];return 1}elsif (-e $log){die "log '$log' exists but is unreadable"}else {return}}sub _set_last_log_number ($) {my ($self)=@_;my$log=$self->{log};my@numbers=sort {$b <=> $a}map {/\.(\d+)$/ ? $1 : ()}glob "$log.*";$self->{LastLogNumber}=$numbers[0]|| 0}sub _set_eof ($) {my ($self)=@_;return unless$self->{end}eq 'fixed';my@stat=stat$self->{log};my$eof=$stat[7];$self->{EOF}=$eof || 0}sub _log_file ($;$) {my ($self,$number)=@_;$number=$self->{LogNumber}unless defined$number;my$log=$self->{log};$log .= ".$number" if$number;return$log}sub _print_position ($$) {my ($self,$pos)=@_;my$lastline=defined$pos->{LastLine}? $pos->{LastLine}: "[unknown]";my$inode=defined$pos->{Inode}? $pos->{Inode}: "[unknown]";my$position=defined$pos->{Position}? $pos->{Position}: "[unknown]";my$logfile=$self->{log};my$cursor=$self->{cursor};return "Cursor: $cursor, LogFile: $logfile, Inode: $inode, Position: $position, LastLine: $lastline"}sub _find_log ($$) {my ($self,$pos)=@_;undef$self->{LastLine};$self->_set_last_log_number();for ($self->{LogNumber}=0;$self->{LogNumber}<= $self->{LastLogNumber};$self->{LogNumber}++){next unless$self->_reopen($pos->{Position});next if ($self->{check_inode}and $pos->{Inode}and $self->{Inode}and $pos->{Inode}ne $self->{Inode});next if ($self->{check_lastline}and $pos->{LastLine}and $pos->{LastLine}ne $self->_last_line());while (){return 1 if$self->_find_end_pos($self->{Handle})> tell$self->{Handle};while (){return 0 if$self->{LogNumber}<= 0;$self->{LogNumber}--;last if$self->_reopen(0)}}}die "unable to find the log: ",$self->_print_position($pos)}sub read {my$self=shift;my$line;while (1){my$FILE=$self->{Handle};return undef unless defined$FILE;if (defined$self->{EOF}and $self->{LogNumber}==0){my$position=tell$FILE;return undef if$position >= $self->{EOF}}$line=<$FILE>;if (defined$line){if ($line =~ /\n$/){last}seek$FILE,- length$line,SEEK_CUR}return undef unless$self->_find_log($self->position())}$self->{LastLine}=$line;return$line}sub position($) {my$self=shift;my$pos={};if ($self->{Handle}){$pos->{Position}=tell$self->{Handle};$pos->{Inode}=$self->{Inode};$pos->{LastLine}=$self->_last_line();$pos->{LogFile}=$self->{log}}return$pos}sub commit($;$) {my ($self,$pos)=@_;$pos ||= $self->position();return unless defined$pos->{Position};$self->{cursor}->commit($pos)}sub lag ($) {my ($self)=@_;die "lag failed: missing log file" unless defined$self->{Handle};my$lag=0;my$number=$self->{LogNumber};while (){my@stat=stat$self->_log_file($number);$lag += $stat[7]if@stat;last if$number <= 0;$number--}$lag -= tell$self->{Handle};return$lag}sub log_number {my ($self)=@_;return$self->{LogNumber}}sub log_name {my ($self)=@_;return$self->{log}}1;
LOG_UNROTATE

$fatpacked{"Log/Unrotate/Cursor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_UNROTATE_CURSOR';
  package Log::Unrotate::Cursor;{$Log::Unrotate::Cursor::VERSION='1.32'}use strict;use warnings;sub read($) {die 'not implemented'}sub commit($$) {die 'not implemented'}sub clean($) {die 'not implemented'}sub rollback($) {return 0}1;
LOG_UNROTATE_CURSOR

$fatpacked{"Log/Unrotate/Cursor/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_UNROTATE_CURSOR_FILE';
  package Log::Unrotate::Cursor::File;{$Log::Unrotate::Cursor::File::VERSION='1.32'}use strict;use warnings;use base qw(Log::Unrotate::Cursor);use overload '""'=>sub {shift()->{file}};use Fcntl qw(:flock);use Carp;use File::Temp 0.15;use File::Basename;our%_lock_values=map {$_=>1}qw(none blocking nonblocking);our%_text2field=(position=>'Position',logfile=>'LogFile',inode=>'Inode',lastline=>'LastLine',committime=>'CommitTime',);sub new {my ($class,$file,$options)=@_;croak "No file specified" unless defined$file;my$lock='none';my$rollback;if ($options){$lock=$options->{lock};$rollback=$options->{rollback_period}}croak "unknown lock value: '$lock'" unless$_lock_values{$lock};croak "wrong rollback_period: '$rollback'" if ($rollback and $rollback !~ /^\d+$/);my$self=bless {file=>$file,rollback=>$rollback,}=>$class;unless ($lock eq 'none'){unless (open$self->{lock_fh},'>>',"$self->{file}.lock"){delete$self->{lock_fh};croak "Can't open $self->{file}.lock: $!"}if ($lock eq 'blocking'){flock$self->{lock_fh},LOCK_EX or croak "Failed to obtain lock: $!"}elsif ($lock eq 'nonblocking'){flock$self->{lock_fh},LOCK_EX | LOCK_NB or croak "Failed to obtain lock: $!"}}$self->{positions}=$self->_read_file_fully();return$self}sub _read_file_fully {my ($self)=@_;my$file=$self->{file};return unless -e $file;open my$fh,'<',$file or die "Can't open '$file': $!";my$content=do {local $/;<$fh>};my@poss=();my$pos={};for my$line (split /\n/,$content){if ($line =~ /^\s*(inode|committime|position):\s*(\d+)/){my$field=$_text2field{$1};if (defined$pos->{$field}){die "Some pos-file inconsistency: '$field' defined twice"}$pos->{$field}=$2}elsif ($line =~ /^\s*(logfile|lastline):\s(.*)/){my$field=$_text2field{$1};if (defined$pos->{$field}){die "Some pos-file inconsistency: '$field' defined twice"}$pos->{$field}=$2}elsif ($line =~ /^###$/){die "missing 'position:' in $file" unless defined$pos->{Position};push@poss,$pos;$pos={}}}if ($pos && scalar keys %$pos){die "missing 'position:' in $file" unless defined$pos->{Position};push@poss,$pos}die "missing 'position:' in $file" unless scalar@poss;return \@poss}sub read {my$self=shift;return undef unless defined$self->{positions};return {%{$self->{positions}->[0]}}}sub _save_positions {my ($self,$poss)=@_;$self->{positions}=[map {{%$_}}@$poss ];my$fh=File::Temp->new(DIR=>dirname($self->{file}));my$first=1;for my$pos (@{$self->{positions}}){$fh->print("###\n")unless$first;$first=0;$fh->print("logfile: $pos->{LogFile}\n");$fh->print("position: $pos->{Position}\n");if ($pos->{Inode}){$fh->print("inode: $pos->{Inode}\n")}if ($pos->{LastLine}){$fh->print("lastline: $pos->{LastLine}\n")}$pos->{CommitTime}||= time;$fh->print("committime: $pos->{CommitTime}\n");my@to_clean;for my$field (keys %$pos){unless (grep {$_ eq $field}values%_text2field){push@to_clean,$field}}delete @{$pos}{@to_clean}if (scalar@to_clean)}$fh->flush;if ($fh->error){die 'print into '.$fh->filename.' failed'}chmod(0644,$fh->filename)or die "Failed to chmod ".$fh->filename.": $!";rename($fh->filename,$self->{file})or die "Failed to commit pos $self->{file}: $!";$fh->unlink_on_destroy(0)}sub _commit_with_backups($$) {my ($self,$pos)=@_;my$time=time;my$poss=$self->{positions};unless ($poss){$self->_save_positions([$pos]);return}if ($poss->[0]->{Position}==$pos->{Position}&& $poss->[0]->{LastLine}eq $pos->{LastLine}&& $poss->[0]->{Inode}==$pos->{Inode}){return}my@times=map {$time - ($_->{CommitTime}|| $time)}@$poss;my@new_poss=();if ($times[0]> $self->{rollback}|| scalar@times==1){@new_poss=($pos,$poss->[0])}elsif ($times[1]<= $self->{rollback}){@new_poss=@$poss;$new_poss[0]=$pos}elsif ($times[1]> $self->{rollback}){@new_poss=($pos,$poss->[0],$poss->[1])}$self->_save_positions(\@new_poss)}sub commit($$) {my ($self,$pos)=@_;return unless defined$pos->{Position};return$self->_commit_with_backups($pos)if ($self->{rollback});$self->_save_positions([$pos])}sub rollback {my ($self)=@_;return 0 unless$self->{positions};return 0 unless scalar @{$self->{positions}}> 1;shift @{$self->{positions}};return 1}sub clean($) {my ($self)=@_;return unless -e $self->{file};unlink$self->{file}or die "Can't remove $self->{file}: $!";$self->{positions}=undef}sub DESTROY {my ($self)=@_;if ($self->{lock_fh}){flock$self->{lock_fh},LOCK_UN}}1;
LOG_UNROTATE_CURSOR_FILE

$fatpacked{"Log/Unrotate/Cursor/Null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOG_UNROTATE_CURSOR_NULL';
  package Log::Unrotate::Cursor::Null;{$Log::Unrotate::Cursor::Null::VERSION='1.32'}use strict;use warnings;use base qw(Log::Unrotate::Cursor);use overload '""'=>sub {'Null'};sub new {return bless {}=>shift}sub read {return}sub commit {return}sub clean {return}1;
LOG_UNROTATE_CURSOR_NULL

$fatpacked{"Mojo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO';
  package Mojo;use Mojo::Base -base;use Carp ();use Mojo::Home;use Mojo::Log;use Mojo::Transaction::HTTP;use Mojo::UserAgent;use Mojo::Util;use Scalar::Util ();has home=>sub {Mojo::Home->new->detect(ref shift)};has log=>sub {Mojo::Log->new};has ua=>sub {my$ua=Mojo::UserAgent->new;Scalar::Util::weaken$ua->server->app(shift)->{app};return$ua};sub build_tx {Mojo::Transaction::HTTP->new}sub config {Mojo::Util::_stash(config=>@_)}sub handler {Carp::croak 'Method "handler" not implemented in subclass'}1;
MOJO

$fatpacked{"Mojo/Asset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_ASSET';
  package Mojo::Asset;use Mojo::Base 'Mojo::EventEmitter';use Carp 'croak';has 'end_range';has start_range=>0;sub add_chunk {croak 'Method "add_chunk" not implemented by subclass'}sub contains {croak 'Method "contains" not implemented by subclass'}sub get_chunk {croak 'Method "get_chunk" not implemented by subclass'}sub is_file {undef}sub is_range {!!($_[0]->end_range || $_[0]->start_range)}sub move_to {croak 'Method "move_to" not implemented by subclass'}sub mtime {croak 'Method "mtime" not implemented by subclass'}sub size {croak 'Method "size" not implemented by subclass'}sub slurp {croak 'Method "slurp" not implemented by subclass'}1;
MOJO_ASSET

$fatpacked{"Mojo/Asset/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_ASSET_FILE';
  package Mojo::Asset::File;use Mojo::Base 'Mojo::Asset';use Carp 'croak';use Errno 'EEXIST';use Fcntl qw(O_APPEND O_CREAT O_EXCL O_RDONLY O_RDWR);use File::Copy 'move';use File::Spec::Functions 'catfile';use IO::File;use Mojo::Util 'md5_sum';has [qw(cleanup path)];has handle=>sub {my$self=shift;my$handle=IO::File->new;my$path=$self->path;if (defined$path && -f $path){$handle->open($path,O_RDONLY)or croak qq{Can't open file "$path": $!};return$handle}my$base=catfile$self->tmpdir,'mojo.tmp';my$name=$path // $base;until ($handle->open($name,O_APPEND | O_CREAT | O_EXCL | O_RDWR)){croak qq{Can't open file "$name": $!} if defined$path || $!!=$!{EEXIST};$name="$base." .md5_sum(time .$$ .rand 999)}$self->path($name);$self->cleanup(1)unless defined$self->cleanup;return$handle};has tmpdir=>sub {$ENV{MOJO_TMPDIR}|| File::Spec::Functions::tmpdir};sub DESTROY {my$self=shift;return unless$self->cleanup && defined(my$path=$self->path);close$self->handle;unlink$path if -w $path}sub add_chunk {my ($self,$chunk)=@_;defined$self->handle->syswrite($chunk)or croak "Can't write to asset: $!";return$self}sub contains {my ($self,$str)=@_;my$handle=$self->handle;$handle->sysseek($self->start_range,SEEK_SET);my$end=$self->end_range // $self->size;my$len=length$str;my$size=$len > 131072 ? $len : 131072;$size=$end - $self->start_range if$size > $end - $self->start_range;my$offset=0;my$start=$handle->sysread(my$window,$len);while ($offset < $end){my$diff=$end - ($start + $offset);my$read=$handle->sysread(my$buffer,$diff < $size ? $diff : $size);$window .= $buffer;my$pos=index$window,$str;return$offset + $pos if$pos >= 0;return -1 if$read==0 || ($offset += $read)==$end;substr$window,0,$read,''}return -1}sub get_chunk {my ($self,$offset,$max)=@_;$max //= 131072;$offset += $self->start_range;my$handle=$self->handle;$handle->sysseek($offset,SEEK_SET);my$buffer;if (defined(my$end=$self->end_range)){return '' if (my$chunk=$end + 1 - $offset)<= 0;$handle->sysread($buffer,$chunk > $max ? $max : $chunk)}else {$handle->sysread($buffer,$max)}return$buffer}sub is_file {1}sub move_to {my ($self,$to)=@_;close$self->handle;delete$self->{handle};my$from=$self->path;move($from,$to)or croak qq{Can't move file "$from" to "$to": $!};return$self->path($to)->cleanup(0)}sub mtime {(stat shift->handle)[9]}sub size {-s shift->handle}sub slurp {my$handle=shift->handle;$handle->sysseek(0,SEEK_SET);defined$handle->sysread(my$content,-s $handle,0)or croak qq{Can't read from asset: $!};return$content}1;
MOJO_ASSET_FILE

$fatpacked{"Mojo/Asset/Memory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_ASSET_MEMORY';
  package Mojo::Asset::Memory;use Mojo::Base 'Mojo::Asset';use Mojo::Asset::File;use Mojo::Util 'spurt';has 'auto_upgrade';has max_memory_size=>sub {$ENV{MOJO_MAX_MEMORY_SIZE}|| 262144};has mtime=>sub {$^T};sub add_chunk {my ($self,$chunk)=@_;$self->{content}.= $chunk // '';return$self if!$self->auto_upgrade || $self->size <= $self->max_memory_size;my$file=Mojo::Asset::File->new;return$file->add_chunk($self->emit(upgrade=>$file)->slurp)}sub contains {my ($self,$str)=@_;my$start=$self->start_range;my$pos=index$self->{content}// '',$str,$start;$pos -= $start if$start && $pos >= 0;my$end=$self->end_range;return$end && ($pos + length$str)>= $end ? -1 : $pos}sub get_chunk {my ($self,$offset,$max)=@_;$max //= 131072;$offset += $self->start_range;if (my$end=$self->end_range){$max=$end + 1 - $offset if ($offset + $max)> $end}return substr shift->{content}// '',$offset,$max}sub move_to {my ($self,$to)=@_;spurt$self->{content}// '',$to;return$self}sub size {length(shift->{content}// '')}sub slurp {shift->{content}// ''}1;
MOJO_ASSET_MEMORY

$fatpacked{"Mojo/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_BASE';
  package Mojo::Base;use strict;use warnings;use utf8;use feature ();use Carp ();use IO::Handle ();my$NAME =eval {require Sub::Util;Sub::Util->can('set_subname')}|| sub {$_[1]};sub DESTROY {}sub _monkey_patch {my ($class,%patch)=@_;no strict 'refs';no warnings 'redefine';*{"${class}::$_"}=$NAME->("${class}::$_",$patch{$_})for keys%patch}sub attr {my ($self,$attrs,$value)=@_;return unless (my$class=ref$self || $self)&& $attrs;Carp::croak 'Default has to be a code reference or constant value' if ref$value && ref$value ne 'CODE';for my$attr (@{ref$attrs eq 'ARRAY' ? $attrs : [$attrs]}){Carp::croak qq{Attribute "$attr" invalid} unless$attr =~ /^[a-zA-Z_]\w*$/;if (ref$value){_monkey_patch$class,$attr,sub {return exists $_[0]{$attr}? $_[0]{$attr}: ($_[0]{$attr}=$value->($_[0]))if @_==1;$_[0]{$attr}=$_[1];$_[0]}}elsif (defined$value){_monkey_patch$class,$attr,sub {return exists $_[0]{$attr}? $_[0]{$attr}: ($_[0]{$attr}=$value)if @_==1;$_[0]{$attr}=$_[1];$_[0]}}else {_monkey_patch$class,$attr,sub {return $_[0]{$attr}if @_==1;$_[0]{$attr}=$_[1];$_[0]}}}}sub import {my$class=shift;return unless my$flag=shift;if ($flag eq '-base'){$flag=$class}elsif ($flag eq '-strict'){$flag=undef}elsif ((my$file=$flag)&&!$flag->can('new')){$file =~ s!::|'!/!g;require "$file.pm"}if ($flag){my$caller=caller;no strict 'refs';push @{"${caller}::ISA"},$flag;_monkey_patch$caller,'has',sub {attr($caller,@_)}}$_->import for qw(strict warnings utf8);feature->import(':5.10')}sub new {my$class=shift;bless @_ ? @_ > 1 ? {@_}: {%{$_[0]}}: {},ref$class || $class}sub tap {my ($self,$cb)=(shift,shift);$_->$cb(@_)for$self;return$self}1;
MOJO_BASE

$fatpacked{"Mojo/ByteStream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_BYTESTREAM';
  package Mojo::ByteStream;use Mojo::Base -strict;use overload bool=>sub {1},'""'=>sub {${$_[0]}},fallback=>1;use Exporter 'import';use Mojo::Collection;use Mojo::Util;our@EXPORT_OK=('b');my@UTILS=(qw(b64_decode b64_encode camelize decamelize hmac_sha1_sum html_unescape),qw(md5_bytes md5_sum punycode_decode punycode_encode quote sha1_bytes),qw(sha1_sum slurp spurt squish term_escape trim unindent unquote),qw(url_escape url_unescape xml_escape xor_encode));for my$name (@UTILS){my$sub=Mojo::Util->can($name);Mojo::Util::monkey_patch __PACKAGE__,$name,sub {my$self=shift;$$self=$sub->($$self,@_);return$self}}sub b {__PACKAGE__->new(@_)}sub clone {$_[0]->new(${$_[0]})}sub decode {shift->_delegate(\&Mojo::Util::decode,@_)}sub encode {shift->_delegate(\&Mojo::Util::encode,@_)}sub new {my$class=shift;return bless \(my$dummy=join '',@_),ref$class || $class}sub say {my ($self,$handle)=@_;$handle ||= \*STDOUT;say$handle $$self;return$self}sub secure_compare {Mojo::Util::secure_compare ${shift()},shift}sub size {length ${$_[0]}}sub split {my ($self,$pattern)=@_;return Mojo::Collection->new(map {$self->new($_)}split$pattern,$$self)}sub tap {shift->Mojo::Base::tap(@_)}sub to_string {${$_[0]}}sub _delegate {my ($self,$sub)=(shift,shift);$$self=$sub->(shift || 'UTF-8',$$self);return$self}1;
MOJO_BYTESTREAM

$fatpacked{"Mojo/Cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CACHE';
  package Mojo::Cache;use Mojo::Base -base;has 'max_keys'=>100;sub get {(shift->{cache}|| {})->{shift()}}sub set {my ($self,$key,$value)=@_;return$self unless (my$max=$self->max_keys)> 0;my$cache=$self->{cache}||= {};my$queue=$self->{queue}||= [];delete$cache->{shift @$queue}while @$queue >= $max;push @$queue,$key unless exists$cache->{$key};$cache->{$key}=$value;return$self}1;
MOJO_CACHE

$fatpacked{"Mojo/Collection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COLLECTION';
  package Mojo::Collection;use Mojo::Base -strict;use Carp 'croak';use Exporter 'import';use List::Util;use Mojo::ByteStream;use Scalar::Util 'blessed';our@EXPORT_OK=('c');sub TO_JSON {[@{shift()}]}sub c {__PACKAGE__->new(@_)}sub compact {my$self=shift;return$self->new(grep {defined && (ref || length)}@$self)}sub each {my ($self,$cb)=@_;return @$self unless$cb;my$i=1;$_->$cb($i++)for @$self;return$self}sub first {my ($self,$cb)=(shift,shift);return$self->[0]unless$cb;return List::Util::first {$_ =~ $cb}@$self if ref$cb eq 'Regexp';return List::Util::first {$_->$cb(@_)}@$self}sub flatten {$_[0]->new(_flatten(@{$_[0]}))}sub grep {my ($self,$cb)=(shift,shift);return$self->new(grep {$_ =~ $cb}@$self)if ref$cb eq 'Regexp';return$self->new(grep {$_->$cb(@_)}@$self)}sub join {Mojo::ByteStream->new(join $_[1]// '',map {"$_"}@{$_[0]})}sub last {shift->[-1]}sub map {my ($self,$cb)=(shift,shift);return$self->new(map {$_->$cb(@_)}@$self)}sub new {my$class=shift;return bless [@_],ref$class || $class}sub reduce {my$self=shift;@_=(@_,@$self);goto&List::Util::reduce}sub reverse {$_[0]->new(reverse @{$_[0]})}sub shuffle {$_[0]->new(List::Util::shuffle @{$_[0]})}sub size {scalar @{$_[0]}}sub slice {my$self=shift;return$self->new(@$self[@_])}sub sort {my ($self,$cb)=@_;return$self->new(sort @$self)unless$cb;my$caller=caller;no strict 'refs';my@sorted=sort {local (*{"${caller}::a"},*{"${caller}::b"})=(\$a,\$b);$a->$cb($b)}@$self;return$self->new(@sorted)}sub tap {shift->Mojo::Base::tap(@_)}sub to_array {[@{shift()}]}sub uniq {my ($self,$cb)=(shift,shift);my%seen;return$self->new(grep {!$seen{$_->$cb(@_)}++}@$self)if$cb;return$self->new(grep {!$seen{$_}++}@$self)}sub _flatten {map {_ref($_)? _flatten(@$_): $_}@_}sub _ref {ref $_[0]eq 'ARRAY' || blessed $_[0]&& $_[0]->isa(__PACKAGE__)}1;
MOJO_COLLECTION

$fatpacked{"Mojo/Content.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CONTENT';
  package Mojo::Content;use Mojo::Base 'Mojo::EventEmitter';use Carp 'croak';use Compress::Raw::Zlib qw(WANT_GZIP Z_STREAM_END);use Mojo::Headers;use Scalar::Util 'looks_like_number';has [qw(auto_decompress auto_relax expect_close relaxed skip_body)];has headers=>sub {Mojo::Headers->new};has max_buffer_size=>sub {$ENV{MOJO_MAX_BUFFER_SIZE}|| 262144};has max_leftover_size=>sub {$ENV{MOJO_MAX_LEFTOVER_SIZE}|| 262144};my$BOUNDARY_RE =qr!multipart.*boundary\s*=\s*(?:"([^"]+)"|([\w'(),.:?\-+/]+))!i;sub body_contains {croak 'Method "body_contains" not implemented by subclass'}sub body_size {croak 'Method "body_size" not implemented by subclass'}sub boundary {(shift->headers->content_type // '')=~ $BOUNDARY_RE ? $1 // $2 : undef}sub charset {my$type=shift->headers->content_type // '';return$type =~ /charset\s*=\s*"?([^"\s;]+)"?/i ? $1 : undef}sub clone {my$self=shift;return undef if$self->is_dynamic;return$self->new(headers=>$self->headers->clone)}sub generate_body_chunk {my ($self,$offset)=@_;$self->emit(drain=>$offset)if ($self->{body_buffer}// '')eq '';my$chunk=delete$self->{body_buffer}// '';return$self->{eof}? '' : undef if$chunk eq '';return$chunk}sub get_body_chunk {croak 'Method "get_body_chunk" not implemented by subclass'}sub get_header_chunk {substr shift->_headers->{header_buffer},shift,131072}sub header_size {length shift->_headers->{header_buffer}}sub headers_contain {index(shift->_headers->{header_buffer},shift)>= 0}sub is_chunked {!!shift->headers->transfer_encoding}sub is_compressed {lc(shift->headers->content_encoding // '')eq 'gzip'}sub is_dynamic {$_[0]{dynamic}&&!defined $_[0]->headers->content_length}sub is_finished {(shift->{state}// '')eq 'finished'}sub is_limit_exceeded {!!shift->{limit}}sub is_multipart {undef}sub is_parsing_body {(shift->{state}// '')eq 'body'}sub leftovers {shift->{buffer}}sub parse {my$self=shift;$self->_parse_until_body(@_);return$self if$self->{state}eq 'headers';$self->{real_size}//= 0;if ($self->is_chunked && $self->{state}ne 'headers'){$self->_parse_chunked;$self->{state}='finished' if ($self->{chunk_state}// '')eq 'finished'}else {$self->{real_size}+= length$self->{pre_buffer};my$limit=$self->is_finished && length($self->{buffer})> $self->max_leftover_size;$self->{buffer}.= $self->{pre_buffer}unless$limit;$self->{pre_buffer}=''}if ($self->skip_body){$self->{state}='finished';return$self}my$headers=$self->headers;my$len=$headers->content_length // '';if ($self->auto_relax && $len eq ''){my$connection=lc($headers->connection // '');$self->relaxed(1)if$connection eq 'close' || (!$connection && $self->expect_close)}if ($self->is_chunked || $self->relaxed){$self->_decompress($self->{buffer}//= '');$self->{size}+= length$self->{buffer};$self->{buffer}='';return$self}$len=0 unless looks_like_number$len;if ((my$need=$len - ($self->{size}||= 0))> 0){my$len=length$self->{buffer};my$chunk=substr$self->{buffer},0,$need > $len ? $len : $need,'';$self->_decompress($chunk);$self->{size}+= length$chunk}$self->{state}='finished' if$len <= $self->progress;return$self}sub parse_body {my$self=shift;$self->{state}='body';return$self->parse(@_)}sub progress {my$self=shift;return 0 unless my$state=$self->{state};return 0 unless$state eq 'body' || $state eq 'finished';return$self->{raw_size}- ($self->{header_size}|| 0)}sub write {my ($self,$chunk,$cb)=@_;$self->{dynamic}=1;$self->{body_buffer}.= $chunk if defined$chunk;$self->once(drain=>$cb)if$cb;$self->{eof}=1 if defined$chunk && $chunk eq '';return$self}sub write_chunk {my ($self,$chunk,$cb)=@_;$self->headers->transfer_encoding('chunked')unless$self->is_chunked;$self->write(defined$chunk ? $self->_build_chunk($chunk): $chunk,$cb);$self->{eof}=1 if defined$chunk && $chunk eq '';return$self}sub _build_chunk {my ($self,$chunk)=@_;return "\x0d\x0a0\x0d\x0a\x0d\x0a" if$chunk eq '';my$crlf=$self->{chunks}++ ? "\x0d\x0a" : '';return$crlf .sprintf('%x',length$chunk)."\x0d\x0a$chunk"}sub _decompress {my ($self,$chunk)=@_;return$self->emit(read=>$chunk)unless$self->auto_decompress && $self->is_compressed;$self->{post_buffer}.= $chunk;my$gz=$self->{gz}//= Compress::Raw::Zlib::Inflate->new(WindowBits=>WANT_GZIP);my$status=$gz->inflate(\$self->{post_buffer},my$out);$self->emit(read=>$out)if defined$out;$self->headers->content_length($gz->total_out)->remove('Content-Encoding')if$status==Z_STREAM_END;@$self{qw(state limit)}=('finished',1)if length($self->{post_buffer}// '')> $self->max_buffer_size}sub _headers {my$self=shift;return$self if defined$self->{header_buffer};my$headers=$self->headers->to_string;$self->{header_buffer}=$headers ? "$headers\x0d\x0a\x0d\x0a" : "\x0d\x0a";return$self}sub _parse_chunked {my$self=shift;return$self->_parse_chunked_trailing_headers if ($self->{chunk_state}// '')eq 'trailing_headers';while (my$len=length$self->{pre_buffer}){unless ($self->{chunk_len}){last unless$self->{pre_buffer}=~ s/^(?:\x0d?\x0a)?([0-9a-fA-F]+).*\x0a//;next if$self->{chunk_len}=hex $1;$self->{chunk_state}='trailing_headers';last}$len=$self->{chunk_len}if$self->{chunk_len}< $len;$self->{buffer}.= substr$self->{pre_buffer},0,$len,'';$self->{real_size}+= $len;$self->{chunk_len}-= $len}$self->_parse_chunked_trailing_headers if ($self->{chunk_state}// '')eq 'trailing_headers';@$self{qw(state limit)}=('finished',1)if length($self->{pre_buffer}// '')> $self->max_buffer_size}sub _parse_chunked_trailing_headers {my$self=shift;my$headers=$self->headers->parse(delete$self->{pre_buffer});return unless$headers->is_finished;$self->{chunk_state}='finished';$self->{buffer}.= $headers->leftovers;$headers->remove('Transfer-Encoding');$headers->content_length($self->{real_size})unless$headers->content_length}sub _parse_headers {my$self=shift;my$headers=$self->headers->parse(delete$self->{pre_buffer});return unless$headers->is_finished;$self->{state}='body';my$leftovers=$self->{pre_buffer}=$headers->leftovers;$self->{header_size}=$self->{raw_size}- length$leftovers}sub _parse_until_body {my ($self,$chunk)=@_;$self->{raw_size}+= length($chunk //= '');$self->{pre_buffer}.= $chunk;$self->_parse_headers if ($self->{state}||= 'headers')eq 'headers';$self->emit('body')if$self->{state}ne 'headers' &&!$self->{body}++}1;
MOJO_CONTENT

$fatpacked{"Mojo/Content/MultiPart.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CONTENT_MULTIPART';
  package Mojo::Content::MultiPart;use Mojo::Base 'Mojo::Content';use Mojo::Util 'b64_encode';has parts=>sub {[]};sub body_contains {my ($self,$chunk)=@_;($_->headers_contain($chunk)or $_->body_contains($chunk))and return 1 for @{$self->parts};return undef}sub body_size {my$self=shift;if (my$len=$self->headers->content_length){return$len}my$len=my$boundary_len=length($self->build_boundary)+ 6;$len += $_->header_size + $_->body_size + $boundary_len for @{$self->parts};return$len}sub build_boundary {my$self=shift;my$boundary;return$boundary if defined($boundary=$self->boundary);my$size=1;do {$boundary=b64_encode join('',map chr(rand 256),1 .. $size++ * 3);$boundary =~ s/\W/X/g}while$self->body_contains($boundary);my$headers=$self->headers;($headers->content_type // '')=~ m!^(.*multipart/[^;]+)(.*)$!;my$before=$1 || 'multipart/mixed';my$after=$2 || '';$headers->content_type("$before; boundary=$boundary$after");return$boundary}sub clone {my$self=shift;return undef unless my$clone=$self->SUPER::clone();return$clone->parts($self->parts)}sub get_body_chunk {my ($self,$offset)=@_;return$self->generate_body_chunk($offset)if$self->{dynamic};my$boundary=$self->build_boundary;my$boundary_len=length($boundary)+ 6;my$len=$boundary_len - 2;return substr "--$boundary\x0d\x0a",$offset if$len > $offset;my$parts=$self->parts;for (my$i=0;$i < @$parts;$i++){my$part=$parts->[$i];my$header_len=$part->header_size;return$part->get_header_chunk($offset - $len)if ($len + $header_len)> $offset;$len += $header_len;my$content_len=$part->body_size;return$part->get_body_chunk($offset - $len)if ($len + $content_len)> $offset;$len += $content_len;if ($#$parts==$i){$boundary .= '--';$boundary_len += 2}return substr "\x0d\x0a--$boundary\x0d\x0a",$offset - $len if ($len + $boundary_len)> $offset;$len += $boundary_len}}sub is_multipart {1}sub new {my$self=shift->SUPER::new(@_);$self->on(read=>\&_read);return$self}sub _parse_multipart_body {my ($self,$boundary)=@_;my$pos=index$self->{multipart},"\x0d\x0a--$boundary";if ($pos < 0){my$len=length($self->{multipart})- (length($boundary)+ 8);return undef unless$len > 0;my$chunk=substr$self->{multipart},0,$len,'';$self->parts->[-1]=$self->parts->[-1]->parse($chunk);return undef}my$chunk=substr$self->{multipart},0,$pos,'';$self->parts->[-1]=$self->parts->[-1]->parse($chunk);return!!($self->{multi_state}='multipart_boundary')}sub _parse_multipart_boundary {my ($self,$boundary)=@_;if ((index$self->{multipart},"\x0d\x0a--$boundary\x0d\x0a")==0){substr$self->{multipart},0,length($boundary)+ 6,'';my$part=Mojo::Content::Single->new(relaxed=>1);$self->emit(part=>$part);push @{$self->parts},$part;return!!($self->{multi_state}='multipart_body')}my$end="\x0d\x0a--$boundary--";if ((index$self->{multipart},$end)==0){substr$self->{multipart},0,length$end,'';$self->{multi_state}='finished'}return undef}sub _parse_multipart_preamble {my ($self,$boundary)=@_;return undef if (my$pos=index$self->{multipart},"--$boundary")< 0;substr$self->{multipart},0,$pos,"\x0d\x0a";return!!($self->{multi_state}='multipart_boundary')}sub _read {my ($self,$chunk)=@_;$self->{multipart}.= $chunk;my$boundary=$self->boundary;until (($self->{multi_state}//= 'multipart_preamble')eq 'finished'){if ($self->{multi_state}eq 'multipart_preamble'){last unless$self->_parse_multipart_preamble($boundary)}elsif ($self->{multi_state}eq 'multipart_boundary'){last unless$self->_parse_multipart_boundary($boundary)}elsif ($self->{multi_state}eq 'multipart_body'){last unless$self->_parse_multipart_body($boundary)}}@$self{qw(state limit)}=('finished',1)if length($self->{multipart}// '')> $self->max_buffer_size}1;
MOJO_CONTENT_MULTIPART

$fatpacked{"Mojo/Content/Single.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_CONTENT_SINGLE';
  package Mojo::Content::Single;use Mojo::Base 'Mojo::Content';use Mojo::Asset::Memory;use Mojo::Content::MultiPart;has asset=>sub {Mojo::Asset::Memory->new(auto_upgrade=>1)};has auto_upgrade=>1;sub body_contains {shift->asset->contains(shift)>= 0}sub body_size {my$self=shift;return ($self->headers->content_length || 0)if$self->{dynamic};return$self->asset->size}sub clone {my$self=shift;return undef unless my$clone=$self->SUPER::clone();return$clone->asset($self->asset)}sub get_body_chunk {my ($self,$offset)=@_;return$self->generate_body_chunk($offset)if$self->{dynamic};return$self->asset->get_chunk($offset)}sub new {my$self=shift->SUPER::new(@_);$self->{read}=$self->on(read=>sub {$_[0]->asset($_[0]->asset->add_chunk($_[1]))});return$self}sub parse {my$self=shift;$self->_parse_until_body(@_);return$self->SUPER::parse unless$self->auto_upgrade && defined$self->boundary;$self->unsubscribe(read=>$self->{read});my$multi=Mojo::Content::MultiPart->new(%$self);$self->emit(upgrade=>$multi);return$multi->parse}1;
MOJO_CONTENT_SINGLE

$fatpacked{"Mojo/Cookie.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COOKIE';
  package Mojo::Cookie;use Mojo::Base -base;use overload bool=>sub {1},'""'=>sub {shift->to_string},fallback=>1;use Carp 'croak';has [qw(name value)];sub parse {croak 'Method "parse" not implemented by subclass'}sub to_string {croak 'Method "to_string" not implemented by subclass'}1;
MOJO_COOKIE

$fatpacked{"Mojo/Cookie/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COOKIE_REQUEST';
  package Mojo::Cookie::Request;use Mojo::Base 'Mojo::Cookie';use Mojo::Util qw(quote split_header);sub parse {my ($self,$str)=@_;my@cookies;my@pairs=map {@$_}@{split_header$str // ''};while (my ($name,$value)=splice@pairs,0,2){next if$name =~ /^\$/;push@cookies,$self->new(name=>$name,value=>$value // '')}return \@cookies}sub to_string {my$self=shift;return '' if (my$name=$self->name // '')eq '';my$value=$self->value // '';return join '=',$name,$value =~ /[,;" ]/ ? quote$value : $value}1;
MOJO_COOKIE_REQUEST

$fatpacked{"Mojo/Cookie/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_COOKIE_RESPONSE';
  package Mojo::Cookie::Response;use Mojo::Base 'Mojo::Cookie';use Mojo::Date;use Mojo::Util qw(quote split_cookie_header);has [qw(domain expires httponly max_age origin path secure)];my%ATTRS=map {$_=>1}qw(domain expires httponly max-age path secure);sub parse {my ($self,$str)=@_;my@cookies;my$tree=split_cookie_header$str // '';while (my$pairs=shift @$tree){my ($name,$value)=splice @$pairs,0,2;push@cookies,$self->new(name=>$name,value=>$value // '');while (my ($name,$value)=splice @$pairs,0,2){next unless$ATTRS{my$attr=lc$name};$value =~ s/^\.// if$attr eq 'domain' && defined$value;$value=Mojo::Date->new($value // '')->epoch if$attr eq 'expires';$value=1 if$attr eq 'secure' || $attr eq 'httponly';$cookies[-1]{$attr eq 'max-age' ? 'max_age' : $attr}=$value}}return \@cookies}sub to_string {my$self=shift;return '' if (my$name=$self->name // '')eq '';my$value=$self->value // '';my$cookie=join '=',$name,$value =~ /[,;" ]/ ? quote$value : $value;my$expires=$self->expires;$cookie .= '; expires=' .Mojo::Date->new($expires)if defined$expires;if (my$domain=$self->domain){$cookie .= "; domain=$domain"}if (my$path=$self->path){$cookie .= "; path=$path"}$cookie .= "; secure" if$self->secure;$cookie .= "; HttpOnly" if$self->httponly;if (defined(my$max=$self->max_age)){$cookie .= "; Max-Age=$max"}return$cookie}1;
MOJO_COOKIE_RESPONSE

$fatpacked{"Mojo/DOM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DOM';
  package Mojo::DOM;use Mojo::Base -strict;use overload '@{}'=>sub {shift->child_nodes},'%{}'=>sub {shift->attr},bool=>sub {1},'""'=>sub {shift->to_string},fallback=>1;use Carp 'croak';use Mojo::Collection;use Mojo::DOM::CSS;use Mojo::DOM::HTML;use Mojo::Util 'squish';use Scalar::Util qw(blessed weaken);sub all_text {shift->_all_text(1,@_)}sub ancestors {_select($_[0]->_collect($_[0]->_ancestors),$_[1])}sub append {shift->_add(1,@_)}sub append_content {shift->_content(1,0,@_)}sub at {my$self=shift;return undef unless my$result=$self->_css->select_one(@_);return$self->_build($result,$self->xml)}sub attr {my$self=shift;my$tree=$self->tree;my$attrs=$tree->[0]ne 'tag' ? {}: $tree->[2];return$attrs unless @_;return$attrs->{$_[0]}unless @_ > 1 || ref $_[0];my$values=ref $_[0]? $_[0]: {@_};@$attrs{keys %$values}=values %$values;return$self}sub child_nodes {$_[0]->_collect(_nodes($_[0]->tree))}sub children {_select($_[0]->_collect(_nodes($_[0]->tree,1)),$_[1])}sub content {my$self=shift;my$type=$self->type;if ($type eq 'root' || $type eq 'tag'){return$self->_content(0,1,@_)if @_;my$html=Mojo::DOM::HTML->new(xml=>$self->xml);return join '',map {$html->tree($_)->render}_nodes($self->tree)}return$self->tree->[1]unless @_;$self->tree->[1]=shift;return$self}sub descendant_nodes {$_[0]->_collect(_all(_nodes($_[0]->tree)))}sub find {$_[0]->_collect(@{$_[0]->_css->select($_[1])})}sub following {_select($_[0]->_collect(@{$_[0]->_siblings(1)->[1]}),$_[1])}sub following_nodes {$_[0]->_collect(@{$_[0]->_siblings->[1]})}sub matches {shift->_css->matches(@_)}sub namespace {my$self=shift;return undef if (my$tree=$self->tree)->[0]ne 'tag';my$ns=$tree->[1]=~ /^(.*?):/ ? "xmlns:$1" : undef;for my$node ($tree,$self->_ancestors){my$attrs=$node->[2];if ($ns){$_ eq $ns and return$attrs->{$_}for keys %$attrs}elsif (defined$attrs->{xmlns}){return$attrs->{xmlns}}}return undef}sub new {my$class=shift;my$self=bless \Mojo::DOM::HTML->new,ref$class || $class;return @_ ? $self->parse(@_): $self}sub next {$_[0]->_maybe($_[0]->_siblings(1,0)->[1])}sub next_node {$_[0]->_maybe($_[0]->_siblings(0,0)->[1])}sub parent {my$self=shift;return undef if$self->tree->[0]eq 'root';return$self->_build($self->_parent,$self->xml)}sub parse {shift->_delegate(parse=>@_)}sub preceding {_select($_[0]->_collect(@{$_[0]->_siblings(1)->[0]}),$_[1])}sub preceding_nodes {$_[0]->_collect(@{$_[0]->_siblings->[0]})}sub prepend {shift->_add(0,@_)}sub prepend_content {shift->_content(0,0,@_)}sub previous {$_[0]->_maybe($_[0]->_siblings(1,-1)->[0])}sub previous_node {$_[0]->_maybe($_[0]->_siblings(0,-1)->[0])}sub remove {shift->replace('')}sub replace {my ($self,$new)=@_;return$self->parse($new)if (my$tree=$self->tree)->[0]eq 'root';return$self->_replace($self->_parent,$tree,_nodes($self->_parse($new)))}sub root {my$self=shift;return$self unless my$tree=$self->_ancestors(1);return$self->_build($tree,$self->xml)}sub strip {my$self=shift;return$self if (my$tree=$self->tree)->[0]ne 'tag';return$self->_replace($tree->[3],$tree,_nodes($tree))}sub tag {my ($self,$tag)=@_;return undef if (my$tree=$self->tree)->[0]ne 'tag';return$tree->[1]unless$tag;$tree->[1]=$tag;return$self}sub tap {shift->Mojo::Base::tap(@_)}sub text {shift->_all_text(0,@_)}sub to_string {shift->_delegate('render')}sub tree {shift->_delegate(tree=>@_)}sub type {shift->tree->[0]}sub val {my$self=shift;return$self->{value}// $self->text if (my$tag=$self->tag)eq 'option';return$tag eq 'textarea' ? $self->text : $self->{value}if$tag ne 'select';my$v=$self->find('option:checked')->map('val');return exists$self->{multiple}? $v->size ? $v->to_array : undef : $v->last}sub wrap {shift->_wrap(0,@_)}sub wrap_content {shift->_wrap(1,@_)}sub xml {shift->_delegate(xml=>@_)}sub _add {my ($self,$offset,$new)=@_;return$self if (my$tree=$self->tree)->[0]eq 'root';my$parent=$self->_parent;splice @$parent,_offset($parent,$tree)+ $offset,0,_link($parent,_nodes($self->_parse($new)));return$self}sub _all {map {$_->[0]eq 'tag' ? ($_,_all(_nodes($_))): ($_)}@_}sub _all_text {my ($self,$recurse,$trim)=@_;my$tree=$self->tree;$trim=1 unless defined$trim;map {$_->[1]eq 'pre' and $trim=0}$self->_ancestors,$tree if$trim && $tree->[0]ne 'root';return _text([_nodes($tree)],$recurse,$trim)}sub _ancestors {my ($self,$root)=@_;return ()unless my$tree=$self->_parent;my@ancestors;do {push@ancestors,$tree}while ($tree->[0]eq 'tag')&& ($tree=$tree->[3]);return$root ? $ancestors[-1]: @ancestors[0 .. $#ancestors - 1]}sub _build {shift->new->tree(shift)->xml(shift)}sub _collect {my$self=shift;my$xml=$self->xml;return Mojo::Collection->new(map {$self->_build($_,$xml)}@_)}sub _content {my ($self,$start,$offset,$new)=@_;my$tree=$self->tree;unless ($tree->[0]eq 'root' || $tree->[0]eq 'tag'){my$old=$self->content;return$self->content($start ? "$old$new" : "$new$old")}$start=$start ? ($#$tree + 1): _start($tree);$offset=$offset ? $#$tree : 0;splice @$tree,$start,$offset,_link($tree,_nodes($self->_parse($new)));return$self}sub _css {Mojo::DOM::CSS->new(tree=>shift->tree)}sub _delegate {my ($self,$method)=(shift,shift);return $$self->$method unless @_;$$self->$method(@_);return$self}sub _link {my ($parent,@children)=@_;for my$node (@children){my$offset=$node->[0]eq 'tag' ? 3 : 2;$node->[$offset]=$parent;weaken$node->[$offset]}return@children}sub _maybe {$_[1]? $_[0]->_build($_[1],$_[0]->xml): undef}sub _nodes {return ()unless my$tree=shift;my@nodes=@$tree[_start($tree).. $#$tree];return shift()? grep {$_->[0]eq 'tag'}@nodes : @nodes}sub _offset {my ($parent,$child)=@_;my$i=_start($parent);$_ eq $child ? last : $i++ for @$parent[$i .. $#$parent];return$i}sub _parent {$_[0]->tree->[$_[0]->type eq 'tag' ? 3 : 2]}sub _parse {Mojo::DOM::HTML->new(xml=>shift->xml)->parse(shift)->tree}sub _replace {my ($self,$parent,$child,@nodes)=@_;splice @$parent,_offset($parent,$child),1,_link($parent,@nodes);return$self->parent}sub _select {my ($collection,$selector)=@_;return$collection unless$selector;return$collection->new(grep {$_->matches($selector)}@$collection)}sub _siblings {my ($self,$tags,$i)=@_;return []unless my$parent=$self->parent;my$tree=$self->tree;my (@before,@after,$match);for my$node (_nodes($parent->tree)){++$match and next if!$match && $node eq $tree;next if$tags && $node->[0]ne 'tag';$match ? push@after,$node : push@before,$node}return defined$i ? [$before[$i],$after[$i]]: [\@before,\@after]}sub _start {$_[0][0]eq 'root' ? 1 : 4}sub _text {my ($nodes,$recurse,$trim)=@_;my$i=0;while (my$next=$nodes->[$i + 1]){++$i and next unless$nodes->[$i][0]eq 'text' && $next->[0]eq 'text';splice @$nodes,$i,2,['text',$nodes->[$i][1].$next->[1]]}my$text='';for my$node (@$nodes){my$type=$node->[0];my$chunk='';if ($type eq 'text'){$chunk=$trim ? squish$node->[1]: $node->[1]}elsif ($type eq 'cdata' || $type eq 'raw'){$chunk=$node->[1]}elsif ($type eq 'tag' && $recurse){no warnings 'recursion';$chunk=_text([_nodes($node)],1,$node->[1]eq 'pre' ? 0 : $trim)}$chunk=" $chunk" if$text =~ /\S\z/ && $chunk =~ /^[^.!?,;:\s]+/;$text .= $chunk if$chunk =~ /\S+/ ||!$trim}return$text}sub _wrap {my ($self,$content,$new)=@_;return$self if (my$tree=$self->tree)->[0]eq 'root' &&!$content;return$self if$tree->[0]ne 'root' && $tree->[0]ne 'tag' && $content;my$current;my$first=$new=$self->_parse($new);$current=$first while$first=(_nodes($first,1))[0];return$self unless$current;if ($content){push @$current,_link($current,_nodes($tree));splice @$tree,_start($tree),$#$tree,_link($tree,_nodes($new));return$self}$self->_replace($self->_parent,$tree,_nodes($new));push @$current,_link($current,$tree);return$self}1;
MOJO_DOM

$fatpacked{"Mojo/DOM/CSS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DOM_CSS';
  package Mojo::DOM::CSS;use Mojo::Base -base;use Mojo::Util 'trim';has 'tree';my$ESCAPE_RE=qr/\\[^0-9a-fA-F]|\\[0-9a-fA-F]{1,6}/;my$ATTR_RE=qr/
    \[
    ((?:$ESCAPE_RE|[\w\-])+)                              # Key
    (?:
      (\W)?=                                              # Operator
      (?:"((?:\\"|[^"])*)"|'((?:\\'|[^'])*)'|([^\]]+?))   # Value
      (?:\s+(i))?                                         # Case-sensitivity
    )?
    \]
  /x;sub matches {my$tree=shift->tree;return$tree->[0]ne 'tag' ? undef : _match(_compile(shift),$tree,$tree)}sub select {_select(0,shift->tree,_compile(@_))}sub select_one {_select(1,shift->tree,_compile(@_))}sub _ancestor {my ($selectors,$current,$tree,$one,$pos)=@_;while ($current=$current->[3]){return undef if$current->[0]eq 'root' || $current eq $tree;return 1 if _combinator($selectors,$current,$tree,$pos);last if$one}return undef}sub _attr {my ($name_re,$value_re,$current)=@_;my$attrs=$current->[2];for my$name (keys %$attrs){next unless$name =~ $name_re;return 1 unless defined$attrs->{$name}&& defined$value_re;return 1 if$attrs->{$name}=~ $value_re}return undef}sub _combinator {my ($selectors,$current,$tree,$pos)=@_;return undef unless my$c=$selectors->[$pos];if (ref$c){return undef unless _selector($c,$current);return 1 unless$c=$selectors->[++$pos]}return _ancestor($selectors,$current,$tree,1,++$pos)if$c eq '>';return _sibling($selectors,$current,$tree,0,++$pos)if$c eq '~';return _sibling($selectors,$current,$tree,1,++$pos)if$c eq '+';return _ancestor($selectors,$current,$tree,0,++$pos)}sub _compile {my$css=trim "$_[0]";my$group=[[]];while (my$selectors=$group->[-1]){push @$selectors,[]unless @$selectors && ref$selectors->[-1];my$last=$selectors->[-1];if ($css =~ /\G\s*,\s*/gc){push @$group,[]}elsif ($css =~ /\G\s*([ >+~])\s*/gc){push @$selectors,$1}elsif ($css =~ /\G([.#])((?:$ESCAPE_RE\s|\\.|[^,.#:[ >~+])+)/gco){my ($name,$op)=$1 eq '.' ? ('class','~'): ('id','');push @$last,['attr',_name($name),_value($op,$2)]}elsif ($css =~ /\G$ATTR_RE/gco){push @$last,['attr',_name($1),_value($2 // '',$3 // $4 // $5,$6)]}elsif ($css =~ /\G:([\w\-]+)(?:\(((?:\([^)]+\)|[^)])+)\))?/gcs){my ($name,$args)=(lc $1,$2);$args=_compile($args)if$name eq 'not';$args=_equation($args)if$name =~ /^nth-/;($name,$args)=("nth-$1",[0,1])if$name =~ /^first-(.+)$/;($name,$args)=("nth-$name",[-1,1])if$name =~ /^last-/;push @$last,['pc',$name,$args]}elsif ($css =~ /\G((?:$ESCAPE_RE\s|\\.|[^,.#:[ >~+])+)/gco){push @$last,['tag',_name($1)]unless $1 eq '*'}else {last}}return$group}sub _empty {$_[0][0]eq 'comment' || $_[0][0]eq 'pi'}sub _equation {return [0,0]unless my$equation=shift;return [2,2]if$equation =~ /^\s*even\s*$/i;return [2,1]if$equation =~ /^\s*odd\s*$/i;return [0,$1]if$equation =~ /^\s*((?:\+|-)?\d+)\s*$/;return [0,0]unless$equation =~ /^\s*((?:\+|-)?(?:\d+)?)?n\s*((?:\+|-)\s*\d+)?\s*$/i;return [$1 eq '-' ? -1 : $1 eq '' ? 1 : $1,join('',split(' ',$2 // 0))]}sub _match {my ($group,$current,$tree)=@_;_combinator([reverse @$_],$current,$tree,0)and return 1 for @$group;return undef}sub _name {qr/(?:^|:)\Q@{[_unescape(shift)]}\E$/}sub _pc {my ($class,$args,$current)=@_;return exists$current->[2]{checked}|| exists$current->[2]{selected}if$class eq 'checked';return!_match($args,$current,$current)if$class eq 'not';return!grep {!_empty($_)}@$current[4 .. $#$current]if$class eq 'empty';return$current->[3]&& $current->[3][0]eq 'root' if$class eq 'root';if (ref$args){my$type=$class =~ /of-type$/ ? $current->[1]: undef;my@siblings=@{_siblings($current,$type)};@siblings=reverse@siblings if$class =~ /^nth-last/;for my$i (0 .. $#siblings){next if (my$result=$args->[0]* $i + $args->[1])< 1;last unless my$sibling=$siblings[$result - 1];return 1 if$sibling eq $current}}elsif ($class eq 'only-child' || $class eq 'only-of-type'){my$type=$class eq 'only-of-type' ? $current->[1]: undef;$_ ne $current and return undef for @{_siblings($current,$type)};return 1}return undef}sub _select {my ($one,$tree,$group)=@_;my@results;my@queue=@$tree[($tree->[0]eq 'root' ? 1 : 4).. $#$tree];while (my$current=shift@queue){next unless$current->[0]eq 'tag';unshift@queue,@$current[4 .. $#$current];next unless _match($group,$current,$tree);$one ? return$current : push@results,$current}return$one ? undef : \@results}sub _selector {my ($selector,$current)=@_;for my$s (@$selector){my$type=$s->[0];if ($type eq 'tag'){return undef unless$current->[1]=~ $s->[1]}elsif ($type eq 'attr'){return undef unless _attr(@$s[1,2],$current)}elsif ($type eq 'pc'){return undef unless _pc(@$s[1,2],$current)}}return 1}sub _sibling {my ($selectors,$current,$tree,$immediate,$pos)=@_;my$found;for my$sibling (@{_siblings($current)}){return$found if$sibling eq $current;if ($immediate){$found=_combinator($selectors,$sibling,$tree,$pos)}else {return 1 if _combinator($selectors,$sibling,$tree,$pos)}}return undef}sub _siblings {my ($current,$type)=@_;my$parent=$current->[3];my@siblings=grep {$_->[0]eq 'tag'}@$parent[($parent->[0]eq 'root' ? 1 : 4).. $#$parent];@siblings=grep {$type eq $_->[1]}@siblings if defined$type;return \@siblings}sub _unescape {my$value=shift;$value =~ s/\\\n//g;$value =~ s/\\([0-9a-fA-F]{1,6})\s?/pack 'U', hex $1/ge;$value =~ s/\\//g;return$value}sub _value {my ($op,$value,$insensitive)=@_;return undef unless defined$value;$value=($insensitive ? '(?i)' : '').quotemeta _unescape($value);return qr/(?:^|\s+)$value(?:\s+|$)/ if$op eq '~';return qr/$value/ if$op eq '*';return qr/^$value/ if$op eq '^';return qr/$value$/ if$op eq '$';return qr/^$value$/}1;
MOJO_DOM_CSS

$fatpacked{"Mojo/DOM/HTML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DOM_HTML';
  package Mojo::DOM::HTML;use Mojo::Base -base;use Mojo::Util qw(html_unescape xml_escape);use Scalar::Util 'weaken';has tree=>sub {['root']};has 'xml';my$ATTR_RE=qr/
    ([^<>=\s\/]+|\/)                     # Key
    (?:
      \s*=\s*
      (?s:(["'])(.*?)\g{-2}|([^>\s]*))   # Value
    )?
    \s*
  /x;my$TOKEN_RE=qr/
    ([^<]+)?                                            # Text
    (?:
      <(?:
        !(?:
          DOCTYPE(
          \s+\w+                                        # Doctype
          (?:(?:\s+\w+)?(?:\s+(?:"[^"]*"|'[^']*'))+)?   # External ID
          (?:\s+\[.+?\])?                               # Int Subset
          \s*)
        |
          --(.*?)--\s*                                  # Comment
        |
          \[CDATA\[(.*?)\]\]                            # CDATA
        )
      |
        \?(.*?)\?                                       # Processing Instruction
      |
        \s*([^<>\s]+\s*(?:(?:$ATTR_RE){0,32766})*+)     # Tag
      )>
    |
      (<)                                               # Runaway "<"
    )??
  /xis;my%RAW=map {$_=>1}qw(script style);my%RCDATA=map {$_=>1}qw(title textarea);my%END=(body=>'head',optgroup=>'optgroup',option=>'option');map {$END{$_}='p'}(qw(address article aside blockquote dir div dl fieldset footer form h1 h2),qw(h3 h4 h5 h6 header hr main menu nav ol p pre section table ul));my%TABLE=map {$_=>1}qw(colgroup tbody td tfoot th thead tr);my%CLOSE =(li=>[{li=>1},{ul=>1,ol=>1}],tr=>[{tr=>1},{table=>1}]);$CLOSE{$_}=[\%TABLE,{table=>1}]for qw(colgroup tbody tfoot thead);$CLOSE{$_}=[{dd=>1,dt=>1},{dl=>1}]for qw(dd dt);$CLOSE{$_}=[{rp=>1,rt=>1},{ruby=>1}]for qw(rp rt);$CLOSE{$_}=[{th=>1,td=>1},{table=>1}]for qw(td th);my%EMPTY=map {$_=>1}(qw(area base br col embed hr img input keygen link menuitem meta param),qw(source track wbr));my@PHRASING=(qw(a abbr area audio b bdi bdo br button canvas cite code data datalist),qw(del dfn em embed i iframe img input ins kbd keygen label link map mark),qw(math meta meter noscript object output picture progress q ruby s samp),qw(script select small span strong sub sup svg template textarea time u),qw(var video wbr));my@OBSOLETE=qw(acronym applet basefont big font strike tt);my%PHRASING=map {$_=>1}@OBSOLETE,@PHRASING;my%BLOCK=map {$_=>1}(qw(a address applet article aside b big blockquote body button caption),qw(center code col colgroup dd details dialog dir div dl dt em fieldset),qw(figcaption figure font footer form frameset h1 h2 h3 h4 h5 h6 head),qw(header hgroup html i iframe li listing main marquee menu nav nobr),qw(noembed noframes noscript object ol optgroup option p plaintext pre rp),qw(rt s script section select small strike strong style summary table),qw(tbody td template textarea tfoot th thead title tr tt u ul xmp));sub parse {my ($self,$html)=(shift,"$_[0]");my$xml=$self->xml;my$current=my$tree=['root'];while ($html =~ /\G$TOKEN_RE/gcso){my ($text,$doctype,$comment,$cdata,$pi,$tag,$runaway)=($1,$2,$3,$4,$5,$6,$11);$text .= '<' if defined$runaway;_node($current,'text',html_unescape$text)if defined$text;if (defined$tag){if ($tag =~ /^\/\s*(\S+)/){_end($xml ? $1 : lc $1,$xml,\$current)}elsif ($tag =~ m!^([^\s/]+)([\s\S]*)!){my ($start,$attr)=($xml ? $1 : lc $1,$2);my (%attrs,$closing);while ($attr =~ /$ATTR_RE/go){my ($key,$value)=($xml ? $1 : lc $1,$3 // $4);++$closing and next if$key eq '/';$attrs{$key}=defined$value ? html_unescape$value : $value}$start='img' if!$xml && $start eq 'image';_start($start,\%attrs,$xml,\$current);_end($start,$xml,\$current)if!$xml && $EMPTY{$start}|| ($xml ||!$BLOCK{$start})&& $closing;next if$xml ||!$RAW{$start}&&!$RCDATA{$start};next unless$html =~ m!\G(.*?)<\s*/\s*\Q$start\E\s*>!gcsi;_node($current,'raw',$RCDATA{$start}? html_unescape $1 : $1);_end($start,0,\$current)}}elsif (defined$doctype){_node($current,'doctype',$doctype)}elsif (defined$comment){_node($current,'comment',$comment)}elsif (defined$cdata){_node($current,'cdata',$cdata)}elsif (defined$pi){$self->xml($xml=1)if!exists$self->{xml}&& $pi =~ /xml/i;_node($current,'pi',$pi)}}return$self->tree($tree)}sub render {_render($_[0]->tree,$_[0]->xml)}sub _end {my ($end,$xml,$current)=@_;my$next=$$current;do {return if$next->[0]eq 'root';return $$current=$next->[3]if$next->[1]eq $end;return if!$xml && $PHRASING{$end}&&!$PHRASING{$next->[1]}}while$next=$next->[3]}sub _node {my ($current,$type,$content)=@_;push @$current,my$new=[$type,$content,$current];weaken$new->[2]}sub _render {my ($tree,$xml)=@_;my$type=$tree->[0];return xml_escape$tree->[1]if$type eq 'text';return$tree->[1]if$type eq 'raw';return '<!DOCTYPE' .$tree->[1].'>' if$type eq 'doctype';return '<!--' .$tree->[1].'-->' if$type eq 'comment';return '<![CDATA[' .$tree->[1].']]>' if$type eq 'cdata';return '<?' .$tree->[1].'?>' if$type eq 'pi';return join '',map {_render($_,$xml)}@$tree[1 .. $#$tree]if$type eq 'root';my$tag=$tree->[1];my$result="<$tag";for my$key (sort keys %{$tree->[2]}){my$value=$tree->[2]{$key};$result .= $xml ? qq{ $key="$key"} : " $key" and next unless defined$value;$result .= qq{ $key="} .xml_escape($value).'"'}return$xml ? "$result />" : $EMPTY{$tag}? "$result>" : "$result></$tag>" unless$tree->[4];no warnings 'recursion';$result .= '>' .join '',map {_render($_,$xml)}@$tree[4 .. $#$tree];return "$result</$tag>"}sub _start {my ($start,$attrs,$xml,$current)=@_;if (!$xml && $$current->[0]ne 'root'){if (my$end=$END{$start}){_end($end,0,$current)}elsif (my$close=$CLOSE{$start}){my ($allowed,$scope)=@$close;my$parent=$$current;while ($parent->[0]ne 'root' &&!$scope->{$parent->[1]}){_end($parent->[1],0,$current)if$allowed->{$parent->[1]};$parent=$parent->[3]}}}push @$$current,my$new=['tag',$start,$attrs,$$current];weaken$new->[3];$$current=$new}1;
MOJO_DOM_HTML

$fatpacked{"Mojo/Date.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_DATE';
  package Mojo::Date;use Mojo::Base -base;use overload bool=>sub {1},'""'=>sub {shift->to_string},fallback=>1;use Time::Local 'timegm';has epoch=>sub {time};my$RFC3339_RE=qr/
    ^(\d+)-(\d+)-(\d+)\D+(\d+):(\d+):(\d+(?:\.\d+)?)   # Date and time
    (?:Z|([+-])(\d+):(\d+))?$                          # Offset
  /xi;my@DAYS=qw(Sun Mon Tue Wed Thu Fri Sat);my@MONTHS=qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);my%MONTHS;@MONTHS{@MONTHS}=(0 .. 11);sub new {@_ > 1 ? shift->SUPER::new->parse(@_): shift->SUPER::new}sub parse {my ($self,$date)=@_;return$self->epoch($date)if$date =~ /^\d+$|^\d+\.\d+$/;my$offset=0;my ($day,$month,$year,$h,$m,$s);if ($date =~ /^\w+\W+(\d+)\W+(\w+)\W+(\d+)\W+(\d+):(\d+):(\d+)\W*\w+$/){($day,$month,$year,$h,$m,$s)=($1,$MONTHS{$2},$3,$4,$5,$6)}elsif ($date =~ $RFC3339_RE){($year,$month,$day,$h,$m,$s)=($1,$2 - 1,$3,$4,$5,$6);$offset=(($8 * 3600)+ ($9 * 60))* ($7 eq '+' ? -1 : 1)if $7}elsif ($date =~ /^\w+\s+(\w+)\s+(\d+)\s+(\d+):(\d+):(\d+)\s+(\d+)$/){($month,$day,$h,$m,$s,$year)=($MONTHS{$1},$2,$3,$4,$5,$6)}else {return$self->epoch(undef)}my$epoch=eval {timegm$s,$m,$h,$day,$month,$year};return$self->epoch((defined$epoch && ($epoch += $offset)>= 0)? $epoch : undef)}sub to_datetime {my ($s,$m,$h,$day,$month,$year)=gmtime(my$epoch=shift->epoch);my$str=sprintf '%04d-%02d-%02dT%02d:%02d:%02d',$year + 1900,$month + 1,$day,$h,$m,$s;return$str .($epoch =~ /(\.\d+)$/ ? "$1Z" : 'Z')}sub to_string {my ($s,$m,$h,$mday,$month,$year,$wday)=gmtime shift->epoch;return sprintf '%s, %02d %s %04d %02d:%02d:%02d GMT',$DAYS[$wday],$mday,$MONTHS[$month],$year + 1900,$h,$m,$s}1;
MOJO_DATE

$fatpacked{"Mojo/EventEmitter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_EVENTEMITTER';
  package Mojo::EventEmitter;use Mojo::Base -base;use Scalar::Util qw(blessed weaken);use constant DEBUG=>$ENV{MOJO_EVENTEMITTER_DEBUG}|| 0;sub catch {$_[0]->on(error=>$_[1])and return $_[0]}sub emit {my ($self,$name)=(shift,shift);if (my$s=$self->{events}{$name}){warn "-- Emit $name in @{[blessed $self]} (@{[scalar @$s]})\n" if DEBUG;for my$cb (@$s){$self->$cb(@_)}}else {warn "-- Emit $name in @{[blessed $self]} (0)\n" if DEBUG;die "@{[blessed $self]}: $_[0]" if$name eq 'error'}return$self}sub has_subscribers {!!shift->{events}{shift()}}sub on {push @{$_[0]{events}{$_[1]}},$_[2]and return $_[2]}sub once {my ($self,$name,$cb)=@_;weaken$self;my$wrapper;$wrapper=sub {$self->unsubscribe($name=>$wrapper);$cb->(@_)};$self->on($name=>$wrapper);weaken$wrapper;return$wrapper}sub subscribers {shift->{events}{shift()}||= []}sub unsubscribe {my ($self,$name,$cb)=@_;if ($cb){$self->{events}{$name}=[grep {$cb ne $_}@{$self->{events}{$name}}];delete$self->{events}{$name}unless @{$self->{events}{$name}}}else {delete$self->{events}{$name}}return$self}1;
MOJO_EVENTEMITTER

$fatpacked{"Mojo/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_EXCEPTION';
  package Mojo::Exception;use Mojo::Base -base;use overload bool=>sub {1},'""'=>sub {shift->to_string},fallback=>1;use Scalar::Util 'blessed';has [qw(frames line lines_before lines_after)]=>sub {[]};has message=>'Exception!';has 'verbose';sub new {@_ > 1 ? shift->SUPER::new->_detect(@_): shift->SUPER::new}sub throw {die shift->new->trace(2)->_detect(@_)}sub to_string {my$self=shift;return$self->message unless$self->verbose;my$str=$self->message ? $self->message : '';$str .= $_->[0].': ' .$_->[1]."\n" for @{$self->lines_before};$str .= ($self->line->[0].': ' .$self->line->[1]."\n")if$self->line->[0];$str .= $_->[0].': ' .$_->[1]."\n" for @{$self->lines_after};return$str}sub trace {my ($self,$start)=@_;$start //= 1;my@frames;while (my@trace=caller($start++)){push@frames,\@trace}return$self->frames(\@frames)}sub _append {my ($stack,$line)=@_;chomp$line;push @$stack,$line}sub _context {my ($self,$num,$lines)=@_;return unless defined$lines->[0][$num - 1];$self->line([$num]);_append($self->line,$_->[$num - 1])for @$lines;for my$i (2 .. 6){last if ((my$previous=$num - $i)< 0);unshift @{$self->lines_before},[$previous + 1];_append($self->lines_before->[0],$_->[$previous])for @$lines}for my$i (0 .. 4){next if ((my$next=$num + $i)< 0);next unless defined$lines->[0][$next];push @{$self->lines_after},[$next + 1];_append($self->lines_after->[-1],$_->[$next])for @$lines}}sub _detect {my ($self,$msg,$files)=@_;return$msg if blessed$msg && $msg->isa('Mojo::Exception');$self->message($msg);my@trace;while ($msg =~ /at\s+(.+?)\s+line\s+(\d+)/g){unshift@trace,[$1,$2]}my$first=$self->frames->[0];push@trace,[$first->[1],$first->[2]]if$first;for my$frame (@trace){next unless -r $frame->[0]&& open my$handle,'<:utf8',$frame->[0];$self->_context($frame->[1],[[<$handle>]]);return$self}$self->_context($trace[-1][1],[map {[split "\n"]}@$files])if$files;return$self}1;
MOJO_EXCEPTION

$fatpacked{"Mojo/Headers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_HEADERS';
  package Mojo::Headers;use Mojo::Base -base;use Mojo::Util 'monkey_patch';has max_line_size=>sub {$ENV{MOJO_MAX_LINE_SIZE}|| 8192};has max_lines=>sub {$ENV{MOJO_MAX_LINES}|| 100};my%NORMALCASE=map {lc()=>$_}(qw(Accept Accept-Charset Accept-Encoding Accept-Language Accept-Ranges),qw(Access-Control-Allow-Origin Allow Authorization Cache-Control Connection),qw(Content-Disposition Content-Encoding Content-Language Content-Length),qw(Content-Location Content-Range Content-Security-Policy Content-Type),qw(Cookie DNT Date ETag Expect Expires Host If-Modified-Since If-None-Match),qw(Last-Modified Link Location Origin Proxy-Authenticate),qw(Proxy-Authorization Range Sec-WebSocket-Accept Sec-WebSocket-Extensions),qw(Sec-WebSocket-Key Sec-WebSocket-Protocol Sec-WebSocket-Version Server),qw(Set-Cookie Status Strict-Transport-Security TE Trailer Transfer-Encoding),qw(Upgrade User-Agent Vary WWW-Authenticate));for my$header (values%NORMALCASE){my$name=lc$header;$name =~ y/-/_/;monkey_patch __PACKAGE__,$name,sub {shift->header($header=>@_)}}sub add {my ($self,$name)=(shift,shift);my$key=lc$name;$self->{normalcase}{$key}//= $name unless$NORMALCASE{$key};push @{$self->{headers}{$key}},@_;return$self}sub append {my ($self,$name,$value)=@_;my$old=$self->header($name);return$self->header($name=>defined$old ? "$old, $value" : $value)}sub clone {$_[0]->new->from_hash($_[0]->to_hash(1))}sub from_hash {my ($self,$hash)=@_;delete$self->{headers}if keys %{$hash}==0;for my$header (keys %$hash){my$value=$hash->{$header};$self->add($header=>ref$value eq 'ARRAY' ? @$value : $value)}return$self}sub header {my ($self,$name)=(shift,shift);return$self->remove($name)->add($name,@_)if @_;return undef unless my$headers=$self->{headers}{lc$name};return join ', ',@$headers}sub is_finished {(shift->{state}// '')eq 'finished'}sub is_limit_exceeded {!!shift->{limit}}sub leftovers {delete shift->{buffer}}sub names {my$self=shift;return [map {$NORMALCASE{$_}|| $self->{normalcase}{$_}|| $_}keys %{$self->{headers}}]}sub parse {my$self=shift;$self->{state}='headers';$self->{buffer}.= shift // '';my$headers=$self->{cache}||= [];my$size=$self->max_line_size;my$lines=$self->max_lines;while ($self->{buffer}=~ s/^(.*?)\x0d?\x0a//){my$line=$1;if ($+[0]> $size || @$headers >= $lines){@$self{qw(state limit)}=('finished',1);return$self}if ($line =~ /^(\S[^:]*)\s*:\s*(.*)$/){push @$headers,[$1,$2]}elsif ($line =~ s/^\s+// && @$headers){$headers->[-1][1].= " $line"}else {$self->add(@$_)for @$headers;@$self{qw(state cache)}=('finished',[]);return$self}}@$self{qw(state limit)}=('finished',1)if length$self->{buffer}> $size;return$self}sub referrer {shift->header(Referer=>@_)}sub remove {my ($self,$name)=@_;delete$self->{headers}{lc$name};return$self}sub to_hash {my ($self,$multi)=@_;return {map {$_=>$multi ? $self->{headers}{lc $_}: $self->header($_)}@{$self->names}}}sub to_string {my$self=shift;my@headers;for my$name (@{$self->names}){push@headers,"$name: $_" for @{$self->{headers}{lc$name}}}return join "\x0d\x0a",@headers}1;
MOJO_HEADERS

$fatpacked{"Mojo/HelloWorld.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_HELLOWORLD';
  package Mojo::HelloWorld;use Mojolicious::Lite;app->log->level('error')->path(undef);any '/*whatever'=>{whatever=>'',text=>'Your Mojo is working!'};1;
MOJO_HELLOWORLD

$fatpacked{"Mojo/Home.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_HOME';
  package Mojo::Home;use Mojo::Base -base;use overload bool=>sub {1},'""'=>sub {shift->to_string},fallback=>1;use Cwd 'abs_path';use File::Basename 'dirname';use File::Find 'find';use File::Spec::Functions qw(abs2rel catdir catfile splitdir);use FindBin;use Mojo::Util 'class_to_path';has parts=>sub {[]};sub detect {my ($self,$class)=@_;return$self->parts([splitdir abs_path$ENV{MOJO_HOME}])if$ENV{MOJO_HOME};if ($class && (my$path=$INC{my$file=class_to_path$class})){$path =~ s/\Q$file\E$//;my@home=splitdir$path;pop@home while@home && ($home[-1]=~ /^b?lib$/ || $home[-1]eq '');return$self->parts([splitdir abs_path catdir(@home)|| '.'])}return$self->parts([split '/',$FindBin::Bin])}sub lib_dir {my$path=catdir @{shift->parts},'lib';return -d $path ? $path : undef}sub list_files {my ($self,$dir)=@_;$dir=catdir @{$self->parts},split('/',$dir // '');return []unless -d $dir;my@files;find {wanted=>sub {my@parts=splitdir abs2rel($File::Find::name,$dir);push@files,join '/',@parts unless grep {/^\./}@parts},no_chdir=>1},$dir;return [sort@files]}sub mojo_lib_dir {catdir dirname(__FILE__),'..'}sub new {@_ > 1 ? shift->SUPER::new->parse(@_): shift->SUPER::new}sub parse {shift->parts([splitdir shift])}sub rel_dir {catdir @{shift->parts},split('/',shift)}sub rel_file {catfile @{shift->parts},split('/',shift)}sub to_string {catdir @{shift->parts}}1;
MOJO_HOME

$fatpacked{"Mojo/IOLoop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP';
  package Mojo::IOLoop;use Mojo::Base 'Mojo::EventEmitter';use Carp 'croak';use Mojo::IOLoop::Client;use Mojo::IOLoop::Delay;use Mojo::IOLoop::Server;use Mojo::IOLoop::Stream;use Mojo::Reactor::Poll;use Mojo::Util qw(md5_sum steady_time);use Scalar::Util qw(blessed weaken);use constant DEBUG=>$ENV{MOJO_IOLOOP_DEBUG}|| 0;has max_accepts=>0;has max_connections=>1000;has multi_accept=>sub {shift->max_connections > 50 ? 50 : 1};has reactor=>sub {my$class=Mojo::Reactor::Poll->detect;warn "-- Reactor initialized ($class)\n" if DEBUG;return$class->new->catch(sub {warn "@{[blessed $_[0]]}: $_[1]"})};$SIG{PIPE}='IGNORE';__PACKAGE__->singleton->reactor;sub acceptor {my ($self,$acceptor)=(_instance(shift),@_);return$self->{acceptors}{$acceptor}unless ref$acceptor;my$id=$self->_id;$self->{acceptors}{$id}=$acceptor->multi_accept($self->multi_accept);weaken$acceptor->reactor($self->reactor)->{reactor};$self->_not_accepting->_maybe_accepting;return$id}sub client {my ($self,$cb)=(_instance(shift),pop);my$id=$self->_id;my$client=$self->{connections}{$id}{client}=Mojo::IOLoop::Client->new;weaken$client->reactor($self->reactor)->{reactor};weaken$self;$client->on(connect=>sub {delete$self->{connections}{$id}{client};my$stream=Mojo::IOLoop::Stream->new(pop);$self->_stream($stream=>$id);$self->$cb(undef,$stream)});$client->on(error=>sub {$self->_remove($id);$self->$cb(pop,undef)});$client->connect(@_);return$id}sub delay {my$delay=Mojo::IOLoop::Delay->new;weaken$delay->ioloop(_instance(shift))->{ioloop};return @_ ? $delay->steps(@_): $delay}sub is_running {_instance(shift)->reactor->is_running}sub next_tick {my ($self,$cb)=(_instance(shift),@_);weaken$self;return$self->reactor->next_tick(sub {$self->$cb})}sub one_tick {_instance(shift)->reactor->one_tick}sub recurring {shift->_timer(recurring=>@_)}sub remove {my ($self,$id)=(_instance(shift),@_);my$c=$self->{connections}{$id};if ($c && (my$stream=$c->{stream})){return$stream->close_gracefully}$self->_remove($id)}sub reset {my$self=_instance(shift);delete @$self{qw(accepting acceptors connections stop)};$self->reactor->reset;$self->stop}sub server {my ($self,$cb)=(_instance(shift),pop);my$server=Mojo::IOLoop::Server->new;weaken$self;$server->on(accept=>sub {if (my$max=$self->max_accepts){$self->{accepts}//= $max - int rand$max / 2;$self->stop_gracefully if ($self->{accepts}-= 1)<= 0}my$stream=Mojo::IOLoop::Stream->new(pop);$self->$cb($stream,$self->stream($stream));$self->_not_accepting if$self->_limit});$server->listen(@_);return$self->acceptor($server)}sub singleton {state$loop=shift->SUPER::new}sub start {my$self=shift;croak 'Mojo::IOLoop already running' if$self->is_running;_instance($self)->reactor->start}sub stop {_instance(shift)->reactor->stop}sub stop_gracefully {my$self=_instance(shift)->_not_accepting;$self->{stop}||= $self->emit('finish')->recurring(1=>\&_stop)}sub stream {my ($self,$stream)=(_instance(shift),@_);return ($self->{connections}{$stream}|| {})->{stream}unless ref$stream;return$self->_stream($stream=>$self->_id)}sub timer {shift->_timer(timer=>@_)}sub _id {my$self=shift;my$id;do {$id=md5_sum 'c' .steady_time .rand 999}while$self->{connections}{$id}|| $self->{acceptors}{$id};return$id}sub _instance {ref $_[0]? $_[0]: $_[0]->singleton}sub _limit {my$self=shift;return 1 if$self->{stop};return keys %{$self->{connections}}>= $self->max_connections}sub _maybe_accepting {my$self=shift;return if$self->{accepting}|| $self->_limit;$_->start for values %{$self->{acceptors}|| {}};$self->{accepting}=1}sub _not_accepting {my$self=shift;return$self unless delete$self->{accepting};$_->stop for values %{$self->{acceptors}|| {}};return$self}sub _remove {my ($self,$id)=@_;return unless my$reactor=$self->reactor;return if$reactor->remove($id);return$self->_not_accepting->_maybe_accepting if delete$self->{acceptors}{$id};return unless delete$self->{connections}{$id};$self->_maybe_accepting;warn "-- $id <<< $$ (@{[scalar keys %{$self->{connections}}]})\n" if DEBUG}sub _stop {my$self=shift;return if keys %{$self->{connections}};$self->_remove(delete$self->{stop});$self->stop}sub _stream {my ($self,$stream,$id)=@_;$self->{connections}{$id}{stream}=$stream;warn "-- $id >>> $$ (@{[scalar keys %{$self->{connections}}]})\n" if DEBUG;weaken$stream->reactor($self->reactor)->{reactor};weaken$self;$stream->on(close=>sub {$self && $self->_remove($id)});$stream->start;return$id}sub _timer {my ($self,$method,$after,$cb)=(_instance(shift),@_);weaken$self;return$self->reactor->$method($after=>sub {$self->$cb})}1;
MOJO_IOLOOP

$fatpacked{"Mojo/IOLoop/Client.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_CLIENT';
  package Mojo::IOLoop::Client;use Mojo::Base 'Mojo::EventEmitter';use Errno 'EINPROGRESS';use IO::Socket::IP;use Mojo::IOLoop;use Scalar::Util 'weaken';use Socket qw(IPPROTO_TCP SOCK_STREAM TCP_NODELAY);use constant NDN=>$ENV{MOJO_NO_NDN}? 0 : eval 'use Net::DNS::Native 0.15 (); 1';my$NDN=NDN ? Net::DNS::Native->new(pool=>5,extra_thread=>1): undef;use constant TLS=>$ENV{MOJO_NO_TLS}? 0 : eval 'use IO::Socket::SSL 1.94 (); 1';use constant TLS_READ=>TLS ? IO::Socket::SSL::SSL_WANT_READ(): 0;use constant TLS_WRITE=>TLS ? IO::Socket::SSL::SSL_WANT_WRITE(): 0;use constant SOCKS=>$ENV{MOJO_NO_SOCKS}? 0 : eval 'use IO::Socket::Socks 0.64 (); 1';use constant SOCKS_READ=>SOCKS ? IO::Socket::Socks::SOCKS_WANT_READ(): 0;use constant SOCKS_WRITE=>SOCKS ? IO::Socket::Socks::SOCKS_WANT_WRITE(): 0;has reactor=>sub {Mojo::IOLoop->singleton->reactor};sub DESTROY {shift->_cleanup}sub connect {my ($self,$args)=(shift,ref $_[0]? $_[0]: {@_});weaken$self;my$reactor=$self->reactor;$self->{timer}=$reactor->timer($args->{timeout}|| 10,sub {$self->emit(error=>'Connect timeout')});$_ && s/[[\]]//g for @$args{qw(address socks_address)};my$address=$args->{socks_address}|| ($args->{address}||= '127.0.0.1');return$reactor->next_tick(sub {$self && $self->_connect($args)})if!NDN || $args->{handle};my$handle=$self->{dns}=$NDN->getaddrinfo($address,_port($args),{protocol=>IPPROTO_TCP,socktype=>SOCK_STREAM});$reactor->io($handle=>sub {my$reactor=shift;$reactor->remove($self->{dns});my ($err,@res)=$NDN->get_result(delete$self->{dns});return$self->emit(error=>"Can't resolve: $err")if$err;$args->{addr_info}=\@res;$self->_connect($args)})->watch($handle,1,0)}sub _cleanup {my$self=shift;$NDN->timedout($self->{dns})if$self->{dns};my$reactor=$self->reactor;$self->{$_}&& $reactor->remove(delete$self->{$_})for qw(dns timer handle);return$self}sub _connect {my ($self,$args)=@_;my$handle;my$address=$args->{socks_address}|| $args->{address};unless ($handle=$self->{handle}=$args->{handle}){my%options=(PeerAddr=>$address,PeerPort=>_port($args));%options=(PeerAddrInfo=>$args->{addr_info})if$args->{addr_info};$options{Blocking}=0;$options{LocalAddr}=$args->{local_address}if$args->{local_address};return$self->emit(error=>"Can't connect: $@")unless$self->{handle}=$handle=IO::Socket::IP->new(%options)}$handle->blocking(0);$self->_wait($handle,$args)}sub _port {$_[0]{socks_port}|| $_[0]{port}|| ($_[0]{tls}? 443 : 80)}sub _ready {my ($self,$args)=@_;my$handle=$self->{handle};if ($handle->isa('IO::Socket::IP')&&!$handle->connect){return$self->emit(error=>$!)unless $!==EINPROGRESS;$self->reactor->remove($handle);return$self->_wait($handle,$args)}return$self->emit(error=>$! || 'Not connected')unless$handle->connected;setsockopt$handle,IPPROTO_TCP,TCP_NODELAY,1;$self->_try_socks($args)}sub _socks {my ($self,$args)=@_;my$handle=$self->{handle};return$self->_try_tls($args)if$handle->ready;my$err=$IO::Socket::Socks::SOCKS_ERROR;if ($err==SOCKS_READ){$self->reactor->watch($handle,1,0)}elsif ($err==SOCKS_WRITE){$self->reactor->watch($handle,1,1)}else {$self->emit(error=>$err)}}sub _tls {my$self=shift;my$handle=$self->{handle};return$self->_cleanup->emit(connect=>$handle)if$handle->connect_SSL;my$err=$IO::Socket::SSL::SSL_ERROR;if ($err==TLS_READ){$self->reactor->watch($handle,1,0)}elsif ($err==TLS_WRITE){$self->reactor->watch($handle,1,1)}}sub _try_socks {my ($self,$args)=@_;my$handle=$self->{handle};return$self->_try_tls($args)unless$args->{socks_address};return$self->emit(error=>'IO::Socket::Socks 0.64+ required for SOCKS support')unless SOCKS;my%options=(ConnectAddr=>$args->{address},ConnectPort=>$args->{port});@options{qw(AuthType Username Password)}=('userpass',@$args{qw(socks_user socks_pass)})if$args->{socks_user};my$reactor=$self->reactor;$reactor->remove($handle);return$self->emit(error=>'SOCKS upgrade failed')unless IO::Socket::Socks->start_SOCKS($handle,%options);weaken$self;$reactor->io($handle=>sub {$self->_socks($args)})->watch($handle,0,1)}sub _try_tls {my ($self,$args)=@_;my$handle=$self->{handle};return$self->_cleanup->emit(connect=>$handle)unless$args->{tls};return$self->emit(error=>'IO::Socket::SSL 1.94+ required for TLS support')unless TLS;weaken$self;my%options=(SSL_ca_file=>$args->{tls_ca}&& -T $args->{tls_ca}? $args->{tls_ca}: undef,SSL_cert_file=>$args->{tls_cert},SSL_error_trap=>sub {$self->emit(error=>$_[1])},SSL_hostname=>IO::Socket::SSL->can_client_sni ? $args->{address}: '',SSL_key_file=>$args->{tls_key},SSL_startHandshake=>0,SSL_verify_mode=>$args->{tls_ca}? 0x01 : 0x00,SSL_verifycn_name=>$args->{address},SSL_verifycn_scheme=>$args->{tls_ca}? 'http' : undef);my$reactor=$self->reactor;$reactor->remove($handle);return$self->emit(error=>'TLS upgrade failed')unless IO::Socket::SSL->start_SSL($handle,%options);$reactor->io($handle=>sub {$self->_tls})->watch($handle,0,1)}sub _wait {my ($self,$handle,$args)=@_;weaken$self;$self->reactor->io($handle=>sub {$self->_ready($args)})->watch($handle,0,1)}1;
MOJO_IOLOOP_CLIENT

$fatpacked{"Mojo/IOLoop/Delay.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_DELAY';
  package Mojo::IOLoop::Delay;use Mojo::Base 'Mojo::EventEmitter';use Mojo::IOLoop;use Mojo::Util;has ioloop=>sub {Mojo::IOLoop->singleton};has remaining=>sub {[]};sub begin {my ($self,$offset,$len)=@_;$self->{pending}++;my$id=$self->{counter}++;return sub {$self->_step($id,$offset // 1,$len,@_)}}sub data {Mojo::Util::_stash(data=>@_)}sub pass {$_[0]->begin->(@_)}sub steps {my$self=shift->remaining([@_]);$self->ioloop->next_tick($self->begin);return$self}sub wait {my$self=shift;return if$self->ioloop->is_running;$self->once(error=>\&_die);$self->once(finish=>sub {shift->ioloop->stop});$self->ioloop->start}sub _die {$_[0]->has_subscribers('error')? $_[0]->ioloop->stop : die $_[1]}sub _step {my ($self,$id,$offset,$len)=(shift,shift,shift,shift);$self->{args}[$id]=[@_ ? defined$len ? splice @_,$offset,$len : splice @_,$offset : ()];return$self if$self->{fail}|| --$self->{pending}|| $self->{lock};local$self->{lock}=1;my@args=map {@$_}@{delete$self->{args}};$self->{counter}=0;if (my$cb=shift @{$self->remaining}){eval {$self->$cb(@args);1}or (++$self->{fail}and return$self->remaining([])->emit(error=>$@))}return$self->remaining([])->emit(finish=>@args)unless$self->{counter};$self->ioloop->next_tick($self->begin)unless$self->{pending};return$self}1;
MOJO_IOLOOP_DELAY

$fatpacked{"Mojo/IOLoop/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_SERVER';
  package Mojo::IOLoop::Server;use Mojo::Base 'Mojo::EventEmitter';use Carp 'croak';use File::Basename 'dirname';use File::Spec::Functions 'catfile';use IO::Socket::IP;use Mojo::IOLoop;use Scalar::Util 'weaken';use Socket qw(IPPROTO_TCP TCP_NODELAY);use constant TLS=>$ENV{MOJO_NO_TLS}? 0 : eval 'use IO::Socket::SSL 1.94 (); 1';use constant TLS_READ=>TLS ? IO::Socket::SSL::SSL_WANT_READ(): 0;use constant TLS_WRITE=>TLS ? IO::Socket::SSL::SSL_WANT_WRITE(): 0;my$CERT=catfile dirname(__FILE__),'resources','server.crt';my$KEY=catfile dirname(__FILE__),'resources','server.key';has multi_accept=>50;has reactor=>sub {Mojo::IOLoop->singleton->reactor};sub DESTROY {my$self=shift;$ENV{MOJO_REUSE}=~ s/(?:^|\,)\Q$self->{reuse}\E// if$self->{reuse};return unless my$reactor=$self->reactor;$self->stop if$self->{handle};$reactor->remove($_)for values %{$self->{handles}}}sub generate_port {IO::Socket::IP->new(Listen=>5,LocalAddr=>'127.0.0.1')->sockport}sub handle {shift->{handle}}sub listen {my ($self,$args)=(shift,ref $_[0]? $_[0]: {@_});my$address=$args->{address}|| '0.0.0.0';my$port=$args->{port};$ENV{MOJO_REUSE}||= '';my$fd;$fd=$1 if$port && $ENV{MOJO_REUSE}=~ /(?:^|\,)\Q$address:$port\E:(\d+)/;local $^F=1023;my$handle;if (defined$fd){$handle=IO::Socket::IP->new_from_fd($fd,'r')or croak "Can't open file descriptor $fd: $!"}else {my%options=(Listen=>$args->{backlog}// SOMAXCONN,LocalAddr=>$address,ReuseAddr=>1,ReusePort=>$args->{reuse},Type=>SOCK_STREAM);$options{LocalPort}=$port if$port;$options{LocalAddr}=~ s/[\[\]]//g;$handle=IO::Socket::IP->new(%options)or croak "Can't create listen socket: $@";$fd=fileno$handle;my$reuse=$self->{reuse}=join ':',$address,$handle->sockport,$fd;$ENV{MOJO_REUSE}.= length$ENV{MOJO_REUSE}? ",$reuse" : "$reuse"}$handle->blocking(0);$self->{handle}=$handle;return unless$args->{tls};croak "IO::Socket::SSL 1.94+ required for TLS support" unless TLS;weaken$self;my$tls=$self->{tls}={SSL_cert_file=>$args->{tls_cert}|| $CERT,SSL_error_trap=>sub {return unless my$handle=delete$self->{handles}{shift()};$self->reactor->remove($handle);close$handle},SSL_honor_cipher_order=>1,SSL_key_file=>$args->{tls_key}|| $KEY,SSL_startHandshake=>0,SSL_verify_mode=>$args->{tls_verify}// ($args->{tls_ca}? 0x03 : 0x00)};$tls->{SSL_ca_file}=$args->{tls_ca}if$args->{tls_ca}&& -T $args->{tls_ca};$tls->{SSL_cipher_list}=$args->{tls_ciphers}if$args->{tls_ciphers};$tls->{SSL_version}=$args->{tls_version}if$args->{tls_version}}sub port {shift->{handle}->sockport}sub start {my$self=shift;weaken$self;$self->reactor->io($self->{handle}=>sub {$self->_accept})}sub stop {$_[0]->reactor->remove($_[0]{handle})}sub _accept {my$self=shift;for (1 .. $self->multi_accept){return unless my$handle=$self->{handle}->accept;$handle->blocking(0);setsockopt$handle,IPPROTO_TCP,TCP_NODELAY,1;$self->emit(accept=>$handle)and next unless my$tls=$self->{tls};$self->_handshake($self->{handles}{$handle}=$handle)if$handle=IO::Socket::SSL->start_SSL($handle,%$tls,SSL_server=>1)}}sub _handshake {my ($self,$handle)=@_;weaken$self;$self->reactor->io($handle=>sub {$self->_tls($handle)})}sub _tls {my ($self,$handle)=@_;if ($handle->accept_SSL){$self->reactor->remove($handle);return$self->emit(accept=>delete$self->{handles}{$handle})}my$err=$IO::Socket::SSL::SSL_ERROR;if ($err==TLS_READ){$self->reactor->watch($handle,1,0)}elsif ($err==TLS_WRITE){$self->reactor->watch($handle,1,1)}}1;
MOJO_IOLOOP_SERVER

$fatpacked{"Mojo/IOLoop/Stream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_IOLOOP_STREAM';
  package Mojo::IOLoop::Stream;use Mojo::Base 'Mojo::EventEmitter';use Errno qw(EAGAIN ECONNRESET EINTR EWOULDBLOCK);use Mojo::IOLoop;use Mojo::Util;use Scalar::Util 'weaken';has reactor=>sub {Mojo::IOLoop->singleton->reactor};sub DESTROY {Mojo::Util::_global_destruction()or shift->close}sub close {my$self=shift;return unless my$reactor=$self->reactor;return unless my$handle=delete$self->timeout(0)->{handle};$reactor->remove($handle);$self->emit('close')}sub close_gracefully {$_[0]->is_writing ? $_[0]{graceful}++ : $_[0]->close}sub handle {shift->{handle}}sub is_readable {my$self=shift;$self->_again;return$self->{handle}&& Mojo::Util::_readable(0,fileno$self->{handle})}sub is_writing {my$self=shift;return undef unless$self->{handle};return!!length($self->{buffer})|| $self->has_subscribers('drain')}sub new {shift->SUPER::new(handle=>shift,buffer=>'',timeout=>15)}sub start {my$self=shift;my$reactor=$self->reactor;return$reactor->watch($self->{handle},1,$self->is_writing)if delete$self->{paused};weaken$self;my$cb=sub {pop()? $self->_write : $self->_read};$reactor->io($self->timeout($self->{timeout})->{handle}=>$cb)}sub steal_handle {my$self=shift;$self->reactor->remove($self->{handle});return delete$self->{handle}}sub stop {my$self=shift;$self->reactor->watch($self->{handle},0,$self->is_writing)unless$self->{paused}++}sub timeout {my$self=shift;return$self->{timeout}unless @_;my$reactor=$self->reactor;$reactor->remove(delete$self->{timer})if$self->{timer};return$self unless my$timeout=$self->{timeout}=shift;weaken$self;$self->{timer}=$reactor->timer($timeout=>sub {$self->emit('timeout')->close});return$self}sub write {my ($self,$chunk,$cb)=@_;$self->{buffer}.= $chunk;if ($cb){$self->once(drain=>$cb)}elsif ($self->{buffer}eq ''){return$self}$self->reactor->watch($self->{handle},!$self->{paused},1)if$self->{handle};return$self}sub _again {$_[0]->reactor->again($_[0]{timer})if $_[0]{timer}}sub _read {my$self=shift;my$read=$self->{handle}->sysread(my$buffer,131072,0);return$read==0 ? $self->close : $self->emit(read=>$buffer)->_again if defined$read;return if $!==EAGAIN || $!==EINTR || $!==EWOULDBLOCK;$!==ECONNRESET ? $self->close : $self->emit(error=>$!)->close}sub _write {my$self=shift;my$handle=$self->{handle};if ($self->{buffer}ne ''){return unless defined(my$written=$handle->syswrite($self->{buffer}));$self->emit(write=>substr($self->{buffer},0,$written,''))->_again}$self->emit('drain')if$self->{buffer}eq '';return if$self->is_writing;return$self->close if$self->{graceful};$self->reactor->watch($handle,!$self->{paused},0)if$self->{handle}}1;
MOJO_IOLOOP_STREAM

$fatpacked{"Mojo/JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_JSON';
  package Mojo::JSON;use Mojo::Base -strict;use Carp 'croak';use Exporter 'import';use JSON::PP ();use Mojo::Util;use Scalar::Util 'blessed';our@EXPORT_OK=qw(decode_json encode_json false from_json j to_json true);my%ESCAPE=('"'=>'"','\\'=>'\\','/'=>'/','b'=>"\x08",'f'=>"\x0c",'n'=>"\x0a",'r'=>"\x0d",'t'=>"\x09",'u2028'=>"\x{2028}",'u2029'=>"\x{2029}");my%REVERSE=map {$ESCAPE{$_}=>"\\$_"}keys%ESCAPE;for (0x00 .. 0x1f){$REVERSE{pack 'C',$_}//= sprintf '\u%.4X',$_}sub decode_json {my$err=_decode(\my$value,shift);return defined$err ? croak$err : $value}sub encode_json {Mojo::Util::encode 'UTF-8',_encode_value(shift)}sub false () {JSON::PP::false}sub from_json {my$err=_decode(\my$value,shift,1);return defined$err ? croak$err : $value}sub j {return encode_json($_[0])if ref $_[0]eq 'ARRAY' || ref $_[0]eq 'HASH';return eval {decode_json($_[0])}}sub to_json {_encode_value(shift)}sub true () {JSON::PP::true}sub _decode {my$valueref=shift;eval {die "Missing or empty input\n" if (local $_=shift)eq '';$_=Mojo::Util::decode 'UTF-8',$_ unless shift;die "Input is not UTF-8 encoded\n" unless defined;$$valueref=_decode_value();/\G[\x20\x09\x0a\x0d]*\z/gc or _throw('Unexpected data')}? return undef : chomp $@;return $@}sub _decode_array {my@array;until (m/\G[\x20\x09\x0a\x0d]*\]/gc){push@array,_decode_value();redo if /\G[\x20\x09\x0a\x0d]*,/gc;last if /\G[\x20\x09\x0a\x0d]*\]/gc;_throw('Expected comma or right square bracket while parsing array')}return \@array}sub _decode_object {my%hash;until (m/\G[\x20\x09\x0a\x0d]*\}/gc){/\G[\x20\x09\x0a\x0d]*"/gc or _throw('Expected string while parsing object');my$key=_decode_string();/\G[\x20\x09\x0a\x0d]*:/gc or _throw('Expected colon while parsing object');$hash{$key}=_decode_value();redo if /\G[\x20\x09\x0a\x0d]*,/gc;last if /\G[\x20\x09\x0a\x0d]*\}/gc;_throw('Expected comma or right curly bracket while parsing object')}return \%hash}sub _decode_string {my$pos=pos;m!\G((?:(?:[^\x00-\x1f\\"]|\\(?:["\\/bfnrt]|u[0-9a-fA-F]{4})){0,32766})*)!gc;my$str=$1;unless (m/\G"/gc){_throw('Unexpected character or invalid escape while parsing string')if /\G[\x00-\x1f\\]/;_throw('Unterminated string')}if (index($str,'\\u')< 0){$str =~ s!\\(["\\/bfnrt])!$ESCAPE{$1}!gs;return$str}my$buffer='';while ($str =~ /\G([^\\]*)\\(?:([^u])|u(.{4}))/gc){$buffer .= $1;if ($2){$buffer .= $ESCAPE{$2}}else {my$ord=hex $3;if (($ord & 0xf800)==0xd800){($ord & 0xfc00)==0xd800 or pos=$pos + pos($str),_throw('Missing high-surrogate');$str =~ /\G\\u([Dd][C-Fc-f]..)/gc or pos=$pos + pos($str),_throw('Missing low-surrogate');$ord=0x10000 + ($ord - 0xd800)* 0x400 + (hex($1)- 0xdc00)}$buffer .= pack 'U',$ord}}return$buffer .substr$str,pos($str),length($str)}sub _decode_value {/\G[\x20\x09\x0a\x0d]*/gc;return _decode_string()if /\G"/gc;return _decode_object()if /\G\{/gc;return _decode_array()if /\G\[/gc;return 0 + $1 if /\G([-]?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)/gc;return true()if /\Gtrue/gc;return false()if /\Gfalse/gc;return undef if /\Gnull/gc;_throw('Expected string, array, object, number, boolean or null')}sub _encode_array {'[' .join(',',map {_encode_value($_)}@{$_[0]}).']'}sub _encode_object {my$object=shift;my@pairs=map {_encode_string($_).':' ._encode_value($object->{$_})}keys %$object;return '{' .join(',',@pairs).'}'}sub _encode_string {my$str=shift;$str =~ s!([\x00-\x1f\x{2028}\x{2029}\\"/])!$REVERSE{$1}!gs;return "\"$str\""}sub _encode_value {my$value=shift;if (my$ref=ref$value){return _encode_object($value)if$ref eq 'HASH';return _encode_array($value)if$ref eq 'ARRAY';return $$value ? 'true' : 'false' if$ref eq 'SCALAR';return$value ? 'true' : 'false' if$ref eq 'JSON::PP::Boolean';return _encode_string($value)unless blessed$value && (my$sub=$value->can('TO_JSON'));return _encode_value($value->$sub)}return 'null' unless defined$value;my$check=(my$dummy="0")& $value;return$value if (!($check ^ $check)&& length$check)&& 0 + $value eq $value && $value * 0==0;return _encode_string($value)}sub _throw {/\G[\x20\x09\x0a\x0d]*/gc;my$context='Malformed JSON: ' .shift;if (m/\G\z/gc){$context .= ' before end of data'}else {my@lines=split "\n",substr($_,0,pos);$context .= ' at line ' .@lines .', offset ' .length(pop@lines || '')}die "$context\n"}1;
MOJO_JSON

$fatpacked{"Mojo/JSON/Pointer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_JSON_POINTER';
  package Mojo::JSON::Pointer;use Mojo::Base -base;has 'data';sub contains {shift->_pointer(1,@_)}sub get {shift->_pointer(0,@_)}sub new {@_ > 1 ? shift->SUPER::new(data=>shift): shift->SUPER::new}sub _pointer {my ($self,$contains,$pointer)=@_;my$data=$self->data;return$contains ? 1 : $data unless$pointer =~ s!^/!!;for my$p ($pointer eq '' ? ($pointer): (split '/',$pointer,-1)){$p =~ s!~1!/!g;$p =~ s/~0/~/g;if (ref$data eq 'HASH' && exists$data->{$p}){$data=$data->{$p}}elsif (ref$data eq 'ARRAY' && $p =~ /^\d+$/ && @$data > $p){$data=$data->[$p]}else {return undef}}return$contains ? 1 : $data}1;
MOJO_JSON_POINTER

$fatpacked{"Mojo/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_LOADER';
  package Mojo::Loader;use Mojo::Base -strict;use Exporter 'import';use File::Basename 'fileparse';use File::Spec::Functions qw(catdir catfile splitdir);use Mojo::Exception;use Mojo::Util qw(b64_decode class_to_path);our@EXPORT_OK =qw(data_section file_is_binary find_modules find_packages load_class);my (%BIN,%CACHE);sub data_section {$_[0]? $_[1]? _all($_[0])->{$_[1]}: _all($_[0]): undef}sub file_is_binary {keys %{_all($_[0])}?!!$BIN{$_[0]}{$_[1]}: undef}sub find_modules {my$ns=shift;my%modules;for my$directory (@INC){next unless -d (my$path=catdir$directory,split(/::|'/,$ns));opendir(my$dir,$path);for my$file (grep /\.pm$/,readdir$dir){next if -d catfile splitdir($path),$file;$modules{"${ns}::" .fileparse$file,qr/\.pm/}++}}return sort keys%modules}sub find_packages {my$ns=shift;no strict 'refs';return sort map {/^(.+)::$/ ? "${ns}::$1" : ()}keys %{"${ns}::"}}sub load_class {my$class=shift;return 1 if ($class || '')!~ /^\w(?:[\w:']*\w)?$/;return undef if$class->can('new')|| eval "require $class; 1";return 1 if $@ =~ /^Can't locate \Q@{[class_to_path $class]}\E in \@INC/;return Mojo::Exception->new($@)}sub _all {my$class=shift;return$CACHE{$class}if$CACHE{$class};my$handle=do {no strict 'refs';\*{"${class}::DATA"}};return {}unless fileno$handle;seek$handle,0,0;my$data=join '',<$handle>;$data =~ s/^.*\n__DATA__\r?\n/\n/s;$data =~ s/\n__END__\r?\n.*$/\n/s;(undef,my@files)=split /^@@\s*(.+?)\s*\r?\n/m,$data;my$all=$CACHE{$class}={};while (@files){my ($name,$data)=splice@files,0,2;$all->{$name}=$name =~ s/\s*\(\s*base64\s*\)$// && ++$BIN{$class}{$name}? b64_decode$data : $data}return$all}1;
MOJO_LOADER

$fatpacked{"Mojo/Log.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_LOG';
  package Mojo::Log;use Mojo::Base 'Mojo::EventEmitter';use Carp 'croak';use Fcntl ':flock';use Mojo::Util 'encode';has format=>sub {\&_format};has handle=>sub {return \*STDERR unless my$path=shift->path;croak qq{Can't open log file "$path": $!} unless open my$file,'>>',$path;return$file};has history=>sub {[]};has level=>'debug';has max_history_size=>10;has 'path';my$LEVEL={debug=>1,info=>2,warn=>3,error=>4,fatal=>5};sub append {my ($self,$msg)=@_;return unless my$handle=$self->handle;flock$handle,LOCK_EX;$handle->print(encode('UTF-8',$msg))or croak "Can't write to log: $!";flock$handle,LOCK_UN}sub debug {shift->_log(debug=>@_)}sub error {shift->_log(error=>@_)}sub fatal {shift->_log(fatal=>@_)}sub info {shift->_log(info=>@_)}sub is_debug {shift->_now('debug')}sub is_error {shift->_now('error')}sub is_info {shift->_now('info')}sub is_warn {shift->_now('warn')}sub new {my$self=shift->SUPER::new(@_);$self->on(message=>\&_message);return$self}sub warn {shift->_log(warn=>@_)}sub _format {'[' .localtime(shift).'] [' .shift().'] ' .join "\n",@_,''}sub _log {shift->emit('message',shift,@_)}sub _message {my ($self,$level)=(shift,shift);return unless$self->_now($level);my$max=$self->max_history_size;my$history=$self->history;push @$history,my$msg=[time,$level,@_];shift @$history while @$history > $max;$self->append($self->format->(@$msg))}sub _now {$LEVEL->{pop()}>= $LEVEL->{$ENV{MOJO_LOG_LEVEL}|| shift->level}}1;
MOJO_LOG

$fatpacked{"Mojo/Message.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_MESSAGE';
  package Mojo::Message;use Mojo::Base 'Mojo::EventEmitter';use Carp 'croak';use Mojo::Asset::Memory;use Mojo::Content::Single;use Mojo::DOM;use Mojo::JSON 'j';use Mojo::JSON::Pointer;use Mojo::Parameters;use Mojo::Upload;use Mojo::Util 'decode';has content=>sub {Mojo::Content::Single->new};has default_charset=>'UTF-8';has max_line_size=>sub {$ENV{MOJO_MAX_LINE_SIZE}|| 8192};has max_message_size=>sub {$ENV{MOJO_MAX_MESSAGE_SIZE}// 16777216};has version=>'1.1';sub body {my$self=shift;my$content=$self->content;return$content->is_multipart ? '' : $content->asset->slurp unless @_;$content=$self->content(Mojo::Content::Single->new)->content if$content->is_multipart;$content->asset(Mojo::Asset::Memory->new->add_chunk(@_));return$self}sub body_params {my$self=shift;return$self->{body_params}if$self->{body_params};my$params=$self->{body_params}=Mojo::Parameters->new;$params->charset($self->content->charset || $self->default_charset);my$type=$self->headers->content_type // '';if ($type =~ m!application/x-www-form-urlencoded!i){$params->parse($self->content->asset->slurp)}elsif ($type =~ m!multipart/form-data!i){$params->append(@$_[0,1])for @{$self->_parse_formdata}}return$params}sub body_size {shift->content->body_size}sub build_body {shift->_build('get_body_chunk')}sub build_headers {shift->_build('get_header_chunk')}sub build_start_line {shift->_build('get_start_line_chunk')}sub cookie {shift->_cache('cookies',0,@_)}sub cookies {croak 'Method "cookies" not implemented by subclass'}sub dom {my$self=shift;return undef if$self->content->is_multipart;my$dom=$self->{dom}||= Mojo::DOM->new($self->text);return @_ ? $dom->find(@_): $dom}sub error {my$self=shift;return$self->{error}unless @_;$self->{error}=shift;return$self->finish}sub every_cookie {shift->_cache('cookies',1,@_)}sub every_upload {shift->_cache('uploads',1,@_)}sub extract_start_line {croak 'Method "extract_start_line" not implemented by subclass'}sub finish {my$self=shift;$self->{state}='finished';return$self->{finished}++ ? $self : $self->emit('finish')}sub fix_headers {my$self=shift;return$self if$self->{fix}++;my$content=$self->content;my$headers=$content->headers;if ($content->is_multipart){$headers->remove('Content-Length')}elsif ($content->is_chunked || $headers->content_length){return$self}if ($content->is_dynamic){$headers->connection('close')}else {$headers->content_length($self->body_size)}return$self}sub get_body_chunk {my ($self,$offset)=@_;$self->emit('progress','body',$offset);my$chunk=$self->content->get_body_chunk($offset);return$chunk if!defined$chunk || $chunk ne '';$self->finish;return$chunk}sub get_header_chunk {my ($self,$offset)=@_;$self->emit('progress','headers',$offset);return$self->fix_headers->content->get_header_chunk($offset)}sub get_start_line_chunk {croak 'Method "get_start_line_chunk" not implemented by subclass'}sub header_size {shift->fix_headers->content->header_size}sub headers {shift->content->headers}sub is_finished {(shift->{state}// '')eq 'finished'}sub is_limit_exceeded {!!shift->{limit}}sub json {my ($self,$pointer)=@_;return undef if$self->content->is_multipart;my$data=$self->{json}//= j($self->body);return$pointer ? Mojo::JSON::Pointer->new($data)->get($pointer): $data}sub parse {my$self=shift;return$self if$self->{error};$self->{raw_size}+= length(my$chunk=shift // '');$self->{buffer}.= $chunk;unless ($self->{state}){my$len=index$self->{buffer},"\x0a";$len=length$self->{buffer}if$len < 0;return$self->_limit('Maximum start-line size exceeded')if$len > $self->max_line_size;$self->{state}='content' if$self->extract_start_line(\$self->{buffer})}my$state=$self->{state}// '';$self->content($self->content->parse(delete$self->{buffer}))if$state eq 'content' || $state eq 'finished';my$max=$self->max_message_size;return$self->_limit('Maximum message size exceeded')if$max && $max < $self->{raw_size};return$self->_limit('Maximum header size exceeded')if$self->headers->is_limit_exceeded;return$self->_limit('Maximum buffer size exceeded')if$self->content->is_limit_exceeded;return$self->emit('progress')->content->is_finished ? $self->finish : $self}sub start_line_size {croak 'Method "start_line_size" not implemented by subclass'}sub text {my$self=shift;my$body=$self->body;my$charset=$self->content->charset || $self->default_charset;return$charset ? decode($charset,$body)// $body : $body}sub to_string {my$self=shift;return$self->build_start_line .$self->build_headers .$self->build_body}sub upload {shift->_cache('uploads',0,@_)}sub uploads {my$self=shift;my@uploads;for my$data (@{$self->_parse_formdata(1)}){my$upload=Mojo::Upload->new(name=>$data->[0],filename=>$data->[2],asset=>$data->[1]->asset,headers=>$data->[1]->headers);push@uploads,$upload}return \@uploads}sub _build {my ($self,$method)=@_;my ($buffer,$offset)=('',0);while (1){next unless defined(my$chunk=$self->$method($offset));last unless my$len=length$chunk;$offset += $len;$buffer .= $chunk}return$buffer}sub _cache {my ($self,$method,$all,$name)=@_;unless ($self->{$method}){$self->{$method}={};push @{$self->{$method}{$_->name}},$_ for @{$self->$method}}my$objects=$self->{$method}{$name}|| [];return$all ? $objects : $objects->[-1]}sub _limit {++$_[0]{limit}and return $_[0]->error({message=>$_[1]})}sub _parse_formdata {my ($self,$upload)=@_;my@formdata;my$content=$self->content;return \@formdata unless$content->is_multipart;my$charset=$content->charset || $self->default_charset;my@parts=($content);while (my$part=shift@parts){if ($part->is_multipart){unshift@parts,@{$part->parts};next}next unless my$disposition=$part->headers->content_disposition;my ($filename)=$disposition =~ /[; ]filename="((?:\\"|[^"])*)"/;next if$upload &&!defined$filename ||!$upload && defined$filename;my ($name)=$disposition =~ /[; ]name="((?:\\"|[^;"])*)"/;$part=$part->asset->slurp unless$upload;if ($charset){$name=decode($charset,$name)// $name if$name;$filename=decode($charset,$filename)// $filename if$filename;$part=decode($charset,$part)// $part unless$upload}push@formdata,[$name,$part,$filename]}return \@formdata}1;
MOJO_MESSAGE

$fatpacked{"Mojo/Message/Request.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_MESSAGE_REQUEST';
  package Mojo::Message::Request;use Mojo::Base 'Mojo::Message';use Mojo::Cookie::Request;use Mojo::Util qw(b64_encode b64_decode);use Mojo::URL;has env=>sub {{}};has method=>'GET';has [qw(proxy reverse_proxy)];has url=>sub {Mojo::URL->new};has via_proxy=>1;sub clone {my$self=shift;return undef unless my$content=$self->content->clone;my$clone=$self->new(content=>$content,method=>$self->method,url=>$self->url->clone,version=>$self->version);$clone->{proxy}=$self->{proxy}->clone if$self->{proxy};return$clone}sub cookies {my$self=shift;my$headers=$self->headers;return [map {@{Mojo::Cookie::Request->parse($_)}}$headers->cookie]unless @_;my@cookies=map {ref $_ eq 'HASH' ? Mojo::Cookie::Request->new($_): $_}$headers->cookie || (),@_;$headers->cookie(join '; ',@cookies);return$self}sub every_param {shift->params->every_param(@_)}sub extract_start_line {my ($self,$bufref)=@_;return undef unless $$bufref =~ s/^\s*(.*?)\x0d?\x0a//;return!$self->error({message=>'Bad request start-line'})unless $1 =~ /^(\S+)\s+(\S+)\s+HTTP\/(\d\.\d)$/;my$url=$self->method($1)->version($3)->url;return!!($1 eq 'CONNECT' ? $url->authority($2): $url->parse($2))}sub fix_headers {my$self=shift;$self->{fix}? return$self : $self->SUPER::fix_headers(@_);my$url=$self->url;my$headers=$self->headers;$headers->host($url->host_port)unless$headers->host;if ((my$info=$url->userinfo)&&!$headers->authorization){$headers->authorization('Basic ' .b64_encode($info,''))}return$self unless (my$proxy=$self->proxy)&& $self->via_proxy;return$self unless my$info=$proxy->userinfo;$headers->proxy_authorization('Basic ' .b64_encode($info,''))unless$headers->proxy_authorization;return$self}sub get_start_line_chunk {my ($self,$offset)=@_;$self->_start_line->emit(progress=>'start_line',$offset);return substr$self->{start_buffer},$offset,131072}sub is_handshake {lc($_[0]->headers->upgrade // '')eq 'websocket'}sub is_secure {my$url=shift->url;return ($url->protocol || $url->base->protocol)eq 'https'}sub is_xhr {(shift->headers->header('X-Requested-With')// '')=~ /XMLHttpRequest/i}sub param {shift->params->param(@_)}sub params {my$self=shift;return$self->{params}||= $self->body_params->clone->append($self->query_params)}sub parse {my$self=shift;my$env=@_ > 1 ? {@_}: ref $_[0]eq 'HASH' ? $_[0]: undef;$self->env($env)->_parse_env($env)if$env;my@args=$env ? (): @_;if (($self->{state}// '')ne 'cgi'){$self->SUPER::parse(@args)}else {$self->content($self->content->parse_body(@args))->SUPER::parse}return$self unless$self->is_finished;my$base=$self->url->base;$base->scheme('http')unless$base->scheme;my$headers=$self->headers;if (!$base->host && (my$host=$headers->host)){$base->authority($host)}my$auth=_parse_basic_auth($headers->authorization);$base->userinfo($auth)if$auth;my$proxy_auth=_parse_basic_auth($headers->proxy_authorization);$self->proxy(Mojo::URL->new->userinfo($proxy_auth))if$proxy_auth;$base->scheme('https')if$self->reverse_proxy && ($headers->header('X-Forwarded-Proto')// '')eq 'https';return$self}sub query_params {shift->url->query}sub start_line_size {length shift->_start_line->{start_buffer}}sub _parse_basic_auth {return undef unless my$header=shift;return$header =~ /Basic (.+)$/ ? b64_decode $1 : undef}sub _parse_env {my ($self,$env)=@_;my$headers=$self->headers;my$url=$self->url;my$base=$url->base;for my$name (keys %$env){my$value=$env->{$name};next unless$name =~ s/^HTTP_//i;$name =~ y/_/-/;$headers->header($name=>$value);if ($name eq 'HOST'){my ($host,$port)=($value,undef);($host,$port)=($1,$2)if$host =~ /^([^:]*):?(.*)$/;$base->host($host)->port($port)}}$headers->content_type($env->{CONTENT_TYPE})if$env->{CONTENT_TYPE};$headers->content_length($env->{CONTENT_LENGTH})if$env->{CONTENT_LENGTH};$url->query->parse($env->{QUERY_STRING})if$env->{QUERY_STRING};$self->method($env->{REQUEST_METHOD})if$env->{REQUEST_METHOD};$base->scheme($1)and $self->version($2)if ($env->{SERVER_PROTOCOL}// '')=~ m!^([^/]+)/([^/]+)$!;$base->scheme('https')if uc($env->{HTTPS}// '')eq 'ON';my$path=$url->path->parse($env->{PATH_INFO}? $env->{PATH_INFO}: '');if (my$value=$env->{SCRIPT_NAME}){$base->path->parse($value =~ m!/$! ? $value : "$value/");my$buffer=$path->to_string;$value =~ s!^/|/$!!g;$buffer =~ s!^/?\Q$value\E/?!!;$buffer =~ s!^/!!;$path->parse($buffer)}$self->{state}='cgi'}sub _start_line {my$self=shift;return$self if defined$self->{start_buffer};my$url=$self->url;my$path=$url->path_query;$path="/$path" unless$path =~ m!^/!;my$method=uc$self->method;if ($method eq 'CONNECT'){my$port=$url->port || ($url->protocol eq 'https' ? '443' : '80');$path=$url->ihost .":$port"}elsif ($self->proxy && $self->via_proxy && $url->protocol ne 'https'){$path=$url->clone->userinfo(undef)unless$self->is_handshake}$self->{start_buffer}="$method $path HTTP/@{[$self->version]}\x0d\x0a";return$self}1;
MOJO_MESSAGE_REQUEST

$fatpacked{"Mojo/Message/Response.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_MESSAGE_RESPONSE';
  package Mojo::Message::Response;use Mojo::Base 'Mojo::Message';use Mojo::Cookie::Response;use Mojo::Date;has [qw(code message)];my%MESSAGES=(100=>'Continue',101=>'Switching Protocols',102=>'Processing',200=>'OK',201=>'Created',202=>'Accepted',203=>'Non-Authoritative Information',204=>'No Content',205=>'Reset Content',206=>'Partial Content',207=>'Multi-Status',208=>'Already Reported',226=>'IM Used',300=>'Multiple Choices',301=>'Moved Permanently',302=>'Found',303=>'See Other',304=>'Not Modified',305=>'Use Proxy',307=>'Temporary Redirect',308=>'Permanent Redirect',400=>'Bad Request',401=>'Unauthorized',402=>'Payment Required',403=>'Forbidden',404=>'Not Found',405=>'Method Not Allowed',406=>'Not Acceptable',407=>'Proxy Authentication Required',408=>'Request Timeout',409=>'Conflict',410=>'Gone',411=>'Length Required',412=>'Precondition Failed',413=>'Request Entity Too Large',414=>'Request-URI Too Long',415=>'Unsupported Media Type',416=>'Request Range Not Satisfiable',417=>'Expectation Failed',418=>"I'm a teapot",422=>'Unprocessable Entity',423=>'Locked',424=>'Failed Dependency',425=>'Unordered Colection',426=>'Upgrade Required',428=>'Precondition Required',429=>'Too Many Requests',431=>'Request Header Fields Too Large',451=>'Unavailable For Legal Reasons',500=>'Internal Server Error',501=>'Not Implemented',502=>'Bad Gateway',503=>'Service Unavailable',504=>'Gateway Timeout',505=>'HTTP Version Not Supported',506=>'Variant Also Negotiates',507=>'Insufficient Storage',508=>'Loop Detected',509=>'Bandwidth Limit Exceeded',510=>'Not Extended',511=>'Network Authentication Required');sub cookies {my$self=shift;my$headers=$self->headers;return [map {@{Mojo::Cookie::Response->parse($_)}}$headers->set_cookie]unless @_;$headers->add('Set-Cookie'=>"$_")for map {ref $_ eq 'HASH' ? Mojo::Cookie::Response->new($_): $_}@_;return$self}sub default_message {$MESSAGES{$_[1]|| $_[0]->code // 404}|| ''}sub extract_start_line {my ($self,$bufref)=@_;return undef unless $$bufref =~ s/^(.*?)\x0d?\x0a//;return!$self->error({message=>'Bad response start-line'})unless $1 =~ m!^\s*HTTP/(\d\.\d)\s+(\d\d\d)\s*(.+)?$!;my$content=$self->content;$content->skip_body(1)if$self->code($2)->is_empty;defined$content->$_ or $content->$_(1)for qw(auto_decompress auto_relax);$content->expect_close(1)if $1 eq '1.0';return!!$self->version($1)->message($3)}sub fix_headers {my$self=shift;$self->{fix}? return$self : $self->SUPER::fix_headers(@_);my$headers=$self->headers;$headers->date(Mojo::Date->new->to_string)unless$headers->date;return$self}sub get_start_line_chunk {my ($self,$offset)=@_;$self->_start_line->emit(progress=>'start_line',$offset);return substr$self->{start_buffer},$offset,131072}sub is_empty {my$self=shift;return undef unless my$code=$self->code;return$self->is_status_class(100)|| $code==204 || $code==304}sub is_status_class {my ($self,$class)=@_;return undef unless my$code=$self->code;return$code >= $class && $code < ($class + 100)}sub start_line_size {length shift->_start_line->{start_buffer}}sub _start_line {my$self=shift;return$self if defined$self->{start_buffer};my$code=$self->code || 404;my$msg=$self->message || $self->default_message;$self->{start_buffer}="HTTP/@{[$self->version]} $code $msg\x0d\x0a";return$self}1;
MOJO_MESSAGE_RESPONSE

$fatpacked{"Mojo/Parameters.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_PARAMETERS';
  package Mojo::Parameters;use Mojo::Base -base;use overload '@{}'=>sub {shift->pairs},bool=>sub {1},'""'=>sub {shift->to_string},fallback=>1;use Mojo::Util qw(decode encode url_escape url_unescape);has charset=>'UTF-8';sub append {my$self=shift;my$old=$self->pairs;my@new=@_==1 ? @{shift->pairs}: @_;while (my ($name,$value)=splice@new,0,2){if (ref$value eq 'ARRAY'){push @$old,$name=>$_ // '' for @$value}elsif (defined$value){push @$old,$name=>$value}}return$self}sub clone {my$self=shift;my$clone=$self->new;if (exists$self->{charset}){$clone->{charset}=$self->{charset}}if (defined$self->{string}){$clone->{string}=$self->{string}}else {$clone->{pairs}=[@{$self->pairs}]}return$clone}sub every_param {my ($self,$name)=@_;my@values;my$pairs=$self->pairs;for (my$i=0;$i < @$pairs;$i += 2){push@values,$pairs->[$i + 1]if$pairs->[$i]eq $name}return \@values}sub merge {my$self=shift;my@pairs=@_==1 ? @{shift->pairs}: @_;while (my ($name,$value)=splice@pairs,0,2){defined$value ? $self->param($name=>$value): $self->remove($name)}return$self}sub names {[sort keys %{shift->to_hash}]}sub new {@_ > 1 ? shift->SUPER::new->parse(@_): shift->SUPER::new}sub pairs {my$self=shift;if (@_){$self->{pairs}=shift;delete$self->{string};return$self}if (defined(my$str=delete$self->{string})){my$pairs=$self->{pairs}=[];return$pairs if$str eq '';my$charset=$self->charset;for my$pair (split '&',$str){next unless$pair =~ /^([^=]+)(?:=(.*))?$/;my ($name,$value)=($1,$2 // '');s/\+/ /g for$name,$value;$name=url_unescape$name;$name=decode($charset,$name)// $name if$charset;$value=url_unescape$value;$value=decode($charset,$value)// $value if$charset;push @$pairs,$name,$value}}return$self->{pairs}||= []}sub param {my ($self,$name)=(shift,shift);return$self->every_param($name)->[-1]unless @_;$self->remove($name);return$self->append($name=>ref $_[0]eq 'ARRAY' ? $_[0]: [@_])}sub parse {my$self=shift;return$self->append(@_)if @_ > 1;$self->{string}=shift;return$self}sub remove {my ($self,$name)=@_;my$pairs=$self->pairs;my$i=0;$pairs->[$i]eq $name ? splice @$pairs,$i,2 : ($i += 2)while$i < @$pairs;return$self}sub to_hash {my$self=shift;my%hash;my$pairs=$self->pairs;for (my$i=0;$i < @$pairs;$i += 2){my ($name,$value)=@{$pairs}[$i,$i + 1];if (exists$hash{$name}){$hash{$name}=[$hash{$name}]if ref$hash{$name}ne 'ARRAY';push @{$hash{$name}},$value}else {$hash{$name}=$value}}return \%hash}sub to_string {my$self=shift;my$charset=$self->charset;if (defined(my$str=$self->{string})){$str=encode$charset,$str if$charset;return url_escape$str,'^A-Za-z0-9\-._~%!$&\'()*+,;=:@/?'}my$pairs=$self->pairs;return '' unless @$pairs;my@pairs;for (my$i=0;$i < @$pairs;$i += 2){my ($name,$value)=@{$pairs}[$i,$i + 1];$name=encode$charset,$name if$charset;$name=url_escape$name,'^*\-.0-9A-Z_a-z';$value=encode$charset,$value if$charset;$value=url_escape$value,'^*\-.0-9A-Z_a-z';s/\%20/\+/g for$name,$value;push@pairs,"$name=$value"}return join '&',@pairs}1;
MOJO_PARAMETERS

$fatpacked{"Mojo/Path.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_PATH';
  package Mojo::Path;use Mojo::Base -base;use overload '@{}'=>sub {shift->parts},bool=>sub {1},'""'=>sub {shift->to_string},fallback=>1;use Mojo::Util qw(decode encode url_escape url_unescape);has charset=>'UTF-8';sub canonicalize {my$self=shift;my$parts=$self->parts;for (my$i=0;$i <= $#$parts;){if ($parts->[$i]eq '' || $parts->[$i]eq '.' || $parts->[$i]eq '...'){splice @$parts,$i,1}elsif ($i < 1 || $parts->[$i]ne '..' || $parts->[$i - 1]eq '..'){$i++}else {splice @$parts,--$i,2}}return @$parts ? $self : $self->trailing_slash(undef)}sub clone {my$self=shift;my$clone=$self->new;if (exists$self->{charset}){$clone->{charset}=$self->{charset}}if (my$parts=$self->{parts}){$clone->{$_}=$self->{$_}for qw(leading_slash trailing_slash);$clone->{parts}=[@$parts]}else {$clone->{path}=$self->{path}}return$clone}sub contains {$_[1]eq '/' || $_[0]->to_route =~ m!^\Q$_[1]\E(?:/|$)!}sub leading_slash {shift->_parse(leading_slash=>@_)}sub merge {my ($self,$path)=@_;return$self->parse($path)if$path =~ m!^/!;pop @{$self->parts}unless$self->trailing_slash;$path=$self->new($path);push @{$self->parts},@{$path->parts};return$self->trailing_slash($path->trailing_slash)}sub new {@_ > 1 ? shift->SUPER::new->parse(@_): shift->SUPER::new}sub parse {my$self=shift;$self->{path}=shift;delete @$self{qw(leading_slash parts trailing_slash)};return$self}sub parts {shift->_parse(parts=>@_)}sub to_abs_string {my$path=shift->to_string;return$path =~ m!^/! ? $path : "/$path"}sub to_dir {my$clone=shift->clone;pop @{$clone->parts}unless$clone->trailing_slash;return$clone->trailing_slash(!!@{$clone->parts})}sub to_route {my$clone=shift->clone;return '/' .join '/',@{$clone->parts},$clone->trailing_slash ? '' : ()}sub to_string {my$self=shift;my$charset=$self->charset;if (defined(my$path=$self->{path})){$path=encode$charset,$path if$charset;return url_escape$path,'^A-Za-z0-9\-._~!$&\'()*+,;=%:@/'}my@parts=@{$self->parts};@parts=map {encode$charset,$_}@parts if$charset;my$path=join '/',map {url_escape $_,'^A-Za-z0-9\-._~!$&\'()*+,;=:@'}@parts;$path="/$path" if$self->leading_slash;$path="$path/" if$self->trailing_slash;return$path}sub trailing_slash {shift->_parse(trailing_slash=>@_)}sub _parse {my ($self,$name)=(shift,shift);unless ($self->{parts}){my$path=url_unescape delete($self->{path})// '';my$charset=$self->charset;$path=decode($charset,$path)// $path if$charset;$self->{leading_slash}=$path =~ s!^/!!;$self->{trailing_slash}=$path =~ s!/$!!;$self->{parts}=[split '/',$path,-1]}return$self->{$name}unless @_;$self->{$name}=shift;return$self}1;
MOJO_PATH

$fatpacked{"Mojo/Reactor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_REACTOR';
  package Mojo::Reactor;use Mojo::Base 'Mojo::EventEmitter';use Carp 'croak';use Mojo::Loader 'load_class';sub again {croak 'Method "again" not implemented by subclass'}sub detect {my$try=$ENV{MOJO_REACTOR}|| 'Mojo::Reactor::EV';return load_class($try)? 'Mojo::Reactor::Poll' : $try}sub io {croak 'Method "io" not implemented by subclass'}sub is_running {croak 'Method "is_running" not implemented by subclass'}sub next_tick {croak 'Method "next_tick" not implemented by subclass'}sub one_tick {croak 'Method "one_tick" not implemented by subclass'}sub recurring {croak 'Method "recurring" not implemented by subclass'}sub remove {croak 'Method "remove" not implemented by subclass'}sub reset {croak 'Method "reset" not implemented by subclass'}sub start {croak 'Method "start" not implemented by subclass'}sub stop {croak 'Method "stop" not implemented by subclass'}sub timer {croak 'Method "timer" not implemented by subclass'}sub watch {croak 'Method "watch" not implemented by subclass'}1;
MOJO_REACTOR

$fatpacked{"Mojo/Reactor/EV.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_REACTOR_EV';
  package Mojo::Reactor::EV;use Mojo::Base 'Mojo::Reactor::Poll';use Carp 'croak';use EV 4.0;my$EV;sub CLONE {die "EV does not work with ithreads.\n"}sub DESTROY {undef$EV}sub again {croak 'Timer not active' unless my$timer=shift->{timers}{shift()};$timer->{watcher}->again}sub is_running {!!EV::depth}sub new {$EV++ ? Mojo::Reactor::Poll->new : shift->SUPER::new}sub one_tick {EV::run(EV::RUN_ONCE)}sub recurring {shift->_timer(1,@_)}sub start {EV::run}sub stop {EV::break(EV::BREAK_ALL)}sub timer {shift->_timer(0,@_)}sub watch {my ($self,$handle,$read,$write)=@_;my$fd=fileno$handle;croak 'I/O watcher not active' unless my$io=$self->{io}{$fd};my$mode=0;$mode |= EV::READ if$read;$mode |= EV::WRITE if$write;if ($mode==0){delete$io->{watcher}}elsif (my$w=$io->{watcher}){$w->events($mode)}else {my$cb=sub {my ($w,$revents)=@_;$self->_try('I/O watcher',$self->{io}{$fd}{cb},0)if EV::READ & $revents;$self->_try('I/O watcher',$self->{io}{$fd}{cb},1)if EV::WRITE & $revents && $self->{io}{$fd}};$io->{watcher}=EV::io($fd,$mode,$cb)}return$self}sub _timer {my ($self,$recurring,$after,$cb)=@_;$after ||= 0.0001 if$recurring;my$id=$self->_id;my$wrapper=sub {delete$self->{timers}{$id}unless$recurring;$self->_try('Timer',$cb)};EV::now_update()if$after > 0;$self->{timers}{$id}{watcher}=EV::timer($after,$after,$wrapper);return$id}1;
MOJO_REACTOR_EV

$fatpacked{"Mojo/Reactor/Poll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_REACTOR_POLL';
  package Mojo::Reactor::Poll;use Mojo::Base 'Mojo::Reactor';use Carp 'croak';use IO::Poll qw(POLLERR POLLHUP POLLIN POLLNVAL POLLOUT POLLPRI);use List::Util 'min';use Mojo::Util qw(md5_sum steady_time);use Time::HiRes 'usleep';sub again {croak 'Timer not active' unless my$timer=shift->{timers}{shift()};$timer->{time}=steady_time + $timer->{after}}sub io {my ($self,$handle,$cb)=@_;$self->{io}{fileno$handle}={cb=>$cb};return$self->watch($handle,1,1)}sub is_running {!!shift->{running}}sub next_tick {my ($self,$cb)=@_;push @{$self->{next_tick}},$cb;$self->{next_timer}//= $self->timer(0=>\&_next);return undef}sub one_tick {my$self=shift;local$self->{running}=1 unless$self->{running};my$i;until ($i ||!$self->{running}){return$self->stop unless keys %{$self->{timers}}|| keys %{$self->{io}};my$min=min map {$_->{time}}values %{$self->{timers}};my$timeout=defined$min ? $min - steady_time : 0.5;$timeout=$timeout <= 0 ? 0 : int($timeout * 1000)+ 1;if (keys %{$self->{io}}){my@poll=map {$_=>$self->{io}{$_}{mode}}keys %{$self->{io}};if (IO::Poll::_poll($timeout,@poll)> 0){while (my ($fd,$mode)=splice@poll,0,2){if ($mode & (POLLIN | POLLPRI | POLLNVAL | POLLHUP | POLLERR)){next unless my$io=$self->{io}{$fd};++$i and $self->_try('I/O watcher',$io->{cb},0)}next unless$mode & POLLOUT && (my$io=$self->{io}{$fd});++$i and $self->_try('I/O watcher',$io->{cb},1)}}}elsif ($timeout){usleep($timeout * 1000)}my$now=steady_time;for my$id (keys %{$self->{timers}}){next unless my$t=$self->{timers}{$id};next unless$t->{time}<= $now;if (exists$t->{recurring}){$t->{time}=$now + $t->{recurring}}else {$self->remove($id)}++$i and $self->_try('Timer',$t->{cb})if$t->{cb}}}}sub recurring {shift->_timer(1,@_)}sub remove {my ($self,$remove)=@_;return!!delete$self->{timers}{$remove}unless ref$remove;return!!delete$self->{io}{fileno$remove}}sub reset {delete @{shift()}{qw(io next_tick next_timer timers)}}sub start {my$self=shift;$self->{running}++;$self->one_tick while$self->{running}}sub stop {delete shift->{running}}sub timer {shift->_timer(0,@_)}sub watch {my ($self,$handle,$read,$write)=@_;croak 'I/O watcher not active' unless my$io=$self->{io}{fileno$handle};$io->{mode}=0;$io->{mode}|= POLLIN | POLLPRI if$read;$io->{mode}|= POLLOUT if$write;return$self}sub _id {my$self=shift;my$id;do {$id=md5_sum 't' .steady_time .rand 999}while$self->{timers}{$id};return$id}sub _next {my$self=shift;delete$self->{next_timer};while (my$cb=shift @{$self->{next_tick}}){$self->$cb}}sub _timer {my ($self,$recurring,$after,$cb)=@_;my$id=$self->_id;my$timer=$self->{timers}{$id}={cb=>$cb,after=>$after,time=>steady_time + $after};$timer->{recurring}=$after if$recurring;return$id}sub _try {my ($self,$what,$cb)=(shift,shift,shift);eval {$self->$cb(@_);1}or $self->emit(error=>"$what failed: $@")}1;
MOJO_REACTOR_POLL

$fatpacked{"Mojo/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER';
  package Mojo::Server;use Mojo::Base 'Mojo::EventEmitter';use Carp 'croak';use Cwd 'abs_path';use Mojo::Loader 'load_class';use Mojo::Util 'md5_sum';use POSIX ();use Scalar::Util 'blessed';has app=>sub {shift->build_app('Mojo::HelloWorld')};has reverse_proxy=>sub {$ENV{MOJO_REVERSE_PROXY}};sub build_app {my ($self,$app)=@_;local$ENV{MOJO_EXE};return$self->app($app->new)->app unless my$e=load_class$app;die ref$e ? $e : qq{Can't find application class "$app" in \@INC. (@INC)\n}}sub build_tx {my$self=shift;my$tx=$self->app->build_tx;$tx->req->reverse_proxy(1)if$self->reverse_proxy;return$tx}sub daemonize {die "Can't fork: $!" unless defined(my$pid=fork);exit 0 if$pid;POSIX::setsid or die "Can't start a new session: $!";open STDIN,'</dev/null';open STDOUT,'>/dev/null';open STDERR,'>&STDOUT'}sub load_app {my ($self,$path)=@_;{local $0=$path=abs_path$path;require FindBin;FindBin->again;local$ENV{MOJO_APP_LOADER}=1;local$ENV{MOJO_EXE};delete$INC{$path};my$app=eval "package Mojo::Server::Sandbox::@{[md5_sum $path]}; require \$path";die qq{Can't load application from file "$path": $@} if $@;die qq{File "$path" did not return an application object.\n} unless blessed$app && $app->isa('Mojo');$self->app($app)};FindBin->again;return$self->app}sub new {my$self=shift->SUPER::new(@_);$self->on(request=>sub {shift->app->handler(shift)});return$self}sub run {croak 'Method "run" not implemented by subclass'}1;
MOJO_SERVER

$fatpacked{"Mojo/Server/CGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_CGI';
  package Mojo::Server::CGI;use Mojo::Base 'Mojo::Server';has 'nph';sub run {my$self=shift;my$tx=$self->build_tx;my$req=$tx->req->parse(\%ENV);$tx->local_port($ENV{SERVER_PORT})->remote_address($ENV{REMOTE_ADDR});binmode STDIN;my$len=$req->headers->content_length;until ($req->is_finished){my$chunk=($len && $len < 131072)? $len : 131072;last unless my$read=STDIN->read(my$buffer,$chunk,0);$req->parse($buffer);last if ($len -= $read)<= 0}$self->emit(request=>$tx);STDOUT->autoflush(1);binmode STDOUT;my$res=$tx->res->fix_headers;return undef if$self->nph &&!_write($res,'get_start_line_chunk');my$code=$res->code || 404;my$msg=$res->message || $res->default_message;$res->headers->status("$code $msg")unless$self->nph;return undef unless _write($res,'get_header_chunk');return undef unless$tx->is_empty || _write($res,'get_body_chunk');$tx->server_close;return$res->code}sub _write {my ($res,$method)=@_;my$offset=0;while (1){sleep 1 and next unless defined(my$chunk=$res->$method($offset));last unless my$len=length$chunk;$offset += $len;return undef unless STDOUT->opened;print STDOUT$chunk}return 1}1;
MOJO_SERVER_CGI

$fatpacked{"Mojo/Server/Daemon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_DAEMON';
  package Mojo::Server::Daemon;use Mojo::Base 'Mojo::Server';use Carp 'croak';use Mojo::IOLoop;use Mojo::Transaction::WebSocket;use Mojo::URL;use Mojo::Util 'term_escape';use Mojo::WebSocket 'server_handshake';use Scalar::Util 'weaken';use constant DEBUG=>$ENV{MOJO_DAEMON_DEBUG}|| 0;has acceptors=>sub {[]};has [qw(backlog max_clients silent)];has inactivity_timeout=>sub {$ENV{MOJO_INACTIVITY_TIMEOUT}// 15};has ioloop=>sub {Mojo::IOLoop->singleton};has listen=>sub {[split ',',$ENV{MOJO_LISTEN}|| 'http://*:3000']};has max_requests=>25;sub DESTROY {return if Mojo::Util::_global_destruction();my$self=shift;$self->_remove($_)for keys %{$self->{connections}|| {}};my$loop=$self->ioloop;$loop->remove($_)for @{$self->acceptors}}sub run {my$self=shift;my$loop=$self->ioloop;my$int=$loop->recurring(1=>sub {});local$SIG{INT}=local$SIG{TERM}=sub {$loop->stop};$self->start->ioloop->start;$loop->remove($int)}sub start {my$self=shift;my$loop=$self->ioloop;if (my$max=$self->max_clients){$loop->max_connections($max)}if (my$servers=$self->{servers}){push @{$self->acceptors},$loop->acceptor(delete$servers->{$_})for keys %$servers}elsif (!@{$self->acceptors}){$self->_listen($_)for @{$self->listen}}return$self}sub stop {my$self=shift;my$loop=$self->ioloop;while (my$id=shift @{$self->acceptors}){my$server=$self->{servers}{$id}=$loop->acceptor($id);$loop->remove($id);$server->stop}return$self}sub _build_tx {my ($self,$id,$c)=@_;my$tx=$self->build_tx->connection($id);$tx->res->headers->server('Mojolicious (Perl)');my$handle=$self->ioloop->stream($id)->handle;$tx->local_address($handle->sockhost)->local_port($handle->sockport);$tx->remote_address($handle->peerhost)->remote_port($handle->peerport);$tx->req->url->base->scheme('https')if$c->{tls};weaken$self;$tx->on(request=>sub {my$tx=shift;if ($tx->req->is_handshake){my$ws=$self->{connections}{$id}{next}=Mojo::Transaction::WebSocket->new(handshake=>$tx);$self->emit(request=>server_handshake$ws)}else {$self->emit(request=>$tx)}my$c=$self->{connections}{$id};$tx->res->headers->connection('close')if$c->{requests}>= $self->max_requests || $tx->req->error;$tx->on(resume=>sub {$self->_write($id)});$self->_write($id)});return ++$c->{requests}> 1 ? $tx->kept_alive(1): $tx}sub _close {my ($self,$id)=@_;if (my$tx=$self->{connections}{$id}{tx}){$tx->server_close}delete$self->{connections}{$id}}sub _finish {my ($self,$id)=@_;my$c=$self->{connections}{$id};return unless my$tx=$c->{tx};return$self->_remove($id)if$tx->is_websocket;delete($c->{tx})->server_close;if (my$ws=delete$c->{next}){if ($ws->handshake->res->code==101){$c->{tx}=$ws->established(1);weaken$self;$ws->on(resume=>sub {$self->_write($id)})}else {$ws->server_close}}return$self->_remove($id)if$tx->error ||!$tx->keep_alive;return if (my$leftovers=$tx->req->content->leftovers)eq '';$tx=$c->{tx}=$self->_build_tx($id,$c);$tx->server_read($leftovers)}sub _listen {my ($self,$listen)=@_;my$url=Mojo::URL->new($listen);my$proto=$url->protocol;croak qq{Invalid listen location "$listen"} unless$proto =~ /^https?$/;my$query=$url->query;my$options={address=>$url->host,backlog=>$self->backlog,reuse=>$query->param('reuse')};if (my$port=$url->port){$options->{port}=$port}$options->{"tls_$_"}=$query->param($_)for qw(ca ciphers version);/^(.*)_(cert|key)$/ and $options->{"tls_$2"}{$1}=$query->param($_)for @{$query->names};if (my$cert=$query->param('cert')){$options->{'tls_cert'}{''}=$cert}if (my$key=$query->param('key')){$options->{'tls_key'}{''}=$key}my$verify=$query->param('verify');$options->{tls_verify}=hex$verify if defined$verify;delete$options->{address}if$options->{address}eq '*';my$tls=$options->{tls}=$proto eq 'https';weaken$self;push @{$self->acceptors},$self->ioloop->server($options=>sub {my ($loop,$stream,$id)=@_;$self->{connections}{$id}={tls=>$tls};warn "-- Accept $id (@{[$stream->handle->peerhost]})\n" if DEBUG;$stream->timeout($self->inactivity_timeout);$stream->on(close=>sub {$self && $self->_close($id)});$stream->on(error=>sub {$self && $self->app->log->error(pop)&& $self->_close($id)});$stream->on(read=>sub {$self->_read($id=>pop)});$stream->on(timeout=>sub {$self->app->log->debug('Inactivity timeout')if$self->{connections}{$id}{tx}})});return if$self->silent;$self->app->log->info(qq{Listening at "$url"});$query->pairs([]);$url->host('127.0.0.1')if$url->host eq '*';say "Server available at $url"}sub _read {my ($self,$id,$chunk)=@_;my$c=$self->{connections}{$id};my$tx=$c->{tx}||= $self->_build_tx($id,$c);warn term_escape "-- Server <<< Client (@{[_url($tx)]})\n$chunk\n" if DEBUG;$tx->server_read($chunk)}sub _remove {my ($self,$id)=@_;$self->ioloop->remove($id);$self->_close($id)}sub _url {shift->req->url->to_abs}sub _write {my ($self,$id)=@_;my$c=$self->{connections}{$id};return if!(my$tx=$c->{tx})|| $c->{writing}++;my$chunk=$tx->server_write;delete$c->{writing};warn term_escape "-- Server >>> Client (@{[_url($tx)]})\n$chunk\n" if DEBUG;my$stream=$self->ioloop->stream($id)->write($chunk);my$next=$chunk eq '' ? undef : '_write';$tx->has_subscribers('finish')? ($next='_finish'): $self->_finish($id)if$tx->is_finished;return unless$next;weaken$self;$stream->write(''=>sub {$self->$next($id)})}1;
MOJO_SERVER_DAEMON

$fatpacked{"Mojo/Server/Hypnotoad.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_HYPNOTOAD';
  package Mojo::Server::Hypnotoad;use Mojo::Base -base;use Cwd 'abs_path';use File::Basename 'dirname';use File::Spec::Functions 'catfile';use Mojo::Server::Prefork;use Mojo::Util qw(steady_time);use Scalar::Util 'weaken';has prefork=>sub {Mojo::Server::Prefork->new(listen=>['http://*:8080'])};has upgrade_timeout=>60;sub configure {my ($self,$name)=@_;my$prefork=$self->prefork;my$c=$prefork->app->config($name)|| {};$self->upgrade_timeout($c->{upgrade_timeout})if$c->{upgrade_timeout};$prefork->reverse_proxy($c->{proxy})if defined$c->{proxy};$prefork->max_clients($c->{clients})if$c->{clients};$prefork->max_requests($c->{requests})if$c->{requests};defined$c->{$_}and $prefork->$_($c->{$_})for qw(accepts backlog graceful_timeout heartbeat_interval),qw(heartbeat_timeout inactivity_timeout listen multi_accept pid_file),qw(workers)}sub run {my ($self,$app)=@_;_exit('Hypnotoad is not available for Windows.')if $^O eq 'MSWin32';$ENV{HYPNOTOAD_EXE}||= $0;$0=$ENV{HYPNOTOAD_APP}||= abs_path$app;$ENV{MOJO_MODE}||= 'production';die "Can't exec: $!" if!$ENV{HYPNOTOAD_REV}++ &&!exec $^X,$ENV{HYPNOTOAD_EXE};my$prefork=$self->prefork->cleanup(0);$prefork->load_app($app)->config->{hypnotoad}{pid_file}//= catfile dirname($ENV{HYPNOTOAD_APP}),'hypnotoad.pid';$self->configure('hypnotoad');weaken$self;$prefork->on(wait=>sub {$self->_manage});$prefork->on(reap=>sub {$self->_cleanup(pop)});$prefork->on(finish=>sub {$self->{finished}=1});_exit('Everything looks good!')if$ENV{HYPNOTOAD_TEST};$self->_stop if$ENV{HYPNOTOAD_STOP};$self->_hot_deploy unless$ENV{HYPNOTOAD_PID};$prefork->start;$prefork->daemonize if!$ENV{HYPNOTOAD_FOREGROUND}&& $ENV{HYPNOTOAD_REV}< 3;local$SIG{USR2}=sub {$self->{upgrade}||= steady_time};$prefork->cleanup(1)->run}sub _cleanup {my ($self,$pid)=@_;return unless ($self->{new}|| '')eq $pid;$self->prefork->app->log->error('Zero downtime software upgrade failed');delete @$self{qw(new upgrade)}}sub _exit {say shift and exit 0}sub _hot_deploy {return unless my$pid=shift->prefork->check_pid;kill 'USR2',$pid;_exit("Starting hot deployment for Hypnotoad server $pid.")}sub _manage {my$self=shift;my$prefork=$self->prefork;my$log=$prefork->app->log;if ($ENV{HYPNOTOAD_PID}&& $ENV{HYPNOTOAD_PID}ne $$){return unless$prefork->healthy==$prefork->workers;$log->info("Upgrade successful, stopping $ENV{HYPNOTOAD_PID}");kill 'QUIT',$ENV{HYPNOTOAD_PID}}$ENV{HYPNOTOAD_PID}=$$ unless ($ENV{HYPNOTOAD_PID}// '')eq $$;if ($self->{upgrade}&&!$self->{finished}){unless ($self->{new}){$log->info('Starting zero downtime software upgrade');die "Can't fork: $!" unless defined(my$pid=$self->{new}=fork);exec $^X,$ENV{HYPNOTOAD_EXE}or die "Can't exec: $!" unless$pid}kill 'KILL',$self->{new}if$self->{upgrade}+ $self->upgrade_timeout <= steady_time}}sub _stop {_exit('Hypnotoad server not running.')unless my$pid=shift->prefork->check_pid;kill 'QUIT',$pid;_exit("Stopping Hypnotoad server $pid gracefully.")}1;
MOJO_SERVER_HYPNOTOAD

$fatpacked{"Mojo/Server/Morbo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_MORBO';
  package Mojo::Server::Morbo;use Mojo::Base -base;use Mojo::Home;use Mojo::Server::Daemon;use POSIX 'WNOHANG';has daemon=>sub {Mojo::Server::Daemon->new};has watch=>sub {[qw(lib templates)]};sub check {my$self=shift;my@files;for my$watch (@{$self->watch}){if (-d $watch){my$home=Mojo::Home->new->parse($watch);push@files,$home->rel_file($_)for @{$home->list_files}}elsif (-r $watch){push@files,$watch}}$self->_check($_)and return $_ for@files;return undef}sub run {my ($self,$app)=@_;local$SIG{INT}=local$SIG{TERM}=sub {$self->{finished}=1;kill 'TERM',$self->{worker}if$self->{worker}};unshift @{$self->watch},$0=$app;$self->{modified}=1;$self->daemon->start->stop;$self->_manage until$self->{finished}&&!$self->{worker};exit 0}sub _check {my ($self,$file)=@_;my ($size,$mtime)=(stat$file)[7,9];return undef unless defined$mtime;my$cache=$self->{cache}||= {};my$stats=$cache->{$file}||= [$^T,$size];return undef if$mtime <= $stats->[0]&& $size==$stats->[1];return!!($cache->{$file}=[$mtime,$size])}sub _manage {my$self=shift;if (defined(my$file=$self->check)){say qq{File "$file" changed, restarting.} if$ENV{MORBO_VERBOSE};kill 'TERM',$self->{worker}if$self->{worker};$self->{modified}=1}if (my$pid=$self->{worker}){delete$self->{worker}if waitpid($pid,WNOHANG)==$pid}$self->_spawn if!$self->{worker}&& delete$self->{modified};sleep 1}sub _spawn {my$self=shift;my$manager=$$;die "Can't fork: $!" unless defined(my$pid=$self->{worker}=fork);return if$pid;my$daemon=$self->daemon;$daemon->load_app($self->watch->[0]);$daemon->ioloop->recurring(1=>sub {shift->stop unless kill 0,$manager});$daemon->run;exit 0}1;
MOJO_SERVER_MORBO

$fatpacked{"Mojo/Server/PSGI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_PSGI';
  package Mojo::Server::PSGI;use Mojo::Base 'Mojo::Server';sub run {my ($self,$env)=@_;my$tx=$self->build_tx;my$req=$tx->req->parse($env);$tx->local_port($env->{SERVER_PORT})->remote_address($env->{REMOTE_ADDR});my$len=$env->{CONTENT_LENGTH};until ($req->is_finished){my$chunk=($len && $len < 131072)? $len : 131072;last unless my$read=$env->{'psgi.input'}->read(my$buffer,$chunk,0);$req->parse($buffer);last if ($len -= $read)<= 0}$self->emit(request=>$tx);my$res=$tx->res->fix_headers;my$hash=$res->headers->to_hash(1);my@headers;for my$name (keys %$hash){push@headers,map {$name=>$_}@{$hash->{$name}}}my$io=Mojo::Server::PSGI::_IO->new(tx=>$tx,empty=>$tx->is_empty);return [$res->code // 404,\@headers,$io]}sub to_psgi_app {my$self=shift;$self->app;return sub {$self->run(@_)}}package Mojo::Server::PSGI::_IO;use Mojo::Base -base;sub close {shift->{tx}->server_close}sub getline {my$self=shift;return undef if$self->{empty};my$chunk=$self->{tx}->res->get_body_chunk($self->{offset}//= 0);return '' unless defined$chunk;return undef if$chunk eq '';$self->{offset}+= length$chunk;return$chunk}1;
MOJO_SERVER_PSGI

$fatpacked{"Mojo/Server/Prefork.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_SERVER_PREFORK';
  package Mojo::Server::Prefork;use Mojo::Base 'Mojo::Server::Daemon';use File::Spec::Functions qw(catfile tmpdir);use Mojo::Util 'steady_time';use POSIX 'WNOHANG';use Scalar::Util 'weaken';has accepts=>1000;has cleanup=>1;has [qw(graceful_timeout heartbeat_timeout)]=>20;has heartbeat_interval=>5;has 'multi_accept';has pid_file=>sub {catfile tmpdir,'prefork.pid'};has workers=>4;sub DESTROY {my$self=shift;return unless$self->cleanup;if (my$file=$self->pid_file){unlink$file if -w $file}}sub check_pid {my$file=shift->pid_file;return undef unless open my$handle,'<',$file;my$pid=<$handle>;chomp$pid;return$pid if$pid && kill 0,$pid;unlink$file if -w $file;return undef}sub ensure_pid_file {my$self=shift;return if -e (my$file=$self->pid_file);$self->app->log->error(qq{Can't create process id file "$file": $!})and die qq{Can't create process id file "$file": $!} unless open my$handle,'>',$file;$self->app->log->info(qq{Creating process id file "$file"});chmod 0644,$handle;print$handle $$}sub healthy {scalar grep {$_->{healthy}}values %{shift->{pool}}}sub run {my$self=shift;say 'Preforking is not available for Windows.' and exit 0 if $^O eq 'MSWin32';my$loop=$self->ioloop->max_accepts($self->accepts);if (defined(my$multi=$self->multi_accept)){$loop->multi_accept($multi)}pipe($self->{reader},$self->{writer})or die "Can't create pipe: $!";local$SIG{CHLD}=sub {while ((my$pid=waitpid -1,WNOHANG)> 0){$self->emit(reap=>$pid)->_stopped($pid)}};local$SIG{INT}=local$SIG{TERM}=sub {$self->_term};local$SIG{QUIT}=sub {$self->_term(1)};local$SIG{TTIN}=sub {$self->workers($self->workers + 1)};local$SIG{TTOU}=sub {$self->workers > 0 ? $self->workers($self->workers - 1): return;for my$w (values %{$self->{pool}}){($w->{graceful}=steady_time)and last unless$w->{graceful}}};$self->start->app->log->info("Manager $$ started");$self->{running}=1;$self->_manage while$self->{running}}sub _heartbeat {shift->{writer}->syswrite("$$:$_[0]\n")or exit 0}sub _manage {my$self=shift;if (!$self->{finished}){$self->_spawn while keys %{$self->{pool}}< $self->workers;$self->ensure_pid_file}elsif (!keys %{$self->{pool}}){return delete$self->{running}}$self->_wait;my$interval=$self->heartbeat_interval;my$ht=$self->heartbeat_timeout;my$gt=$self->graceful_timeout;my$log=$self->app->log;my$time=steady_time;for my$pid (keys %{$self->{pool}}){next unless my$w=$self->{pool}{$pid};$log->error("Worker $pid has no heartbeat, restarting")and $w->{graceful}=$time if!$w->{graceful}&& ($w->{time}+ $interval + $ht <= $time);my$graceful=$w->{graceful}||= $self->{graceful}? $time : undef;$log->debug("Stopping worker $pid gracefully")and (kill 'QUIT',$pid or $self->_stopped($pid))if$graceful &&!$w->{quit}++;$w->{force}=1 if$graceful && $graceful + $gt <= $time;$log->debug("Stopping worker $pid")and (kill 'KILL',$pid or $self->_stopped($pid))if$w->{force}|| ($self->{finished}&&!$graceful)}}sub _spawn {my$self=shift;die "Can't fork: $!" unless defined(my$pid=fork);return$self->emit(spawn=>$pid)->{pool}{$pid}={time=>steady_time}if$pid;my$loop=$self->cleanup(0)->ioloop;my$finished=0;$loop->on(finish=>sub {$finished=1});weaken$self;my$cb=sub {$self->_heartbeat($finished)};$loop->next_tick($cb);$loop->recurring($self->heartbeat_interval=>$cb);$SIG{$_}='DEFAULT' for qw(CHLD INT TERM TTIN TTOU);$SIG{QUIT}=sub {$loop->stop_gracefully};delete$self->{reader};srand;$self->app->log->debug("Worker $$ started");$loop->start;exit 0}sub _stopped {my ($self,$pid)=@_;return unless my$w=delete$self->{pool}{$pid};my$log=$self->app->log;$log->debug("Worker $pid stopped");$log->error("Worker $pid stopped too early, shutting down")and $self->_term unless$w->{healthy}}sub _term {my ($self,$graceful)=@_;@{$self->emit(finish=>$graceful)}{qw(finished graceful)}=(1,$graceful)}sub _wait {my$self=shift;my$reader=$self->emit('wait')->{reader};return unless Mojo::Util::_readable(1000,fileno($reader));return unless$reader->sysread(my$chunk,4194304);my$time=steady_time;while ($chunk =~ /(\d+):(\d)\n/g){next unless my$w=$self->{pool}{$1};@$w{qw(healthy time)}=(1,$time)and $self->emit(heartbeat=>$1);$w->{graceful}||= $time if $2}}1;
MOJO_SERVER_PREFORK

$fatpacked{"Mojo/Template.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TEMPLATE';
  package Mojo::Template;use Mojo::Base -base;use Carp 'croak';use Mojo::ByteStream;use Mojo::Exception;use Mojo::Util qw(decode encode monkey_patch slurp);use constant DEBUG=>$ENV{MOJO_TEMPLATE_DEBUG}|| 0;has [qw(append code prepend unparsed)]=>'';has [qw(auto_escape compiled)];has capture_end=>'end';has capture_start=>'begin';has comment_mark=>'#';has encoding=>'UTF-8';has escape=>sub {\&Mojo::Util::xss_escape};has [qw(escape_mark expression_mark trim_mark)]=>'=';has [qw(line_start replace_mark)]=>'%';has name=>'template';has namespace=>'Mojo::Template::SandBox';has tag_start=>'<%';has tag_end=>'%>';has tree=>sub {[]};sub build {my$self=shift;my$tree=$self->tree;my$escape=$self->auto_escape;my@blocks=('');my ($i,$capture,$multi);while (++$i <= @$tree && (my$next=$tree->[$i])){my ($op,$value)=@{$tree->[$i - 1]};push@blocks,'' and next if$op eq 'line';my$newline=chomp($value //= '');if ($op eq 'text'){$value=join "\n",map {quotemeta $_}split("\n",$value,-1);$value .= '\n' if$newline;$blocks[-1].= "\$_O .= \"" .$value ."\";" if$value ne ''}elsif ($op eq 'code' || $multi){$blocks[-1].= $value}elsif ($op eq 'cpen'){$blocks[-1].= 'return Mojo::ByteStream->new($_O) }';$blocks[-1].= ';' if ($next->[1]// '')=~ /^\s*$/}if ($op eq 'expr' || $op eq 'escp'){if (!$multi && ($op eq 'escp' &&!$escape || $op eq 'expr' && $escape)){$blocks[-1].= "\$_O .= _escape scalar + $value"}elsif (!$multi){$blocks[-1].= "\$_O .= scalar + $value"}$multi=!$next || $next->[0]ne 'text';$blocks[-1].= ';' unless$multi || $capture}if ($op eq 'cpst'){$capture=1}elsif ($capture){$blocks[-1].= " sub { my \$_O = ''; ";$capture=0}}return$self->code(join "\n",@blocks)->tree([])}sub compile {my$self=shift;return undef unless defined(my$code=$self->code);my$compiled=eval$self->_wrap($code);$self->compiled($compiled)and return undef unless $@;return Mojo::Exception->new($@,[$self->unparsed,$code])->trace->verbose(1)}sub interpret {my$self=shift;local$SIG{__DIE__}=sub {CORE::die($_[0])if ref $_[0];Mojo::Exception->throw(shift,[$self->unparsed,$self->code])};return undef unless my$compiled=$self->compiled;my$output;return$output if eval {$output=$compiled->(@_);1};return Mojo::Exception->new($@,[$self->unparsed])->verbose(1)}sub parse {my ($self,$template)=@_;$self->unparsed($template)->tree(\my@tree);my$tag=$self->tag_start;my$replace=$self->replace_mark;my$expr=$self->expression_mark;my$escp=$self->escape_mark;my$cpen=$self->capture_end;my$cmnt=$self->comment_mark;my$cpst=$self->capture_start;my$trim=$self->trim_mark;my$end=$self->tag_end;my$start=$self->line_start;my$line_re =qr/^(\s*)\Q$start\E(?:(\Q$replace\E)|(\Q$cmnt\E)|(\Q$expr\E))?(.*)$/;my$token_re=qr/
      (
        \Q$tag\E(?:\Q$replace\E|\Q$cmnt\E)                   # Replace
      |
        \Q$tag$expr\E(?:\Q$escp\E)?(?:\s*\Q$cpen\E(?!\w))?   # Expression
      |
        \Q$tag\E(?:\s*\Q$cpen\E(?!\w))?                      # Code
      |
        (?:(?<!\w)\Q$cpst\E\s*)?(?:\Q$trim\E)?\Q$end\E       # End
      )
    /x;my$cpen_re=qr/^\Q$tag\E(?:\Q$expr\E)?(?:\Q$escp\E)?\s*\Q$cpen\E(.*)$/;my$end_re=qr/^(?:(\Q$cpst\E)\s*)?(\Q$trim\E)?\Q$end\E$/;my$op='text';my ($trimming,$capture);for my$line (split "\n",$template){if ($op eq 'text' && $line =~ $line_re){if ($2){$line="$1$start$5"}elsif ($3){$line="$tag$3 $trim$end"}else {$line=$4 ? "$1$tag$4$5 $end" : "$tag$5 $trim$end"}}$line .= "\n" if$line !~ s/\\\\$/\\\n/ && $line !~ s/\\$//;for my$token (split$token_re,$line){($token,$capture)=("$tag$1",1)if$token =~ $cpen_re;if ($op ne 'text' && $token =~ $end_re){$op='text';splice@tree,-1,0,['cpst']if $1;_trim(\@tree)if ($trimming=$2)&& @tree > 1;push@tree,['text','']}elsif ($token eq $tag){$op='code'}elsif ($token eq "$tag$expr"){$op='expr'}elsif ($token eq "$tag$expr$escp"){$op='escp'}elsif ($token eq "$tag$cmnt"){$op='cmnt'}elsif ($op ne 'cmnt'){$token=$tag if$token eq "$tag$replace";if ($trimming && $token =~ s/^(\s+)//){push@tree,['code',$1];$trimming=0}push@tree,$capture ? ['cpen']: (),[$op,$token];$capture=0}}push@tree,['line']and next if$tree[-4]&& $tree[-4][0]ne 'line' || (!$tree[-3]|| $tree[-3][0]ne 'text' || $tree[-3][1]!~ /\n$/)|| ($tree[-2][0]ne 'line' || $tree[-1][0]ne 'text');$tree[-3][1].= pop(@tree)->[1]}return$self}sub render {my$self=shift;return$self->parse(shift)->build->compile || $self->interpret(@_)}sub render_file {my ($self,$path)=(shift,shift);$self->name($path)unless defined$self->{name};my$template=slurp$path;my$encoding=$self->encoding;croak qq{Template "$path" has invalid encoding} if$encoding &&!defined($template=decode$encoding,$template);return$self->render($template,@_)}sub _line {my$name=shift->name;$name =~ y/"//d;return qq{#line @{[shift]} "$name"}}sub _trim {my$tree=shift;my$i=$tree->[-2][0]eq 'cpst' || $tree->[-2][0]eq 'cpen' ? -3 : -2;return unless$tree->[$i][0]eq 'text';splice @$tree,$i,0,['code',$1]if$tree->[$i][1]=~ s/(\s+)$//}sub _wrap {my ($self,$code)=@_;monkey_patch$self->namespace,'_escape',$self->escape;my$num=()=$code =~ /\n/g;my$head=$self->_line(1)."\npackage @{[$self->namespace]};";$head .= " use Mojo::Base -strict; no warnings 'ambiguous';";$code="$head sub { my \$_O = ''; @{[$self->prepend]}; { $code\n";$code .= $self->_line($num + 1)."\n@{[$self->append]}; } \$_O };";warn "-- Code for @{[$self->name]}\n@{[encode 'UTF-8', $code]}\n\n" if DEBUG;return$code}1;
MOJO_TEMPLATE

$fatpacked{"Mojo/Transaction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TRANSACTION';
  package Mojo::Transaction;use Mojo::Base 'Mojo::EventEmitter';use Carp 'croak';use Mojo::Message::Request;use Mojo::Message::Response;has [qw(kept_alive local_address local_port original_remote_address remote_port)];has req=>sub {Mojo::Message::Request->new};has res=>sub {Mojo::Message::Response->new};sub client_close {shift->server_close}sub client_read {croak 'Method "client_read" not implemented by subclass'}sub client_write {croak 'Method "client_write" not implemented by subclass'}sub completed {++$_[0]{completed}and return $_[0]}sub connection {my$self=shift;return$self->emit(connection=>$self->{connection}=shift)if @_;return$self->{connection}}sub error {$_[0]->req->error || $_[0]->res->error}sub is_finished {!!shift->{completed}}sub is_websocket {undef}sub remote_address {my$self=shift;return$self->original_remote_address(@_)if @_;return$self->original_remote_address unless$self->req->reverse_proxy;return ($self->req->headers->header('X-Forwarded-For')// '')=~ /([^,\s]+)$/ ? $1 : $self->original_remote_address}sub server_close {shift->completed->emit('finish')}sub server_read {croak 'Method "server_read" not implemented by subclass'}sub server_write {croak 'Method "server_write" not implemented by subclass'}sub success {$_[0]->error ? undef : $_[0]->res}1;
MOJO_TRANSACTION

$fatpacked{"Mojo/Transaction/HTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TRANSACTION_HTTP';
  package Mojo::Transaction::HTTP;use Mojo::Base 'Mojo::Transaction';has 'previous';sub client_close {my ($self,$close)=@_;my$res=$self->res->finish;if ($close &&!$res->code &&!$res->error){$res->error({message=>'Premature connection close'})}elsif ($res->is_status_class(400)|| $res->is_status_class(500)){$res->error({message=>$res->message,code=>$res->code})}$self->server_close}sub client_read {my ($self,$chunk)=@_;my$res=$self->res;$res->content->skip_body(1)if uc$self->req->method eq 'HEAD';return unless$res->parse($chunk)->is_finished;return$self->completed if!$res->is_status_class(100)|| $res->headers->upgrade;$self->res($res->new)->emit(unexpected=>$res);return if (my$leftovers=$res->content->leftovers)eq '';$self->client_read($leftovers)}sub client_write {shift->_write(0)}sub is_empty {!!(uc $_[0]->req->method eq 'HEAD' || $_[0]->res->is_empty)}sub keep_alive {my$self=shift;my$req=$self->req;my$res=$self->res;my$req_conn=lc($req->headers->connection // '');my$res_conn=lc($res->headers->connection // '');return undef if$req_conn eq 'close' || $res_conn eq 'close';return$res_conn eq 'keep-alive' if$res->version eq '1.0';return$req_conn eq 'keep-alive' if$req->version eq '1.0';return 1}sub redirects {my$previous=shift;my@redirects;unshift@redirects,$previous while$previous=$previous->previous;return \@redirects}sub resume {++$_[0]{writing}and return $_[0]->emit('resume')}sub server_read {my ($self,$chunk)=@_;my$req=$self->req;$req->parse($chunk)unless$req->error;$self->emit('request')if$req->is_finished &&!$self->{handled}++}sub server_write {shift->_write(1)}sub _body {my ($self,$msg,$finish)=@_;my$buffer=$msg->get_body_chunk($self->{offset});my$written=defined$buffer ? length$buffer : 0;$self->{write}=$msg->content->is_dynamic ? 1 : ($self->{write}- $written);$self->{offset}+= $written;$self->{writing}=0 unless defined$buffer;$finish ? $self->completed : ($self->{writing}=0)if$self->{write}<= 0 || defined$buffer && $buffer eq '';return$buffer // ''}sub _headers {my ($self,$msg,$head)=@_;my$buffer=$msg->get_header_chunk($self->{offset});my$written=defined$buffer ? length$buffer : 0;$self->{write}-= $written;$self->{offset}+= $written;if ($self->{write}<= 0){$self->{offset}=0;if ($head && $self->is_empty){$self->completed}else {$self->{http_state}='body';$self->{write}=$msg->content->is_dynamic ? 1 : $msg->body_size}}return$buffer}sub _start_line {my ($self,$msg)=@_;my$buffer=$msg->get_start_line_chunk($self->{offset});my$written=defined$buffer ? length$buffer : 0;$self->{write}-= $written;$self->{offset}+= $written;@$self{qw(http_state write offset)}=('headers',$msg->header_size,0)if$self->{write}<= 0;return$buffer}sub _write {my ($self,$server)=@_;return '' unless$server ? $self->{writing}: ($self->{writing}//= 1);$self->{$_}||= 0 for qw(offset write);my$msg=$server ? $self->res : $self->req;@$self{qw(http_state write)}=('start_line',$msg->start_line_size)unless$self->{http_state};my$chunk='';$chunk .= $self->_start_line($msg)if$self->{http_state}eq 'start_line';$chunk .= $self->_headers($msg,$server)if$self->{http_state}eq 'headers';$chunk .= $self->_body($msg,$server)if$self->{http_state}eq 'body';return$chunk}1;
MOJO_TRANSACTION_HTTP

$fatpacked{"Mojo/Transaction/WebSocket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_TRANSACTION_WEBSOCKET';
  package Mojo::Transaction::WebSocket;use Mojo::Base 'Mojo::Transaction';use Compress::Raw::Zlib 'Z_SYNC_FLUSH';use Config;use List::Util 'first';use Mojo::JSON qw(encode_json j);use Mojo::Util qw(decode deprecated encode trim);use Mojo::WebSocket qw(WS_BINARY WS_CLOSE WS_CONTINUATION WS_PING WS_PONG WS_TEXT);has [qw(compressed established handshake masked)];has max_websocket_size=>sub {$ENV{MOJO_MAX_WEBSOCKET_SIZE}|| 262144};sub build_frame {deprecated 'Mojo::Transaction::WebSocket::build_frame is DEPRECATED';Mojo::WebSocket::build_frame(shift->masked,@_)}sub build_message {my ($self,$frame)=@_;$frame={text=>encode('UTF-8',$frame)}if ref$frame ne 'HASH';$frame->{text}=encode_json($frame->{json})if exists$frame->{json};if (exists$frame->{text}){$frame=[1,0,0,0,WS_TEXT,$frame->{text}]}else {$frame=[1,0,0,0,WS_BINARY,$frame->{binary}]}return$frame unless$self->compressed;my$deflate=$self->{deflate}||= Compress::Raw::Zlib::Deflate->new(AppendOutput=>1,MemLevel=>8,WindowBits=>-15);$deflate->deflate($frame->[5],my$out);$deflate->flush($out,Z_SYNC_FLUSH);@$frame[1,5]=(1,substr($out,0,length($out)- 4));return$frame}sub client_read {shift->server_read(@_)}sub client_write {shift->server_write(@_)}sub connection {shift->handshake->connection}sub finish {my$self=shift;my$close=$self->{close}=[@_];my$payload=$close->[0]? pack('n',$close->[0]): '';$payload .= encode 'UTF-8',$close->[1]if defined$close->[1];$close->[0]//= 1005;$self->send([1,0,0,0,WS_CLOSE,$payload])->{closing}=1;return$self}sub is_websocket {1}sub kept_alive {shift->handshake->kept_alive}sub local_address {shift->handshake->local_address}sub local_port {shift->handshake->local_port}sub new {my$self=shift->SUPER::new(@_);$self->on(frame=>sub {shift->_message(@_)});return$self}sub parse_frame {deprecated 'Mojo::Transaction::WebSocket::parse_frame is DEPRECATED';Mojo::WebSocket::parse_frame($_[1],$_[0]->max_websocket_size)}sub protocol {shift->res->headers->sec_websocket_protocol}sub remote_address {shift->handshake->remote_address}sub remote_port {shift->handshake->remote_port}sub req {shift->handshake->req}sub res {shift->handshake->res}sub resume {$_[0]->handshake->resume and return $_[0]}sub send {my ($self,$msg,$cb)=@_;$self->once(drain=>$cb)if$cb;$msg=$self->build_message($msg)unless ref$msg eq 'ARRAY';$self->{write}.= Mojo::WebSocket::build_frame($self->masked,@$msg);return$self->emit('resume')}sub server_close {my$self=shift->completed;return$self->emit(finish=>$self->{close}? (@{$self->{close}}): 1006)}sub server_read {my ($self,$chunk)=@_;$self->{read}.= $chunk // '';my$max=$self->max_websocket_size;while (my$frame=Mojo::WebSocket::parse_frame(\$self->{read},$max)){$self->finish(1009)and last unless ref$frame;$self->emit(frame=>$frame)}$self->emit('resume')}sub server_write {my$self=shift;$self->emit('drain')if ($self->{write}//= '')eq '';$self->completed if$self->{write}eq '' && $self->{closing};return delete$self->{write}}sub with_compression {my$self=shift;$self->compressed(1)and $self->res->headers->sec_websocket_extensions('permessage-deflate')if ($self->req->headers->sec_websocket_extensions // '')=~ /permessage-deflate/}sub with_protocols {my$self=shift;my%protos=map {trim($_)=>1}split ',',$self->req->headers->sec_websocket_protocol;return undef unless my$proto=first {$protos{$_}}@_;$self->res->headers->sec_websocket_protocol($proto);return$proto}sub _message {my ($self,$frame)=@_;my$op=$frame->[4]|| WS_CONTINUATION;return$self->send([1,0,0,0,WS_PONG,$frame->[5]])if$op==WS_PING;return if$op==WS_PONG;if ($op==WS_CLOSE){return$self->finish unless length$frame->[5]>= 2;return$self->finish(unpack('n',substr($frame->[5],0,2,'')),decode('UTF-8',$frame->[5]))}$self->{op}=$op unless exists$self->{op};$self->{message}.= $frame->[5];my$max=$self->max_websocket_size;return$self->finish(1009)if length$self->{message}> $max;return unless$frame->[0];my$msg=delete$self->{message};if ($self->compressed && $frame->[1]){my$inflate=$self->{inflate}||= Compress::Raw::Zlib::Inflate->new(Bufsize=>$max,LimitOutput=>1,WindowBits=>-15);$inflate->inflate(($msg .= "\x00\x00\xff\xff"),my$out);return$self->finish(1009)if$msg ne '';$msg=$out}$self->emit(json=>j($msg))if$self->has_subscribers('json');$op=delete$self->{op};$self->emit($op==WS_TEXT ? 'text' : 'binary'=>$msg);$self->emit(message=>$op==WS_TEXT ? decode 'UTF-8',$msg : $msg)if$self->has_subscribers('message')}1;
MOJO_TRANSACTION_WEBSOCKET

$fatpacked{"Mojo/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_URL';
  package Mojo::URL;use Mojo::Base -base;use overload bool=>sub {1},'""'=>sub {shift->to_string},fallback=>1;use Mojo::Parameters;use Mojo::Path;use Mojo::Util qw(decode encode punycode_decode punycode_encode url_escape url_unescape);has base=>sub {Mojo::URL->new};has [qw(fragment host port scheme userinfo)];sub authority {my$self=shift;if (@_){return$self unless defined(my$authority=shift);$self->userinfo(_decode(url_unescape $1))if$authority =~ s/^([^\@]+)\@//;$authority =~ s/:(\d+)$// and $self->port($1);my$host=url_unescape$authority;return$host =~ /[^\x00-\x7f]/ ? $self->ihost($host): $self->host($host)}return undef unless defined(my$authority=$self->host_port);return$authority unless defined(my$info=$self->userinfo);return _encode($info,'^A-Za-z0-9\-._~!$&\'()*+,;=:').'@' .$authority}sub clone {my$self=shift;my$clone=$self->new;@$clone{keys %$self}=values %$self;$clone->{$_}&& ($clone->{$_}=$clone->{$_}->clone)for qw(base path query);return$clone}sub host_port {my$self=shift;return undef unless defined(my$host=$self->ihost);return$host unless my$port=$self->port;return "$host:$port"}sub ihost {my$self=shift;return$self->host(join '.',map {/^xn--(.+)$/ ? punycode_decode $1 : $_}split(/\./,shift,-1))if @_;return undef unless defined(my$host=$self->host);return lc$host unless$host =~ /[^\x00-\x7f]/;return lc join '.',map {/[^\x00-\x7f]/ ? ('xn--' .punycode_encode $_): $_}split(/\./,$host,-1)}sub is_abs {!!shift->scheme}sub new {@_ > 1 ? shift->SUPER::new->parse(@_): shift->SUPER::new}sub parse {my ($self,$url)=@_;$url =~ m!^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?!;$self->scheme($2)if defined $2;$self->authority($4)if defined $4;$self->path($5)if defined $5;$self->query($7)if defined $7;$self->fragment(_decode(url_unescape $9))if defined $9;return$self}sub path {my$self=shift;$self->{path}||= Mojo::Path->new;return$self->{path}unless @_;$self->{path}=ref $_[0]? $_[0]: $self->{path}->merge($_[0]);return$self}sub path_query {my$self=shift;my$query=$self->query->to_string;return$self->path->to_string .($query eq '' ? '' : "?$query")}sub protocol {lc(shift->scheme // '')}sub query {my$self=shift;my$q=$self->{query}||= Mojo::Parameters->new;return$q unless @_;if (@_ > 1){$q->pairs([])->parse(@_)}elsif (ref $_[0]eq 'ARRAY'){$q->merge(@{$_[0]})}elsif (ref $_[0]eq 'HASH'){$q->append(%{$_[0]})}else {$self->{query}=ref $_[0]? $_[0]: $q->parse($_[0])}return$self}sub to_abs {my$self=shift;my$abs=$self->clone;return$abs if$abs->is_abs;my$base=shift || $abs->base;$abs->base($base)->scheme($base->scheme);return$abs if$abs->authority;$abs->authority($base->authority);my$path=$abs->path;return$abs if$path->leading_slash;my$base_path=$base->path;if (!@{$path->parts}){$path =$abs->path($base_path->clone)->path->trailing_slash(0)->canonicalize;return$abs if$abs->query->to_string ne '';$abs->query($base->query->clone)}else {$abs->path($base_path->clone->merge($path)->canonicalize)}return$abs}sub to_string {my$self=shift;my$url='';if (my$proto=$self->protocol){$url .= "$proto:"}my$authority=$self->authority;$url .= "//$authority" if defined$authority;my$path=$self->path_query;$url .=!$authority || $path eq '' || $path =~ m!^[/?]! ? $path : "/$path";return$url unless defined(my$fragment=$self->fragment);return$url .'#' ._encode($fragment,'^A-Za-z0-9\-._~!$&\'()*+,;=%:@/?')}sub _decode {decode('UTF-8',$_[0])// $_[0]}sub _encode {url_escape encode('UTF-8',$_[0]),$_[1]}1;
MOJO_URL

$fatpacked{"Mojo/Upload.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_UPLOAD';
  package Mojo::Upload;use Mojo::Base -base;has [qw(asset filename headers name)];sub move_to {$_[0]->asset->move_to($_[1])and return $_[0]}sub size {shift->asset->size}sub slurp {shift->asset->slurp}1;
MOJO_UPLOAD

$fatpacked{"Mojo/UserAgent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT';
  package Mojo::UserAgent;use Mojo::Base 'Mojo::EventEmitter';use Mojo::IOLoop;use Mojo::Util qw(monkey_patch term_escape);use Mojo::UserAgent::CookieJar;use Mojo::UserAgent::Proxy;use Mojo::UserAgent::Server;use Mojo::UserAgent::Transactor;use Scalar::Util 'weaken';use constant DEBUG=>$ENV{MOJO_USERAGENT_DEBUG}|| 0;has ca=>sub {$ENV{MOJO_CA_FILE}};has cert=>sub {$ENV{MOJO_CERT_FILE}};has connect_timeout=>sub {$ENV{MOJO_CONNECT_TIMEOUT}|| 10};has cookie_jar=>sub {Mojo::UserAgent::CookieJar->new};has 'local_address';has inactivity_timeout=>sub {$ENV{MOJO_INACTIVITY_TIMEOUT}// 20};has ioloop=>sub {Mojo::IOLoop->new};has key=>sub {$ENV{MOJO_KEY_FILE}};has max_connections=>5;has max_redirects=>sub {$ENV{MOJO_MAX_REDIRECTS}|| 0};has proxy=>sub {Mojo::UserAgent::Proxy->new};has request_timeout=>sub {$ENV{MOJO_REQUEST_TIMEOUT}// 0};has server=>sub {Mojo::UserAgent::Server->new(ioloop=>shift->ioloop)};has transactor=>sub {Mojo::UserAgent::Transactor->new};for my$name (qw(DELETE GET HEAD OPTIONS PATCH POST PUT)){monkey_patch __PACKAGE__,lc$name,sub {my$self=shift;my$cb=ref $_[-1]eq 'CODE' ? pop : undef;return$self->start($self->build_tx($name,@_),$cb)}}sub DESTROY {Mojo::Util::_global_destruction()or shift->_cleanup}sub build_tx {shift->transactor->tx(@_)}sub build_websocket_tx {shift->transactor->websocket(@_)}sub start {my ($self,$tx,$cb)=@_;$self->_cleanup->server->restart unless ($self->{pid}//= $$)eq $$;if ($cb){warn "-- Non-blocking request (@{[_url($tx)]})\n" if DEBUG;return$self->_start(Mojo::IOLoop->singleton,$tx,$cb)}warn "-- Blocking request (@{[_url($tx)]})\n" if DEBUG;$self->_start($self->ioloop,$tx=>sub {shift->ioloop->stop;$tx=shift});$self->ioloop->start;return$tx}sub websocket {my ($self,$cb)=(shift,pop);$self->start($self->build_websocket_tx(@_),$cb)}sub _cleanup {my$self=shift;delete$self->{pid};$self->_finish($_,1)for keys %{$self->{connections}|| {}};return$self}sub _connect {my ($self,$loop,$peer,$tx,$handle,$cb)=@_;my$t=$self->transactor;my ($proto,$host,$port)=$peer ? $t->peer($tx): $t->endpoint($tx);my%options =(address=>$host,port=>$port,timeout=>$self->connect_timeout);if (my$local=$self->local_address){$options{local_address}=$local}$options{handle}=$handle if$handle;if ($proto eq 'socks'){@options{qw(socks_address socks_port)}=@options{qw(address port)};($proto,@options{qw(address port)})=$t->endpoint($tx);my$userinfo=$tx->req->via_proxy(0)->proxy->userinfo;@options{qw(socks_user socks_pass)}=split ':',$userinfo if$userinfo}map {$options{"tls_$_"}=$self->$_}qw(ca cert key) if ($options{tls}=$proto eq 'https');weaken$self;my$id;return$id=$loop->client(%options=>sub {my ($loop,$err,$stream)=@_;return unless$self;return$self->_error($id,$err)if$err;$stream->on(timeout=>sub {$self->_error($id,'Inactivity timeout')});$stream->on(close=>sub {$self && $self->_finish($id,1)});$stream->on(error=>sub {$self && $self->_error($id,pop)});$stream->on(read=>sub {$self->_read($id,pop)});$self->$cb($id)})}sub _connect_proxy {my ($self,$loop,$old,$cb)=@_;return undef unless my$new=$self->transactor->proxy_connect($old);return$self->_start(($loop,$new)=>sub {my ($self,$tx)=@_;$old->res->error({message=>'Proxy connection failed'})and return$self->$cb($old)if$tx->error ||!$tx->res->is_status_class(200)||!$tx->keep_alive;$old->req->via_proxy(0);my$id=$tx->connection;return$self->_start($loop,$old->connection($id),$cb)unless$tx->req->url->protocol eq 'https';my$handle=$loop->stream($id)->steal_handle;$self->_remove($id);$id=$self->_connect($loop,0,$old,$handle,sub {shift->_start($loop,$old->connection($id),$cb)});$self->{connections}{$id}={cb=>$cb,ioloop=>$loop,tx=>$old}})}sub _connected {my ($self,$id)=@_;my$c=$self->{connections}{$id};my$stream=$c->{ioloop}->stream($id)->timeout($self->inactivity_timeout);my$tx=$c->{tx}->connection($id);my$handle=$stream->handle;$tx->local_address($handle->sockhost)->local_port($handle->sockport);$tx->remote_address($handle->peerhost)->remote_port($handle->peerport);weaken$self;$tx->on(resume=>sub {$self->_write($id)});$self->_write($id)}sub _connection {my ($self,$loop,$tx,$cb)=@_;my ($proto,$host,$port)=$self->transactor->endpoint($tx);my$id=$tx->connection || $self->_dequeue($loop,"$proto:$host:$port",1);if ($id){warn "-- Reusing connection $id ($proto://$host:$port)\n" if DEBUG;@{$self->{connections}{$id}}{qw(cb tx)}=($cb,$tx);$tx->kept_alive(1)unless$tx->connection;$self->_connected($id);return$id}if (my$id=$self->_connect_proxy($loop,$tx,$cb)){return$id}$id=$self->_connect($loop,1,$tx,undef,\&_connected);warn "-- Connect $id ($proto://$host:$port)\n" if DEBUG;$self->{connections}{$id}={cb=>$cb,ioloop=>$loop,tx=>$tx};return$id}sub _dequeue {my ($self,$loop,$name,$test)=@_;my$old=$self->{queue}{$loop}||= [];my ($found,@new);for my$queued (@$old){push@new,$queued and next if$found ||!grep {$_ eq $name}@$queued;next unless my$stream=$loop->stream($queued->[1]);$test && $stream->is_readable ? $stream->close : ($found=$queued->[1])}@$old=@new;return$found}sub _error {my ($self,$id,$err)=@_;my$tx=$self->{connections}{$id}{tx};$tx->res->error({message=>$err})if$tx;$self->_finish($id,1)}sub _finish {my ($self,$id,$close)=@_;return unless my$c=$self->{connections}{$id};$c->{ioloop}->remove($c->{timeout})if$c->{timeout};return$self->_reuse($id,$close)unless my$old=$c->{tx};$old->client_close($close);return$self->_remove($id)if$old->is_websocket;$self->cookie_jar->collect($old);if (my$new=$self->transactor->upgrade($old)){weaken$self;$new->on(resume=>sub {$self->_write($id)});$c->{cb}($self,$c->{tx}=$new);return$new->client_read($old->res->content->leftovers)}$self->_reuse($id,$close);$c->{cb}($self,$old)unless$self->_redirect($c,$old)}sub _read {my ($self,$id,$chunk)=@_;return$self->_remove($id)unless my$tx=$self->{connections}{$id}{tx};warn term_escape "-- Client <<< Server (@{[_url($tx)]})\n$chunk\n" if DEBUG;$tx->client_read($chunk);$self->_finish($id)if$tx->is_finished}sub _redirect {my ($self,$c,$old)=@_;return undef unless my$new=$self->transactor->redirect($old);return undef unless @{$old->redirects}< $self->max_redirects;return$self->_start($c->{ioloop},$new,delete$c->{cb})}sub _remove {my ($self,$id)=@_;my$c=delete$self->{connections}{$id};$self->_dequeue($c->{ioloop},$id);$c->{ioloop}->remove($id)}sub _reuse {my ($self,$id,$close)=@_;my$c=$self->{connections}{$id};my$tx=delete$c->{tx};my$max=$self->max_connections;return$self->_remove($id)if$close ||!$tx ||!$max ||!$tx->keep_alive || $tx->error;my$queue=$self->{queue}{$c->{ioloop}}||= [];$self->_remove(shift(@$queue)->[1])while @$queue && @$queue >= $max;push @$queue,[join(':',$self->transactor->endpoint($tx)),$id]}sub _start {my ($self,$loop,$tx,$cb)=@_;my$url=$tx->req->url;unless ($url->is_abs){my$base =$loop==$self->ioloop ? $self->server->url : $self->server->nb_url;$url->scheme($base->scheme)->authority($base->authority)}$_->prepare($tx)for$self->proxy,$self->cookie_jar;my$id=$self->emit(start=>$tx)->_connection($loop,$tx,$cb);if (my$timeout=$self->request_timeout){weaken$self;$self->{connections}{$id}{timeout}=$loop->timer($timeout=>sub {$self->_error($id,'Request timeout')})}return$id}sub _url {shift->req->url->to_abs}sub _write {my ($self,$id)=@_;my$c=$self->{connections}{$id};return if!(my$tx=$c->{tx})|| $c->{writing}++;my$chunk=$tx->client_write;delete$c->{writing};warn term_escape "-- Client >>> Server (@{[_url($tx)]})\n$chunk\n" if DEBUG;my$stream=$c->{ioloop}->stream($id)->write($chunk);return if$chunk eq '';weaken$self;$stream->write(''=>sub {$self->_write($id)})}1;
MOJO_USERAGENT

$fatpacked{"Mojo/UserAgent/CookieJar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_COOKIEJAR';
  package Mojo::UserAgent::CookieJar;use Mojo::Base -base;use Mojo::Cookie::Request;use Mojo::Path;use Scalar::Util 'looks_like_number';has 'ignore';has max_cookie_size=>4096;sub add {my ($self,@cookies)=@_;my$size=$self->max_cookie_size;for my$cookie (@cookies){my$age=$cookie->max_age;$cookie->expires($age + time)if looks_like_number$age;next if length($cookie->value // '')> $size;my$origin=$cookie->origin // '';next unless my$domain=lc($cookie->domain // $origin);next unless my$path=$cookie->path;next if (my$name=$cookie->name // '')eq '';my$jar=$self->{jar}{$domain}||= [];@$jar=(grep({_compare($_,$path,$name,$origin)}@$jar),$cookie)}return$self}sub all {my$jar=shift->{jar};return [map {@{$jar->{$_}}}sort keys %$jar]}sub collect {my ($self,$tx)=@_;my$url=$tx->req->url;for my$cookie (@{$tx->res->cookies}){my$host=$url->ihost;my$domain=lc($cookie->domain // $cookie->origin($host)->origin);if (my$cb=$self->ignore){next if$cb->($cookie)}next if$host ne $domain && ($host !~ /\Q.$domain\E$/ || $host =~ /\.\d+$/);my$path=$cookie->path // $url->path->to_dir->to_abs_string;$path=Mojo::Path->new($path)->trailing_slash(0)->to_abs_string;next unless _path($path,$url->path->to_abs_string);$self->add($cookie->path($path))}}sub empty {delete shift->{jar}}sub find {my ($self,$url)=@_;my@found;return \@found unless my$domain=my$host=$url->ihost;my$path=$url->path->to_abs_string;while ($domain){next unless my$old=$self->{jar}{$domain};my$new=$self->{jar}{$domain}=[];for my$cookie (@$old){next unless$cookie->domain || $host eq $cookie->origin;if (my$expires=$cookie->expires){next if time > ($expires || 0)}push @$new,$cookie;next if$cookie->secure && $url->protocol ne 'https';next unless _path($cookie->path,$path);my$name=$cookie->name;my$value=$cookie->value;push@found,Mojo::Cookie::Request->new(name=>$name,value=>$value)}}continue {$domain =~ s/^[^.]*\.*//}return \@found}sub prepare {my ($self,$tx)=@_;return unless keys %{$self->{jar}};my$req=$tx->req;$req->cookies(@{$self->find($req->url)})}sub _compare {my ($cookie,$path,$name,$origin)=@_;return 1 if$cookie->path ne $path || $cookie->name ne $name;return ($cookie->origin // '')ne $origin}sub _path {$_[0]eq '/' || $_[0]eq $_[1]|| index($_[1],"$_[0]/")==0}1;
MOJO_USERAGENT_COOKIEJAR

$fatpacked{"Mojo/UserAgent/Proxy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_PROXY';
  package Mojo::UserAgent::Proxy;use Mojo::Base -base;use Mojo::URL;has [qw(http https not)];sub detect {my$self=shift;$self->http($ENV{HTTP_PROXY}|| $ENV{http_proxy});$self->https($ENV{HTTPS_PROXY}|| $ENV{https_proxy});return$self->not([split ',',$ENV{NO_PROXY}|| $ENV{no_proxy}|| ''])}sub is_needed {!grep {$_[1]=~ /\Q$_\E$/}@{$_[0]->not || []}}sub prepare {my ($self,$tx)=@_;$self->detect if$ENV{MOJO_PROXY};my$req=$tx->req;my$url=$req->url;return unless$req->via_proxy && $self->is_needed($url->host);my$proto=$url->protocol;my$http=$self->http;$req->proxy(Mojo::URL->new($http))if$http && $proto eq 'http';my$https=$self->https;$req->proxy(Mojo::URL->new($https))if$https && $proto eq 'https'}1;
MOJO_USERAGENT_PROXY

$fatpacked{"Mojo/UserAgent/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_SERVER';
  package Mojo::UserAgent::Server;use Mojo::Base -base;use Mojo::IOLoop;use Mojo::Server::Daemon;use Scalar::Util 'weaken';has ioloop=>sub {Mojo::IOLoop->singleton};sub app {my ($self,$app)=@_;state$singleton;return$singleton=$app ? $app : $singleton unless ref$self;return$self->{app}|| $singleton unless$app;$self->{app}=$app;return$self}sub nb_url {shift->_url(1,@_)}sub restart {shift->_restart(1)}sub url {shift->_url(0,@_)}sub _restart {my ($self,$full,$proto)=@_;delete @{$self}{qw(nb_port port)}if$full;$self->{proto}=$proto ||= 'http';my$server=$self->{server}=Mojo::Server::Daemon->new(ioloop=>$self->ioloop,silent=>1);weaken$server->app($self->app)->{app};my$port=$self->{port}? ":$self->{port}" : '';$self->{port}=$server->listen(["$proto://127.0.0.1$port"])->start->ioloop->acceptor($server->acceptors->[0])->port;$server=$self->{nb_server}=Mojo::Server::Daemon->new(silent=>1);weaken$server->app($self->app)->{app};$port=$self->{nb_port}? ":$self->{nb_port}" : '';$self->{nb_port}=$server->listen(["$proto://127.0.0.1$port"])->start->ioloop->acceptor($server->acceptors->[0])->port}sub _url {my ($self,$nb)=(shift,shift);$self->_restart(0,@_)if!$self->{server}|| @_;my$port=$nb ? $self->{nb_port}: $self->{port};return Mojo::URL->new("$self->{proto}://127.0.0.1:$port/")}1;
MOJO_USERAGENT_SERVER

$fatpacked{"Mojo/UserAgent/Transactor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_USERAGENT_TRANSACTOR';
  package Mojo::UserAgent::Transactor;use Mojo::Base -base;use File::Basename 'basename';use Mojo::Asset::File;use Mojo::Asset::Memory;use Mojo::Content::MultiPart;use Mojo::Content::Single;use Mojo::JSON 'encode_json';use Mojo::Parameters;use Mojo::Transaction::HTTP;use Mojo::Transaction::WebSocket;use Mojo::URL;use Mojo::Util qw(encode url_escape);use Mojo::WebSocket qw(challenge client_handshake);has generators=>sub {{form=>\&_form,json=>\&_json}};has name=>'Mojolicious (Perl)';sub add_generator {$_[0]->generators->{$_[1]}=$_[2]and return $_[0]}sub endpoint {my ($self,$tx)=@_;my$req=$tx->req;my$url=$req->url;my$proto=$url->protocol || 'http';my$host=$url->ihost;my$port=$url->port || ($proto eq 'https' ? 443 : 80);my$socks;if (my$proxy=$req->proxy){$socks=$proxy->protocol eq 'socks'}return$self->_proxy($tx,$proto,$host,$port)if$proto eq 'http' && $req->via_proxy &&!$req->is_handshake &&!$socks;return$proto,$host,$port}sub peer {$_[0]->_proxy($_[1],$_[0]->endpoint($_[1]))}sub proxy_connect {my ($self,$old)=@_;my$req=$old->req;return undef if uc$req->method eq 'CONNECT';return undef unless (my$proxy=$req->proxy)&& $req->via_proxy;return undef if$proxy->protocol eq 'socks';my$url=$req->url;return undef unless$req->is_handshake || $url->protocol eq 'https';my$new=$self->tx(CONNECT=>$url->clone->userinfo(undef));$new->req->proxy($proxy);$new->res->content->auto_relax(0)->headers->connection('keep-alive');return$new}sub redirect {my ($self,$old)=@_;my$res=$old->res;my$code=$res->code // 0;return undef unless grep {$_==$code}301,302,303,307,308;return undef unless my$location=$res->headers->location;$location=Mojo::URL->new($location);$location=$location->base($old->req->url)->to_abs unless$location->is_abs;my$proto=$location->protocol;return undef if ($proto ne 'http' && $proto ne 'https')||!$location->host;my$new=Mojo::Transaction::HTTP->new;my$req=$old->req;if ($code==307 || $code==308){return undef unless my$clone=$req->clone;$new->req($clone)}else {my$method=uc$req->method;my$headers=$new->req->method($method eq 'POST' ? 'GET' : $method)->content->headers($req->headers->clone)->headers;$headers->remove($_)for grep {/^content-/i}@{$headers->names}}my$headers=$new->req->url($location)->headers;$headers->remove($_)for qw(Authorization Cookie Host Referer);return$new->previous($old)}sub tx {my$self=shift;my$tx=Mojo::Transaction::HTTP->new;my$req=$tx->req->method(shift);my$url=shift;$url="http://$url" unless$url =~ m!^/|://!;ref$url ? $req->url($url): $req->url->parse($url);my$headers=$req->headers;$headers->from_hash(shift)if ref $_[0]eq 'HASH';$headers->user_agent($self->name)unless$headers->user_agent;$headers->accept_encoding('gzip')unless$headers->accept_encoding;if (@_ > 1){return$tx unless my$generator=$self->generators->{shift()};$self->$generator($tx,@_)}elsif (@_){$req->body(shift)}return$tx}sub upgrade {my ($self,$tx)=@_;my$code=$tx->res->code // 0;return undef unless$tx->req->is_handshake && $code==101;my$ws=Mojo::Transaction::WebSocket->new(handshake=>$tx,masked=>1);return challenge($ws)? $ws->established(1): undef}sub websocket {my$self=shift;my$sub=ref $_[-1]eq 'ARRAY' ? pop : [];my$tx=$self->tx(GET=>@_);my$req=$tx->req;$req->headers->sec_websocket_protocol(join ', ',@$sub)if @$sub;my$url=$req->url;my$proto=$url->protocol;$url->scheme($proto eq 'wss' ? 'https' : 'http')if$proto;return client_handshake$tx}sub _form {my ($self,$tx,$form,%options)=@_;$options{charset}='UTF-8' unless exists$options{charset};my$req=$tx->req;my$headers=$req->headers;my$multipart=($headers->content_type // '')=~ m!multipart/form-data!i;for my$value (map {ref $_ eq 'ARRAY' ? @$_ : $_}values %$form){++$multipart and last if ref$value eq 'HASH'}if ($multipart){my$parts=$self->_multipart($options{charset},$form);$req->content(Mojo::Content::MultiPart->new(headers=>$headers,parts=>$parts));_type($headers,'multipart/form-data');return$tx}my$method=uc$req->method;my@form=map {$_=>$form->{$_}}sort keys %$form;if ($method eq 'GET' || $method eq 'HEAD'){$req->url->query->merge(@form)}else {$req->body(Mojo::Parameters->new(@form)->charset($options{charset})->to_string);_type($headers,'application/x-www-form-urlencoded')}return$tx}sub _json {my ($self,$tx,$data)=@_;_type($tx->req->body(encode_json$data)->headers,'application/json');return$tx}sub _multipart {my ($self,$charset,$form)=@_;my@parts;for my$name (sort keys %$form){next unless defined(my$values=$form->{$name});for my$value (ref$values eq 'ARRAY' ? @$values : ($values)){push@parts,my$part=Mojo::Content::Single->new;my$filename;my$headers=$part->headers;if (ref$value eq 'HASH'){if (my$file=delete$value->{file}){$file=Mojo::Asset::File->new(path=>$file)unless ref$file;$part->asset($file);$value->{filename}//= basename$file->path if$file->isa('Mojo::Asset::File')}elsif (defined(my$content=delete$value->{content})){$part->asset(Mojo::Asset::Memory->new->add_chunk($content))}$filename=url_escape delete$value->{filename}// $name,'"';$filename=encode$charset,$filename if$charset;$headers->from_hash($value)}else {$value=encode$charset,$value if$charset;$part->asset(Mojo::Asset::Memory->new->add_chunk($value))}$name=url_escape$name,'"';$name=encode$charset,$name if$charset;my$disposition=qq{form-data; name="$name"};$disposition .= qq{; filename="$filename"} if defined$filename;$headers->content_disposition($disposition)}}return \@parts}sub _proxy {my ($self,$tx,$proto,$host,$port)=@_;if (my$proxy=$tx->req->proxy){$proto=$proxy->protocol;$host=$proxy->ihost;$port=$proxy->port || ($proto eq 'https' ? 443 : 80)}return$proto,$host,$port}sub _type {$_[0]->content_type($_[1])unless $_[0]->content_type}1;
MOJO_USERAGENT_TRANSACTOR

$fatpacked{"Mojo/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_UTIL';
  package Mojo::Util;use Mojo::Base -strict;use Carp qw(carp croak);use Data::Dumper ();use Digest::MD5 qw(md5 md5_hex);use Digest::SHA qw(hmac_sha1_hex sha1 sha1_hex);use Encode 'find_encoding';use Exporter 'import';use IO::Poll qw(POLLIN POLLPRI);use List::Util 'min';use MIME::Base64 qw(decode_base64 encode_base64);use Symbol 'delete_package';use Time::HiRes ();use constant MONOTONIC=>eval {!!Time::HiRes::clock_gettime(Time::HiRes::CLOCK_MONOTONIC())};use constant {PC_BASE=>36,PC_TMIN=>1,PC_TMAX=>26,PC_SKEW=>38,PC_DAMP=>700,PC_INITIAL_BIAS=>72,PC_INITIAL_N=>128 };my%ENTITIES;for my$line (split "\n",join('',<DATA>)){next unless$line =~ /^(\S+)\s+U\+(\S+)(?:\s+U\+(\S+))?/;$ENTITIES{$1}=defined $3 ? (chr(hex $2).chr(hex $3)): chr(hex $2)}my%XML=('&'=>'&amp;','<'=>'&lt;','>'=>'&gt;','"'=>'&quot;','\''=>'&#39;');my$EXPIRES_RE=qr/(\w+\W+\d+\W+\w+\W+\d+\W+\d+:\d+:\d+\W*\w+)/;my%CACHE;our@EXPORT_OK=(qw(b64_decode b64_encode camelize class_to_file class_to_path decamelize),qw(decode deprecated dumper encode hmac_sha1_sum html_unescape md5_bytes),qw(md5_sum monkey_patch punycode_decode punycode_encode quote),qw(secure_compare sha1_bytes sha1_sum slurp split_cookie_header),qw(split_header spurt squish steady_time tablify term_escape trim unindent),qw(unquote url_escape url_unescape xml_escape xor_encode xss_escape));sub b64_decode {decode_base64 $_[0]}sub b64_encode {encode_base64 $_[0],$_[1]}sub camelize {my$str=shift;return$str if$str =~ /^[A-Z]/;return join '::',map {join('',map {ucfirst lc}split '_')}split '-',$str}sub class_to_file {my$class=shift;$class =~ s/::|'//g;$class =~ s/([A-Z])([A-Z]*)/$1 . lc $2/ge;return decamelize($class)}sub class_to_path {join '.',join('/',split(/::|'/,shift)),'pm'}sub decamelize {my$str=shift;return$str if$str !~ /^[A-Z]/;return join '-',map {join('_',map {lc}grep {length}split /([A-Z]{1}[^A-Z]*)/)}split '::',$str}sub decode {my ($encoding,$bytes)=@_;return undef unless eval {$bytes=_encoding($encoding)->decode("$bytes",1);1};return$bytes}sub deprecated {local$Carp::CarpLevel=1;$ENV{MOJO_FATAL_DEPRECATIONS}? croak @_ : carp @_}sub dumper {Data::Dumper->new([@_])->Indent(1)->Sortkeys(1)->Terse(1)->Useqq(1)->Dump}sub encode {_encoding($_[0])->encode("$_[1]")}sub hmac_sha1_sum {hmac_sha1_hex @_}sub html_unescape {my$str=shift;$str =~ s/&(?:\#((?:[0-9]{1,7}|x[0-9a-fA-F]{1,6}));|(\w+;))/_decode($1, $2)/ge;return$str}sub md5_bytes {md5 @_}sub md5_sum {md5_hex @_}sub monkey_patch {Mojo::Base::_monkey_patch(@_)}sub punycode_decode {my$input=shift;use integer;my$n=PC_INITIAL_N;my$i=0;my$bias=PC_INITIAL_BIAS;my@output;push@output,split('',$1)if$input =~ s/(.*)\x2d//s;while ($input ne ''){my$oldi=$i;my$w=1;for (my$k=PC_BASE;1;$k += PC_BASE){my$digit=ord substr$input,0,1,'';$digit=$digit < 0x40 ? $digit + (26 - 0x30): ($digit & 0x1f)- 1;$i += $digit * $w;my$t=$k - $bias;$t=$t < PC_TMIN ? PC_TMIN : $t > PC_TMAX ? PC_TMAX : $t;last if$digit < $t;$w *= PC_BASE - $t}$bias=_adapt($i - $oldi,@output + 1,$oldi==0);$n += $i / (@output + 1);$i=$i % (@output + 1);splice@output,$i++,0,chr$n}return join '',@output}sub punycode_encode {my$output=shift;use integer;my$n=PC_INITIAL_N;my$delta=0;my$bias=PC_INITIAL_BIAS;my$len=length$output;my@input=map {ord}split '',$output;my@chars=sort grep {$_ >= PC_INITIAL_N}@input;$output =~ s/[^\x00-\x7f]+//gs;my$h=my$basic=length$output;$output .= "\x2d" if$basic > 0;for my$m (@chars){next if$m < $n;$delta += ($m - $n)* ($h + 1);$n=$m;for (my$i=0;$i < $len;$i++){my$c=$input[$i];if ($c < $n){$delta++}elsif ($c==$n){my$q=$delta;for (my$k=PC_BASE;1;$k += PC_BASE){my$t=$k - $bias;$t=$t < PC_TMIN ? PC_TMIN : $t > PC_TMAX ? PC_TMAX : $t;last if$q < $t;my$o=$t + (($q - $t)% (PC_BASE - $t));$output .= chr$o + ($o < 26 ? 0x61 : 0x30 - 26);$q=($q - $t)/ (PC_BASE - $t)}$output .= chr$q + ($q < 26 ? 0x61 : 0x30 - 26);$bias=_adapt($delta,$h + 1,$h==$basic);$delta=0;$h++}}$delta++;$n++}return$output}sub quote {my$str=shift;$str =~ s/(["\\])/\\$1/g;return qq{"$str"}}sub secure_compare {my ($one,$two)=@_;return undef if length$one!=length$two;my$r=0;$r |= ord(substr$one,$_)^ ord(substr$two,$_)for 0 .. length($one)- 1;return$r==0}sub sha1_bytes {sha1 @_}sub sha1_sum {sha1_hex @_}sub slurp {my$path=shift;open my$file,'<',$path or croak qq{Can't open file "$path": $!};my$ret=my$content='';while ($ret=$file->sysread(my$buffer,131072,0)){$content .= $buffer}croak qq{Can't read from file "$path": $!} unless defined$ret;return$content}sub split_cookie_header {_header(shift,1)}sub split_header {_header(shift,0)}sub spurt {my ($content,$path)=@_;open my$file,'>',$path or croak qq{Can't open file "$path": $!};defined$file->syswrite($content)or croak qq{Can't write to file "$path": $!};return$content}sub squish {my$str=trim(@_);$str =~ s/\s+/ /g;return$str}sub steady_time () {MONOTONIC ? Time::HiRes::clock_gettime(Time::HiRes::CLOCK_MONOTONIC()): Time::HiRes::time}sub tablify {my$rows=shift;my@spec;for my$row (@$rows){for my$i (0 .. $#$row){($row->[$i]//= '')=~ s/[\r\n]//g;my$len=length$row->[$i];$spec[$i]=$len if$len >= ($spec[$i]// 0)}}my$format=join '  ',map({"\%-${_}s"}@spec[0 .. $#spec - 1]),'%s';return join '',map {sprintf "$format\n",@$_}@$rows}sub term_escape {my$str=shift;$str =~ s/([\x00-\x09\x0b-\x1f\x7f\x80-\x9f])/sprintf '\\x%02x', ord $1/ge;return$str}sub trim {my$str=shift;$str =~ s/^\s+//;$str =~ s/\s+$//;return$str}sub unindent {my$str=shift;my$min=min map {m/^([ \t]*)/;length $1 || ()}split "\n",$str;$str =~ s/^[ \t]{0,$min}//gm if$min;return$str}sub unquote {my$str=shift;return$str unless$str =~ s/^"(.*)"$/$1/g;$str =~ s/\\\\/\\/g;$str =~ s/\\"/"/g;return$str}sub url_escape {my ($str,$pattern)=@_;if ($pattern){$str =~ s/([$pattern])/sprintf '%%%02X', ord $1/ge}else {$str =~ s/([^A-Za-z0-9\-._~])/sprintf '%%%02X', ord $1/ge}return$str}sub url_unescape {my$str=shift;$str =~ s/%([0-9a-fA-F]{2})/chr hex $1/ge;return$str}sub xml_escape {my$str=shift;$str =~ s/([&<>"'])/$XML{$1}/ge;return$str}sub xor_encode {my ($input,$key)=@_;my$len=length$key;my$buffer=my$output='';$output .= $buffer ^ $key while length($buffer=substr($input,0,$len,''))==$len;return$output .= $buffer ^ substr($key,0,length$buffer,'')}sub xss_escape {no warnings 'uninitialized';ref $_[0]eq 'Mojo::ByteStream' ? $_[0]: xml_escape("$_[0]")}sub _adapt {my ($delta,$numpoints,$firsttime)=@_;use integer;$delta=$firsttime ? $delta / PC_DAMP : $delta / 2;$delta += $delta / $numpoints;my$k=0;while ($delta > ((PC_BASE - PC_TMIN)* PC_TMAX)/ 2){$delta /= PC_BASE - PC_TMIN;$k += PC_BASE}return$k + (((PC_BASE - PC_TMIN + 1)* $delta)/ ($delta + PC_SKEW))}sub _decode {my ($point,$name)=@_;return chr($point !~ /^x/ ? $point : hex$point)unless defined$name;return exists$ENTITIES{$name}? $ENTITIES{$name}: "&$name"}sub _encoding {$CACHE{$_[0]}//= find_encoding($_[0])// croak "Unknown encoding '$_[0]'"}sub _global_destruction {defined ${^GLOBAL_PHASE} && ${^GLOBAL_PHASE} eq 'DESTRUCT'}sub _header {my ($str,$cookie)=@_;my (@tree,@part);while ($str =~ /\G[,;\s]*([^=;, ]+)\s*/gc){push@part,$1,undef;my$expires=$cookie && @part > 2 && lc $1 eq 'expires';if ($expires && $str =~ /\G=\s*$EXPIRES_RE/gco){$part[-1]=$1}elsif ($str =~ /\G=\s*("(?:\\\\|\\"|[^"])*")/gc){$part[-1]=unquote $1}elsif ($str =~ /\G=\s*([^;, ]*)/gc){$part[-1]=$1}next unless$str =~ /\G[;\s]*,\s*/gc;push@tree,[@part];@part=()}return [@part ? (@tree,\@part): @tree]}sub _options {return ref $_[0]eq 'HASH' ? (undef,%{shift()}): @_ if @_==1;return shift,@_ if @_ % 2;return ref $_[1]eq 'HASH' ? (shift,%{shift()}): (undef,@_)}sub _readable {!!(IO::Poll::_poll(@_[0,1],my$m=POLLIN | POLLPRI)> 0)}sub _stash {my ($name,$object)=(shift,shift);my$dict=$object->{$name}||= {};return$dict unless @_;return$dict->{$_[0]}unless @_ > 1 || ref $_[0];my$values=ref $_[0]? $_[0]: {@_};@$dict{keys %$values}=values %$values;return$object}sub _teardown {return unless my$class=shift;no strict 'refs';@{"${class}::ISA"}=();delete_package$class}1;__DATA__ Aacute; U+000C1
  aacute; U+000E1
  Abreve; U+00102
  abreve; U+00103
  ac; U+0223E
  acd; U+0223F
  acE; U+0223E U+00333
  Acirc; U+000C2
  acirc; U+000E2
  acute; U+000B4
  Acy; U+00410
  acy; U+00430
  AElig; U+000C6
  aelig; U+000E6
  af; U+02061
  Afr; U+1D504
  afr; U+1D51E
  Agrave; U+000C0
  agrave; U+000E0
  alefsym; U+02135
  aleph; U+02135
  Alpha; U+00391
  alpha; U+003B1
  Amacr; U+00100
  amacr; U+00101
  amalg; U+02A3F
  AMP; U+00026
  amp; U+00026
  And; U+02A53
  and; U+02227
  andand; U+02A55
  andd; U+02A5C
  andslope; U+02A58
  andv; U+02A5A
  ang; U+02220
  ange; U+029A4
  angle; U+02220
  angmsd; U+02221
  angmsdaa; U+029A8
  angmsdab; U+029A9
  angmsdac; U+029AA
  angmsdad; U+029AB
  angmsdae; U+029AC
  angmsdaf; U+029AD
  angmsdag; U+029AE
  angmsdah; U+029AF
  angrt; U+0221F
  angrtvb; U+022BE
  angrtvbd; U+0299D
  angsph; U+02222
  angst; U+000C5
  angzarr; U+0237C
  Aogon; U+00104
  aogon; U+00105
  Aopf; U+1D538
  aopf; U+1D552
  ap; U+02248
  apacir; U+02A6F
  apE; U+02A70
  ape; U+0224A
  apid; U+0224B
  apos; U+00027
  ApplyFunction; U+02061
  approx; U+02248
  approxeq; U+0224A
  Aring; U+000C5
  aring; U+000E5
  Ascr; U+1D49C
  ascr; U+1D4B6
  Assign; U+02254
  ast; U+0002A
  asymp; U+02248
  asympeq; U+0224D
  Atilde; U+000C3
  atilde; U+000E3
  Auml; U+000C4
  auml; U+000E4
  awconint; U+02233
  awint; U+02A11
  backcong; U+0224C
  backepsilon; U+003F6
  backprime; U+02035
  backsim; U+0223D
  backsimeq; U+022CD
  Backslash; U+02216
  Barv; U+02AE7
  barvee; U+022BD
  Barwed; U+02306
  barwed; U+02305
  barwedge; U+02305
  bbrk; U+023B5
  bbrktbrk; U+023B6
  bcong; U+0224C
  Bcy; U+00411
  bcy; U+00431
  bdquo; U+0201E
  becaus; U+02235
  Because; U+02235
  because; U+02235
  bemptyv; U+029B0
  bepsi; U+003F6
  bernou; U+0212C
  Bernoullis; U+0212C
  Beta; U+00392
  beta; U+003B2
  beth; U+02136
  between; U+0226C
  Bfr; U+1D505
  bfr; U+1D51F
  bigcap; U+022C2
  bigcirc; U+025EF
  bigcup; U+022C3
  bigodot; U+02A00
  bigoplus; U+02A01
  bigotimes; U+02A02
  bigsqcup; U+02A06
  bigstar; U+02605
  bigtriangledown; U+025BD
  bigtriangleup; U+025B3
  biguplus; U+02A04
  bigvee; U+022C1
  bigwedge; U+022C0
  bkarow; U+0290D
  blacklozenge; U+029EB
  blacksquare; U+025AA
  blacktriangle; U+025B4
  blacktriangledown; U+025BE
  blacktriangleleft; U+025C2
  blacktriangleright; U+025B8
  blank; U+02423
  blk12; U+02592
  blk14; U+02591
  blk34; U+02593
  block; U+02588
  bne; U+0003D U+020E5
  bnequiv; U+02261 U+020E5
  bNot; U+02AED
  bnot; U+02310
  Bopf; U+1D539
  bopf; U+1D553
  bot; U+022A5
  bottom; U+022A5
  bowtie; U+022C8
  boxbox; U+029C9
  boxDL; U+02557
  boxDl; U+02556
  boxdL; U+02555
  boxdl; U+02510
  boxDR; U+02554
  boxDr; U+02553
  boxdR; U+02552
  boxdr; U+0250C
  boxH; U+02550
  boxh; U+02500
  boxHD; U+02566
  boxHd; U+02564
  boxhD; U+02565
  boxhd; U+0252C
  boxHU; U+02569
  boxHu; U+02567
  boxhU; U+02568
  boxhu; U+02534
  boxminus; U+0229F
  boxplus; U+0229E
  boxtimes; U+022A0
  boxUL; U+0255D
  boxUl; U+0255C
  boxuL; U+0255B
  boxul; U+02518
  boxUR; U+0255A
  boxUr; U+02559
  boxuR; U+02558
  boxur; U+02514
  boxV; U+02551
  boxv; U+02502
  boxVH; U+0256C
  boxVh; U+0256B
  boxvH; U+0256A
  boxvh; U+0253C
  boxVL; U+02563
  boxVl; U+02562
  boxvL; U+02561
  boxvl; U+02524
  boxVR; U+02560
  boxVr; U+0255F
  boxvR; U+0255E
  boxvr; U+0251C
  bprime; U+02035
  Breve; U+002D8
  breve; U+002D8
  brvbar; U+000A6
  Bscr; U+0212C
  bscr; U+1D4B7
  bsemi; U+0204F
  bsim; U+0223D
  bsime; U+022CD
  bsol; U+0005C
  bsolb; U+029C5
  bsolhsub; U+027C8
  bull; U+02022
  bullet; U+02022
  bump; U+0224E
  bumpE; U+02AAE
  bumpe; U+0224F
  Bumpeq; U+0224E
  bumpeq; U+0224F
  Cacute; U+00106
  cacute; U+00107
  Cap; U+022D2
  cap; U+02229
  capand; U+02A44
  capbrcup; U+02A49
  capcap; U+02A4B
  capcup; U+02A47
  capdot; U+02A40
  CapitalDifferentialD; U+02145
  caps; U+02229 U+0FE00
  caret; U+02041
  caron; U+002C7
  Cayleys; U+0212D
  ccaps; U+02A4D
  Ccaron; U+0010C
  ccaron; U+0010D
  Ccedil; U+000C7
  ccedil; U+000E7
  Ccirc; U+00108
  ccirc; U+00109
  Cconint; U+02230
  ccups; U+02A4C
  ccupssm; U+02A50
  Cdot; U+0010A
  cdot; U+0010B
  cedil; U+000B8
  Cedilla; U+000B8
  cemptyv; U+029B2
  cent; U+000A2
  CenterDot; U+000B7
  centerdot; U+000B7
  Cfr; U+0212D
  cfr; U+1D520
  CHcy; U+00427
  chcy; U+00447
  check; U+02713
  checkmark; U+02713
  Chi; U+003A7
  chi; U+003C7
  cir; U+025CB
  circ; U+002C6
  circeq; U+02257
  circlearrowleft; U+021BA
  circlearrowright; U+021BB
  circledast; U+0229B
  circledcirc; U+0229A
  circleddash; U+0229D
  CircleDot; U+02299
  circledR; U+000AE
  circledS; U+024C8
  CircleMinus; U+02296
  CirclePlus; U+02295
  CircleTimes; U+02297
  cirE; U+029C3
  cire; U+02257
  cirfnint; U+02A10
  cirmid; U+02AEF
  cirscir; U+029C2
  ClockwiseContourIntegral; U+02232
  CloseCurlyDoubleQuote; U+0201D
  CloseCurlyQuote; U+02019
  clubs; U+02663
  clubsuit; U+02663
  Colon; U+02237
  colon; U+0003A
  Colone; U+02A74
  colone; U+02254
  coloneq; U+02254
  comma; U+0002C
  commat; U+00040
  comp; U+02201
  compfn; U+02218
  complement; U+02201
  complexes; U+02102
  cong; U+02245
  congdot; U+02A6D
  Congruent; U+02261
  Conint; U+0222F
  conint; U+0222E
  ContourIntegral; U+0222E
  Copf; U+02102
  copf; U+1D554
  coprod; U+02210
  Coproduct; U+02210
  COPY; U+000A9
  copy; U+000A9
  copysr; U+02117
  CounterClockwiseContourIntegral; U+02233
  crarr; U+021B5
  Cross; U+02A2F
  cross; U+02717
  Cscr; U+1D49E
  cscr; U+1D4B8
  csub; U+02ACF
  csube; U+02AD1
  csup; U+02AD0
  csupe; U+02AD2
  ctdot; U+022EF
  cudarrl; U+02938
  cudarrr; U+02935
  cuepr; U+022DE
  cuesc; U+022DF
  cularr; U+021B6
  cularrp; U+0293D
  Cup; U+022D3
  cup; U+0222A
  cupbrcap; U+02A48
  CupCap; U+0224D
  cupcap; U+02A46
  cupcup; U+02A4A
  cupdot; U+0228D
  cupor; U+02A45
  cups; U+0222A U+0FE00
  curarr; U+021B7
  curarrm; U+0293C
  curlyeqprec; U+022DE
  curlyeqsucc; U+022DF
  curlyvee; U+022CE
  curlywedge; U+022CF
  curren; U+000A4
  curvearrowleft; U+021B6
  curvearrowright; U+021B7
  cuvee; U+022CE
  cuwed; U+022CF
  cwconint; U+02232
  cwint; U+02231
  cylcty; U+0232D
  Dagger; U+02021
  dagger; U+02020
  daleth; U+02138
  Darr; U+021A1
  dArr; U+021D3
  darr; U+02193
  dash; U+02010
  Dashv; U+02AE4
  dashv; U+022A3
  dbkarow; U+0290F
  dblac; U+002DD
  Dcaron; U+0010E
  dcaron; U+0010F
  Dcy; U+00414
  dcy; U+00434
  DD; U+02145
  dd; U+02146
  ddagger; U+02021
  ddarr; U+021CA
  DDotrahd; U+02911
  ddotseq; U+02A77
  deg; U+000B0
  Del; U+02207
  Delta; U+00394
  delta; U+003B4
  demptyv; U+029B1
  dfisht; U+0297F
  Dfr; U+1D507
  dfr; U+1D521
  dHar; U+02965
  dharl; U+021C3
  dharr; U+021C2
  DiacriticalAcute; U+000B4
  DiacriticalDot; U+002D9
  DiacriticalDoubleAcute; U+002DD
  DiacriticalGrave; U+00060
  DiacriticalTilde; U+002DC
  diam; U+022C4
  Diamond; U+022C4
  diamond; U+022C4
  diamondsuit; U+02666
  diams; U+02666
  die; U+000A8
  DifferentialD; U+02146
  digamma; U+003DD
  disin; U+022F2
  div; U+000F7
  divide; U+000F7
  divideontimes; U+022C7
  divonx; U+022C7
  DJcy; U+00402
  djcy; U+00452
  dlcorn; U+0231E
  dlcrop; U+0230D
  dollar; U+00024
  Dopf; U+1D53B
  dopf; U+1D555
  Dot; U+000A8
  dot; U+002D9
  DotDot; U+020DC
  doteq; U+02250
  doteqdot; U+02251
  DotEqual; U+02250
  dotminus; U+02238
  dotplus; U+02214
  dotsquare; U+022A1
  doublebarwedge; U+02306
  DoubleContourIntegral; U+0222F
  DoubleDot; U+000A8
  DoubleDownArrow; U+021D3
  DoubleLeftArrow; U+021D0
  DoubleLeftRightArrow; U+021D4
  DoubleLeftTee; U+02AE4
  DoubleLongLeftArrow; U+027F8
  DoubleLongLeftRightArrow; U+027FA
  DoubleLongRightArrow; U+027F9
  DoubleRightArrow; U+021D2
  DoubleRightTee; U+022A8
  DoubleUpArrow; U+021D1
  DoubleUpDownArrow; U+021D5
  DoubleVerticalBar; U+02225
  DownArrow; U+02193
  Downarrow; U+021D3
  downarrow; U+02193
  DownArrowBar; U+02913
  DownArrowUpArrow; U+021F5
  DownBreve; U+00311
  downdownarrows; U+021CA
  downharpoonleft; U+021C3
  downharpoonright; U+021C2
  DownLeftRightVector; U+02950
  DownLeftTeeVector; U+0295E
  DownLeftVector; U+021BD
  DownLeftVectorBar; U+02956
  DownRightTeeVector; U+0295F
  DownRightVector; U+021C1
  DownRightVectorBar; U+02957
  DownTee; U+022A4
  DownTeeArrow; U+021A7
  drbkarow; U+02910
  drcorn; U+0231F
  drcrop; U+0230C
  Dscr; U+1D49F
  dscr; U+1D4B9
  DScy; U+00405
  dscy; U+00455
  dsol; U+029F6
  Dstrok; U+00110
  dstrok; U+00111
  dtdot; U+022F1
  dtri; U+025BF
  dtrif; U+025BE
  duarr; U+021F5
  duhar; U+0296F
  dwangle; U+029A6
  DZcy; U+0040F
  dzcy; U+0045F
  dzigrarr; U+027FF
  Eacute; U+000C9
  eacute; U+000E9
  easter; U+02A6E
  Ecaron; U+0011A
  ecaron; U+0011B
  ecir; U+02256
  Ecirc; U+000CA
  ecirc; U+000EA
  ecolon; U+02255
  Ecy; U+0042D
  ecy; U+0044D
  eDDot; U+02A77
  Edot; U+00116
  eDot; U+02251
  edot; U+00117
  ee; U+02147
  efDot; U+02252
  Efr; U+1D508
  efr; U+1D522
  eg; U+02A9A
  Egrave; U+000C8
  egrave; U+000E8
  egs; U+02A96
  egsdot; U+02A98
  el; U+02A99
  Element; U+02208
  elinters; U+023E7
  ell; U+02113
  els; U+02A95
  elsdot; U+02A97
  Emacr; U+00112
  emacr; U+00113
  empty; U+02205
  emptyset; U+02205
  EmptySmallSquare; U+025FB
  emptyv; U+02205
  EmptyVerySmallSquare; U+025AB
  emsp; U+02003
  emsp13; U+02004
  emsp14; U+02005
  ENG; U+0014A
  eng; U+0014B
  ensp; U+02002
  Eogon; U+00118
  eogon; U+00119
  Eopf; U+1D53C
  eopf; U+1D556
  epar; U+022D5
  eparsl; U+029E3
  eplus; U+02A71
  epsi; U+003B5
  Epsilon; U+00395
  epsilon; U+003B5
  epsiv; U+003F5
  eqcirc; U+02256
  eqcolon; U+02255
  eqsim; U+02242
  eqslantgtr; U+02A96
  eqslantless; U+02A95
  Equal; U+02A75
  equals; U+0003D
  EqualTilde; U+02242
  equest; U+0225F
  Equilibrium; U+021CC
  equiv; U+02261
  equivDD; U+02A78
  eqvparsl; U+029E5
  erarr; U+02971
  erDot; U+02253
  Escr; U+02130
  escr; U+0212F
  esdot; U+02250
  Esim; U+02A73
  esim; U+02242
  Eta; U+00397
  eta; U+003B7
  ETH; U+000D0
  eth; U+000F0
  Euml; U+000CB
  euml; U+000EB
  euro; U+020AC
  excl; U+00021
  exist; U+02203
  Exists; U+02203
  expectation; U+02130
  ExponentialE; U+02147
  exponentiale; U+02147
  fallingdotseq; U+02252
  Fcy; U+00424
  fcy; U+00444
  female; U+02640
  ffilig; U+0FB03
  fflig; U+0FB00
  ffllig; U+0FB04
  Ffr; U+1D509
  ffr; U+1D523
  filig; U+0FB01
  FilledSmallSquare; U+025FC
  FilledVerySmallSquare; U+025AA
  fjlig; U+00066 U+0006A
  flat; U+0266D
  fllig; U+0FB02
  fltns; U+025B1
  fnof; U+00192
  Fopf; U+1D53D
  fopf; U+1D557
  ForAll; U+02200
  forall; U+02200
  fork; U+022D4
  forkv; U+02AD9
  Fouriertrf; U+02131
  fpartint; U+02A0D
  frac12; U+000BD
  frac13; U+02153
  frac14; U+000BC
  frac15; U+02155
  frac16; U+02159
  frac18; U+0215B
  frac23; U+02154
  frac25; U+02156
  frac34; U+000BE
  frac35; U+02157
  frac38; U+0215C
  frac45; U+02158
  frac56; U+0215A
  frac58; U+0215D
  frac78; U+0215E
  frasl; U+02044
  frown; U+02322
  Fscr; U+02131
  fscr; U+1D4BB
  gacute; U+001F5
  Gamma; U+00393
  gamma; U+003B3
  Gammad; U+003DC
  gammad; U+003DD
  gap; U+02A86
  Gbreve; U+0011E
  gbreve; U+0011F
  Gcedil; U+00122
  Gcirc; U+0011C
  gcirc; U+0011D
  Gcy; U+00413
  gcy; U+00433
  Gdot; U+00120
  gdot; U+00121
  gE; U+02267
  ge; U+02265
  gEl; U+02A8C
  gel; U+022DB
  geq; U+02265
  geqq; U+02267
  geqslant; U+02A7E
  ges; U+02A7E
  gescc; U+02AA9
  gesdot; U+02A80
  gesdoto; U+02A82
  gesdotol; U+02A84
  gesl; U+022DB U+0FE00
  gesles; U+02A94
  Gfr; U+1D50A
  gfr; U+1D524
  Gg; U+022D9
  gg; U+0226B
  ggg; U+022D9
  gimel; U+02137
  GJcy; U+00403
  gjcy; U+00453
  gl; U+02277
  gla; U+02AA5
  glE; U+02A92
  glj; U+02AA4
  gnap; U+02A8A
  gnapprox; U+02A8A
  gnE; U+02269
  gne; U+02A88
  gneq; U+02A88
  gneqq; U+02269
  gnsim; U+022E7
  Gopf; U+1D53E
  gopf; U+1D558
  grave; U+00060
  GreaterEqual; U+02265
  GreaterEqualLess; U+022DB
  GreaterFullEqual; U+02267
  GreaterGreater; U+02AA2
  GreaterLess; U+02277
  GreaterSlantEqual; U+02A7E
  GreaterTilde; U+02273
  Gscr; U+1D4A2
  gscr; U+0210A
  gsim; U+02273
  gsime; U+02A8E
  gsiml; U+02A90
  GT; U+0003E
  Gt; U+0226B
  gt; U+0003E
  gtcc; U+02AA7
  gtcir; U+02A7A
  gtdot; U+022D7
  gtlPar; U+02995
  gtquest; U+02A7C
  gtrapprox; U+02A86
  gtrarr; U+02978
  gtrdot; U+022D7
  gtreqless; U+022DB
  gtreqqless; U+02A8C
  gtrless; U+02277
  gtrsim; U+02273
  gvertneqq; U+02269 U+0FE00
  gvnE; U+02269 U+0FE00
  Hacek; U+002C7
  hairsp; U+0200A
  half; U+000BD
  hamilt; U+0210B
  HARDcy; U+0042A
  hardcy; U+0044A
  hArr; U+021D4
  harr; U+02194
  harrcir; U+02948
  harrw; U+021AD
  Hat; U+0005E
  hbar; U+0210F
  Hcirc; U+00124
  hcirc; U+00125
  hearts; U+02665
  heartsuit; U+02665
  hellip; U+02026
  hercon; U+022B9
  Hfr; U+0210C
  hfr; U+1D525
  HilbertSpace; U+0210B
  hksearow; U+02925
  hkswarow; U+02926
  hoarr; U+021FF
  homtht; U+0223B
  hookleftarrow; U+021A9
  hookrightarrow; U+021AA
  Hopf; U+0210D
  hopf; U+1D559
  horbar; U+02015
  HorizontalLine; U+02500
  Hscr; U+0210B
  hscr; U+1D4BD
  hslash; U+0210F
  Hstrok; U+00126
  hstrok; U+00127
  HumpDownHump; U+0224E
  HumpEqual; U+0224F
  hybull; U+02043
  hyphen; U+02010
  Iacute; U+000CD
  iacute; U+000ED
  ic; U+02063
  Icirc; U+000CE
  icirc; U+000EE
  Icy; U+00418
  icy; U+00438
  Idot; U+00130
  IEcy; U+00415
  iecy; U+00435
  iexcl; U+000A1
  iff; U+021D4
  Ifr; U+02111
  ifr; U+1D526
  Igrave; U+000CC
  igrave; U+000EC
  ii; U+02148
  iiiint; U+02A0C
  iiint; U+0222D
  iinfin; U+029DC
  iiota; U+02129
  IJlig; U+00132
  ijlig; U+00133
  Im; U+02111
  Imacr; U+0012A
  imacr; U+0012B
  image; U+02111
  ImaginaryI; U+02148
  imagline; U+02110
  imagpart; U+02111
  imath; U+00131
  imof; U+022B7
  imped; U+001B5
  Implies; U+021D2
  in; U+02208
  incare; U+02105
  infin; U+0221E
  infintie; U+029DD
  inodot; U+00131
  Int; U+0222C
  int; U+0222B
  intcal; U+022BA
  integers; U+02124
  Integral; U+0222B
  intercal; U+022BA
  Intersection; U+022C2
  intlarhk; U+02A17
  intprod; U+02A3C
  InvisibleComma; U+02063
  InvisibleTimes; U+02062
  IOcy; U+00401
  iocy; U+00451
  Iogon; U+0012E
  iogon; U+0012F
  Iopf; U+1D540
  iopf; U+1D55A
  Iota; U+00399
  iota; U+003B9
  iprod; U+02A3C
  iquest; U+000BF
  Iscr; U+02110
  iscr; U+1D4BE
  isin; U+02208
  isindot; U+022F5
  isinE; U+022F9
  isins; U+022F4
  isinsv; U+022F3
  isinv; U+02208
  it; U+02062
  Itilde; U+00128
  itilde; U+00129
  Iukcy; U+00406
  iukcy; U+00456
  Iuml; U+000CF
  iuml; U+000EF
  Jcirc; U+00134
  jcirc; U+00135
  Jcy; U+00419
  jcy; U+00439
  Jfr; U+1D50D
  jfr; U+1D527
  jmath; U+00237
  Jopf; U+1D541
  jopf; U+1D55B
  Jscr; U+1D4A5
  jscr; U+1D4BF
  Jsercy; U+00408
  jsercy; U+00458
  Jukcy; U+00404
  jukcy; U+00454
  Kappa; U+0039A
  kappa; U+003BA
  kappav; U+003F0
  Kcedil; U+00136
  kcedil; U+00137
  Kcy; U+0041A
  kcy; U+0043A
  Kfr; U+1D50E
  kfr; U+1D528
  kgreen; U+00138
  KHcy; U+00425
  khcy; U+00445
  KJcy; U+0040C
  kjcy; U+0045C
  Kopf; U+1D542
  kopf; U+1D55C
  Kscr; U+1D4A6
  kscr; U+1D4C0
  lAarr; U+021DA
  Lacute; U+00139
  lacute; U+0013A
  laemptyv; U+029B4
  lagran; U+02112
  Lambda; U+0039B
  lambda; U+003BB
  Lang; U+027EA
  lang; U+027E8
  langd; U+02991
  langle; U+027E8
  lap; U+02A85
  Laplacetrf; U+02112
  laquo; U+000AB
  Larr; U+0219E
  lArr; U+021D0
  larr; U+02190
  larrb; U+021E4
  larrbfs; U+0291F
  larrfs; U+0291D
  larrhk; U+021A9
  larrlp; U+021AB
  larrpl; U+02939
  larrsim; U+02973
  larrtl; U+021A2
  lat; U+02AAB
  lAtail; U+0291B
  latail; U+02919
  late; U+02AAD
  lates; U+02AAD U+0FE00
  lBarr; U+0290E
  lbarr; U+0290C
  lbbrk; U+02772
  lbrace; U+0007B
  lbrack; U+0005B
  lbrke; U+0298B
  lbrksld; U+0298F
  lbrkslu; U+0298D
  Lcaron; U+0013D
  lcaron; U+0013E
  Lcedil; U+0013B
  lcedil; U+0013C
  lceil; U+02308
  lcub; U+0007B
  Lcy; U+0041B
  lcy; U+0043B
  ldca; U+02936
  ldquo; U+0201C
  ldquor; U+0201E
  ldrdhar; U+02967
  ldrushar; U+0294B
  ldsh; U+021B2
  lE; U+02266
  le; U+02264
  LeftAngleBracket; U+027E8
  LeftArrow; U+02190
  Leftarrow; U+021D0
  leftarrow; U+02190
  LeftArrowBar; U+021E4
  LeftArrowRightArrow; U+021C6
  leftarrowtail; U+021A2
  LeftCeiling; U+02308
  LeftDoubleBracket; U+027E6
  LeftDownTeeVector; U+02961
  LeftDownVector; U+021C3
  LeftDownVectorBar; U+02959
  LeftFloor; U+0230A
  leftharpoondown; U+021BD
  leftharpoonup; U+021BC
  leftleftarrows; U+021C7
  LeftRightArrow; U+02194
  Leftrightarrow; U+021D4
  leftrightarrow; U+02194
  leftrightarrows; U+021C6
  leftrightharpoons; U+021CB
  leftrightsquigarrow; U+021AD
  LeftRightVector; U+0294E
  LeftTee; U+022A3
  LeftTeeArrow; U+021A4
  LeftTeeVector; U+0295A
  leftthreetimes; U+022CB
  LeftTriangle; U+022B2
  LeftTriangleBar; U+029CF
  LeftTriangleEqual; U+022B4
  LeftUpDownVector; U+02951
  LeftUpTeeVector; U+02960
  LeftUpVector; U+021BF
  LeftUpVectorBar; U+02958
  LeftVector; U+021BC
  LeftVectorBar; U+02952
  lEg; U+02A8B
  leg; U+022DA
  leq; U+02264
  leqq; U+02266
  leqslant; U+02A7D
  les; U+02A7D
  lescc; U+02AA8
  lesdot; U+02A7F
  lesdoto; U+02A81
  lesdotor; U+02A83
  lesg; U+022DA U+0FE00
  lesges; U+02A93
  lessapprox; U+02A85
  lessdot; U+022D6
  lesseqgtr; U+022DA
  lesseqqgtr; U+02A8B
  LessEqualGreater; U+022DA
  LessFullEqual; U+02266
  LessGreater; U+02276
  lessgtr; U+02276
  LessLess; U+02AA1
  lesssim; U+02272
  LessSlantEqual; U+02A7D
  LessTilde; U+02272
  lfisht; U+0297C
  lfloor; U+0230A
  Lfr; U+1D50F
  lfr; U+1D529
  lg; U+02276
  lgE; U+02A91
  lHar; U+02962
  lhard; U+021BD
  lharu; U+021BC
  lharul; U+0296A
  lhblk; U+02584
  LJcy; U+00409
  ljcy; U+00459
  Ll; U+022D8
  ll; U+0226A
  llarr; U+021C7
  llcorner; U+0231E
  Lleftarrow; U+021DA
  llhard; U+0296B
  lltri; U+025FA
  Lmidot; U+0013F
  lmidot; U+00140
  lmoust; U+023B0
  lmoustache; U+023B0
  lnap; U+02A89
  lnapprox; U+02A89
  lnE; U+02268
  lne; U+02A87
  lneq; U+02A87
  lneqq; U+02268
  lnsim; U+022E6
  loang; U+027EC
  loarr; U+021FD
  lobrk; U+027E6
  LongLeftArrow; U+027F5
  Longleftarrow; U+027F8
  longleftarrow; U+027F5
  LongLeftRightArrow; U+027F7
  Longleftrightarrow; U+027FA
  longleftrightarrow; U+027F7
  longmapsto; U+027FC
  LongRightArrow; U+027F6
  Longrightarrow; U+027F9
  longrightarrow; U+027F6
  looparrowleft; U+021AB
  looparrowright; U+021AC
  lopar; U+02985
  Lopf; U+1D543
  lopf; U+1D55D
  loplus; U+02A2D
  lotimes; U+02A34
  lowast; U+02217
  lowbar; U+0005F
  LowerLeftArrow; U+02199
  LowerRightArrow; U+02198
  loz; U+025CA
  lozenge; U+025CA
  lozf; U+029EB
  lpar; U+00028
  lparlt; U+02993
  lrarr; U+021C6
  lrcorner; U+0231F
  lrhar; U+021CB
  lrhard; U+0296D
  lrm; U+0200E
  lrtri; U+022BF
  lsaquo; U+02039
  Lscr; U+02112
  lscr; U+1D4C1
  Lsh; U+021B0
  lsh; U+021B0
  lsim; U+02272
  lsime; U+02A8D
  lsimg; U+02A8F
  lsqb; U+0005B
  lsquo; U+02018
  lsquor; U+0201A
  Lstrok; U+00141
  lstrok; U+00142
  LT; U+0003C
  Lt; U+0226A
  lt; U+0003C
  ltcc; U+02AA6
  ltcir; U+02A79
  ltdot; U+022D6
  lthree; U+022CB
  ltimes; U+022C9
  ltlarr; U+02976
  ltquest; U+02A7B
  ltri; U+025C3
  ltrie; U+022B4
  ltrif; U+025C2
  ltrPar; U+02996
  lurdshar; U+0294A
  luruhar; U+02966
  lvertneqq; U+02268 U+0FE00
  lvnE; U+02268 U+0FE00
  macr; U+000AF
  male; U+02642
  malt; U+02720
  maltese; U+02720
  Map; U+02905
  map; U+021A6
  mapsto; U+021A6
  mapstodown; U+021A7
  mapstoleft; U+021A4
  mapstoup; U+021A5
  marker; U+025AE
  mcomma; U+02A29
  Mcy; U+0041C
  mcy; U+0043C
  mdash; U+02014
  mDDot; U+0223A
  measuredangle; U+02221
  MediumSpace; U+0205F
  Mellintrf; U+02133
  Mfr; U+1D510
  mfr; U+1D52A
  mho; U+02127
  micro; U+000B5
  mid; U+02223
  midast; U+0002A
  midcir; U+02AF0
  middot; U+000B7
  minus; U+02212
  minusb; U+0229F
  minusd; U+02238
  minusdu; U+02A2A
  MinusPlus; U+02213
  mlcp; U+02ADB
  mldr; U+02026
  mnplus; U+02213
  models; U+022A7
  Mopf; U+1D544
  mopf; U+1D55E
  mp; U+02213
  Mscr; U+02133
  mscr; U+1D4C2
  mstpos; U+0223E
  Mu; U+0039C
  mu; U+003BC
  multimap; U+022B8
  mumap; U+022B8
  nabla; U+02207
  Nacute; U+00143
  nacute; U+00144
  nang; U+02220 U+020D2
  nap; U+02249
  napE; U+02A70 U+00338
  napid; U+0224B U+00338
  napos; U+00149
  napprox; U+02249
  natur; U+0266E
  natural; U+0266E
  naturals; U+02115
  nbsp; U+000A0
  nbump; U+0224E U+00338
  nbumpe; U+0224F U+00338
  ncap; U+02A43
  Ncaron; U+00147
  ncaron; U+00148
  Ncedil; U+00145
  ncedil; U+00146
  ncong; U+02247
  ncongdot; U+02A6D U+00338
  ncup; U+02A42
  Ncy; U+0041D
  ncy; U+0043D
  ndash; U+02013
  ne; U+02260
  nearhk; U+02924
  neArr; U+021D7
  nearr; U+02197
  nearrow; U+02197
  nedot; U+02250 U+00338
  NegativeMediumSpace; U+0200B
  NegativeThickSpace; U+0200B
  NegativeThinSpace; U+0200B
  NegativeVeryThinSpace; U+0200B
  nequiv; U+02262
  nesear; U+02928
  nesim; U+02242 U+00338
  NestedGreaterGreater; U+0226B
  NestedLessLess; U+0226A
  NewLine; U+0000A
  nexist; U+02204
  nexists; U+02204
  Nfr; U+1D511
  nfr; U+1D52B
  ngE; U+02267 U+00338
  nge; U+02271
  ngeq; U+02271
  ngeqq; U+02267 U+00338
  ngeqslant; U+02A7E U+00338
  nges; U+02A7E U+00338
  nGg; U+022D9 U+00338
  ngsim; U+02275
  nGt; U+0226B U+020D2
  ngt; U+0226F
  ngtr; U+0226F
  nGtv; U+0226B U+00338
  nhArr; U+021CE
  nharr; U+021AE
  nhpar; U+02AF2
  ni; U+0220B
  nis; U+022FC
  nisd; U+022FA
  niv; U+0220B
  NJcy; U+0040A
  njcy; U+0045A
  nlArr; U+021CD
  nlarr; U+0219A
  nldr; U+02025
  nlE; U+02266 U+00338
  nle; U+02270
  nLeftarrow; U+021CD
  nleftarrow; U+0219A
  nLeftrightarrow; U+021CE
  nleftrightarrow; U+021AE
  nleq; U+02270
  nleqq; U+02266 U+00338
  nleqslant; U+02A7D U+00338
  nles; U+02A7D U+00338
  nless; U+0226E
  nLl; U+022D8 U+00338
  nlsim; U+02274
  nLt; U+0226A U+020D2
  nlt; U+0226E
  nltri; U+022EA
  nltrie; U+022EC
  nLtv; U+0226A U+00338
  nmid; U+02224
  NoBreak; U+02060
  NonBreakingSpace; U+000A0
  Nopf; U+02115
  nopf; U+1D55F
  Not; U+02AEC
  not; U+000AC
  NotCongruent; U+02262
  NotCupCap; U+0226D
  NotDoubleVerticalBar; U+02226
  NotElement; U+02209
  NotEqual; U+02260
  NotEqualTilde; U+02242 U+00338
  NotExists; U+02204
  NotGreater; U+0226F
  NotGreaterEqual; U+02271
  NotGreaterFullEqual; U+02267 U+00338
  NotGreaterGreater; U+0226B U+00338
  NotGreaterLess; U+02279
  NotGreaterSlantEqual; U+02A7E U+00338
  NotGreaterTilde; U+02275
  NotHumpDownHump; U+0224E U+00338
  NotHumpEqual; U+0224F U+00338
  notin; U+02209
  notindot; U+022F5 U+00338
  notinE; U+022F9 U+00338
  notinva; U+02209
  notinvb; U+022F7
  notinvc; U+022F6
  NotLeftTriangle; U+022EA
  NotLeftTriangleBar; U+029CF U+00338
  NotLeftTriangleEqual; U+022EC
  NotLess; U+0226E
  NotLessEqual; U+02270
  NotLessGreater; U+02278
  NotLessLess; U+0226A U+00338
  NotLessSlantEqual; U+02A7D U+00338
  NotLessTilde; U+02274
  NotNestedGreaterGreater; U+02AA2 U+00338
  NotNestedLessLess; U+02AA1 U+00338
  notni; U+0220C
  notniva; U+0220C
  notnivb; U+022FE
  notnivc; U+022FD
  NotPrecedes; U+02280
  NotPrecedesEqual; U+02AAF U+00338
  NotPrecedesSlantEqual; U+022E0
  NotReverseElement; U+0220C
  NotRightTriangle; U+022EB
  NotRightTriangleBar; U+029D0 U+00338
  NotRightTriangleEqual; U+022ED
  NotSquareSubset; U+0228F U+00338
  NotSquareSubsetEqual; U+022E2
  NotSquareSuperset; U+02290 U+00338
  NotSquareSupersetEqual; U+022E3
  NotSubset; U+02282 U+020D2
  NotSubsetEqual; U+02288
  NotSucceeds; U+02281
  NotSucceedsEqual; U+02AB0 U+00338
  NotSucceedsSlantEqual; U+022E1
  NotSucceedsTilde; U+0227F U+00338
  NotSuperset; U+02283 U+020D2
  NotSupersetEqual; U+02289
  NotTilde; U+02241
  NotTildeEqual; U+02244
  NotTildeFullEqual; U+02247
  NotTildeTilde; U+02249
  NotVerticalBar; U+02224
  npar; U+02226
  nparallel; U+02226
  nparsl; U+02AFD U+020E5
  npart; U+02202 U+00338
  npolint; U+02A14
  npr; U+02280
  nprcue; U+022E0
  npre; U+02AAF U+00338
  nprec; U+02280
  npreceq; U+02AAF U+00338
  nrArr; U+021CF
  nrarr; U+0219B
  nrarrc; U+02933 U+00338
  nrarrw; U+0219D U+00338
  nRightarrow; U+021CF
  nrightarrow; U+0219B
  nrtri; U+022EB
  nrtrie; U+022ED
  nsc; U+02281
  nsccue; U+022E1
  nsce; U+02AB0 U+00338
  Nscr; U+1D4A9
  nscr; U+1D4C3
  nshortmid; U+02224
  nshortparallel; U+02226
  nsim; U+02241
  nsime; U+02244
  nsimeq; U+02244
  nsmid; U+02224
  nspar; U+02226
  nsqsube; U+022E2
  nsqsupe; U+022E3
  nsub; U+02284
  nsubE; U+02AC5 U+00338
  nsube; U+02288
  nsubset; U+02282 U+020D2
  nsubseteq; U+02288
  nsubseteqq; U+02AC5 U+00338
  nsucc; U+02281
  nsucceq; U+02AB0 U+00338
  nsup; U+02285
  nsupE; U+02AC6 U+00338
  nsupe; U+02289
  nsupset; U+02283 U+020D2
  nsupseteq; U+02289
  nsupseteqq; U+02AC6 U+00338
  ntgl; U+02279
  Ntilde; U+000D1
  ntilde; U+000F1
  ntlg; U+02278
  ntriangleleft; U+022EA
  ntrianglelefteq; U+022EC
  ntriangleright; U+022EB
  ntrianglerighteq; U+022ED
  Nu; U+0039D
  nu; U+003BD
  num; U+00023
  numero; U+02116
  numsp; U+02007
  nvap; U+0224D U+020D2
  nVDash; U+022AF
  nVdash; U+022AE
  nvDash; U+022AD
  nvdash; U+022AC
  nvge; U+02265 U+020D2
  nvgt; U+0003E U+020D2
  nvHarr; U+02904
  nvinfin; U+029DE
  nvlArr; U+02902
  nvle; U+02264 U+020D2
  nvlt; U+0003C U+020D2
  nvltrie; U+022B4 U+020D2
  nvrArr; U+02903
  nvrtrie; U+022B5 U+020D2
  nvsim; U+0223C U+020D2
  nwarhk; U+02923
  nwArr; U+021D6
  nwarr; U+02196
  nwarrow; U+02196
  nwnear; U+02927
  Oacute; U+000D3
  oacute; U+000F3
  oast; U+0229B
  ocir; U+0229A
  Ocirc; U+000D4
  ocirc; U+000F4
  Ocy; U+0041E
  ocy; U+0043E
  odash; U+0229D
  Odblac; U+00150
  odblac; U+00151
  odiv; U+02A38
  odot; U+02299
  odsold; U+029BC
  OElig; U+00152
  oelig; U+00153
  ofcir; U+029BF
  Ofr; U+1D512
  ofr; U+1D52C
  ogon; U+002DB
  Ograve; U+000D2
  ograve; U+000F2
  ogt; U+029C1
  ohbar; U+029B5
  ohm; U+003A9
  oint; U+0222E
  olarr; U+021BA
  olcir; U+029BE
  olcross; U+029BB
  oline; U+0203E
  olt; U+029C0
  Omacr; U+0014C
  omacr; U+0014D
  Omega; U+003A9
  omega; U+003C9
  Omicron; U+0039F
  omicron; U+003BF
  omid; U+029B6
  ominus; U+02296
  Oopf; U+1D546
  oopf; U+1D560
  opar; U+029B7
  OpenCurlyDoubleQuote; U+0201C
  OpenCurlyQuote; U+02018
  operp; U+029B9
  oplus; U+02295
  Or; U+02A54
  or; U+02228
  orarr; U+021BB
  ord; U+02A5D
  order; U+02134
  orderof; U+02134
  ordf; U+000AA
  ordm; U+000BA
  origof; U+022B6
  oror; U+02A56
  orslope; U+02A57
  orv; U+02A5B
  oS; U+024C8
  Oscr; U+1D4AA
  oscr; U+02134
  Oslash; U+000D8
  oslash; U+000F8
  osol; U+02298
  Otilde; U+000D5
  otilde; U+000F5
  Otimes; U+02A37
  otimes; U+02297
  otimesas; U+02A36
  Ouml; U+000D6
  ouml; U+000F6
  ovbar; U+0233D
  OverBar; U+0203E
  OverBrace; U+023DE
  OverBracket; U+023B4
  OverParenthesis; U+023DC
  par; U+02225
  para; U+000B6
  parallel; U+02225
  parsim; U+02AF3
  parsl; U+02AFD
  part; U+02202
  PartialD; U+02202
  Pcy; U+0041F
  pcy; U+0043F
  percnt; U+00025
  period; U+0002E
  permil; U+02030
  perp; U+022A5
  pertenk; U+02031
  Pfr; U+1D513
  pfr; U+1D52D
  Phi; U+003A6
  phi; U+003C6
  phiv; U+003D5
  phmmat; U+02133
  phone; U+0260E
  Pi; U+003A0
  pi; U+003C0
  pitchfork; U+022D4
  piv; U+003D6
  planck; U+0210F
  planckh; U+0210E
  plankv; U+0210F
  plus; U+0002B
  plusacir; U+02A23
  plusb; U+0229E
  pluscir; U+02A22
  plusdo; U+02214
  plusdu; U+02A25
  pluse; U+02A72
  PlusMinus; U+000B1
  plusmn; U+000B1
  plussim; U+02A26
  plustwo; U+02A27
  pm; U+000B1
  Poincareplane; U+0210C
  pointint; U+02A15
  Popf; U+02119
  popf; U+1D561
  pound; U+000A3
  Pr; U+02ABB
  pr; U+0227A
  prap; U+02AB7
  prcue; U+0227C
  prE; U+02AB3
  pre; U+02AAF
  prec; U+0227A
  precapprox; U+02AB7
  preccurlyeq; U+0227C
  Precedes; U+0227A
  PrecedesEqual; U+02AAF
  PrecedesSlantEqual; U+0227C
  PrecedesTilde; U+0227E
  preceq; U+02AAF
  precnapprox; U+02AB9
  precneqq; U+02AB5
  precnsim; U+022E8
  precsim; U+0227E
  Prime; U+02033
  prime; U+02032
  primes; U+02119
  prnap; U+02AB9
  prnE; U+02AB5
  prnsim; U+022E8
  prod; U+0220F
  Product; U+0220F
  profalar; U+0232E
  profline; U+02312
  profsurf; U+02313
  prop; U+0221D
  Proportion; U+02237
  Proportional; U+0221D
  propto; U+0221D
  prsim; U+0227E
  prurel; U+022B0
  Pscr; U+1D4AB
  pscr; U+1D4C5
  Psi; U+003A8
  psi; U+003C8
  puncsp; U+02008
  Qfr; U+1D514
  qfr; U+1D52E
  qint; U+02A0C
  Qopf; U+0211A
  qopf; U+1D562
  qprime; U+02057
  Qscr; U+1D4AC
  qscr; U+1D4C6
  quaternions; U+0210D
  quatint; U+02A16
  quest; U+0003F
  questeq; U+0225F
  QUOT; U+00022
  quot; U+00022
  rAarr; U+021DB
  race; U+0223D U+00331
  Racute; U+00154
  racute; U+00155
  radic; U+0221A
  raemptyv; U+029B3
  Rang; U+027EB
  rang; U+027E9
  rangd; U+02992
  range; U+029A5
  rangle; U+027E9
  raquo; U+000BB
  Rarr; U+021A0
  rArr; U+021D2
  rarr; U+02192
  rarrap; U+02975
  rarrb; U+021E5
  rarrbfs; U+02920
  rarrc; U+02933
  rarrfs; U+0291E
  rarrhk; U+021AA
  rarrlp; U+021AC
  rarrpl; U+02945
  rarrsim; U+02974
  Rarrtl; U+02916
  rarrtl; U+021A3
  rarrw; U+0219D
  rAtail; U+0291C
  ratail; U+0291A
  ratio; U+02236
  rationals; U+0211A
  RBarr; U+02910
  rBarr; U+0290F
  rbarr; U+0290D
  rbbrk; U+02773
  rbrace; U+0007D
  rbrack; U+0005D
  rbrke; U+0298C
  rbrksld; U+0298E
  rbrkslu; U+02990
  Rcaron; U+00158
  rcaron; U+00159
  Rcedil; U+00156
  rcedil; U+00157
  rceil; U+02309
  rcub; U+0007D
  Rcy; U+00420
  rcy; U+00440
  rdca; U+02937
  rdldhar; U+02969
  rdquo; U+0201D
  rdquor; U+0201D
  rdsh; U+021B3
  Re; U+0211C
  real; U+0211C
  realine; U+0211B
  realpart; U+0211C
  reals; U+0211D
  rect; U+025AD
  REG; U+000AE
  reg; U+000AE
  ReverseElement; U+0220B
  ReverseEquilibrium; U+021CB
  ReverseUpEquilibrium; U+0296F
  rfisht; U+0297D
  rfloor; U+0230B
  Rfr; U+0211C
  rfr; U+1D52F
  rHar; U+02964
  rhard; U+021C1
  rharu; U+021C0
  rharul; U+0296C
  Rho; U+003A1
  rho; U+003C1
  rhov; U+003F1
  RightAngleBracket; U+027E9
  RightArrow; U+02192
  Rightarrow; U+021D2
  rightarrow; U+02192
  RightArrowBar; U+021E5
  RightArrowLeftArrow; U+021C4
  rightarrowtail; U+021A3
  RightCeiling; U+02309
  RightDoubleBracket; U+027E7
  RightDownTeeVector; U+0295D
  RightDownVector; U+021C2
  RightDownVectorBar; U+02955
  RightFloor; U+0230B
  rightharpoondown; U+021C1
  rightharpoonup; U+021C0
  rightleftarrows; U+021C4
  rightleftharpoons; U+021CC
  rightrightarrows; U+021C9
  rightsquigarrow; U+0219D
  RightTee; U+022A2
  RightTeeArrow; U+021A6
  RightTeeVector; U+0295B
  rightthreetimes; U+022CC
  RightTriangle; U+022B3
  RightTriangleBar; U+029D0
  RightTriangleEqual; U+022B5
  RightUpDownVector; U+0294F
  RightUpTeeVector; U+0295C
  RightUpVector; U+021BE
  RightUpVectorBar; U+02954
  RightVector; U+021C0
  RightVectorBar; U+02953
  ring; U+002DA
  risingdotseq; U+02253
  rlarr; U+021C4
  rlhar; U+021CC
  rlm; U+0200F
  rmoust; U+023B1
  rmoustache; U+023B1
  rnmid; U+02AEE
  roang; U+027ED
  roarr; U+021FE
  robrk; U+027E7
  ropar; U+02986
  Ropf; U+0211D
  ropf; U+1D563
  roplus; U+02A2E
  rotimes; U+02A35
  RoundImplies; U+02970
  rpar; U+00029
  rpargt; U+02994
  rppolint; U+02A12
  rrarr; U+021C9
  Rrightarrow; U+021DB
  rsaquo; U+0203A
  Rscr; U+0211B
  rscr; U+1D4C7
  Rsh; U+021B1
  rsh; U+021B1
  rsqb; U+0005D
  rsquo; U+02019
  rsquor; U+02019
  rthree; U+022CC
  rtimes; U+022CA
  rtri; U+025B9
  rtrie; U+022B5
  rtrif; U+025B8
  rtriltri; U+029CE
  RuleDelayed; U+029F4
  ruluhar; U+02968
  rx; U+0211E
  Sacute; U+0015A
  sacute; U+0015B
  sbquo; U+0201A
  Sc; U+02ABC
  sc; U+0227B
  scap; U+02AB8
  Scaron; U+00160
  scaron; U+00161
  sccue; U+0227D
  scE; U+02AB4
  sce; U+02AB0
  Scedil; U+0015E
  scedil; U+0015F
  Scirc; U+0015C
  scirc; U+0015D
  scnap; U+02ABA
  scnE; U+02AB6
  scnsim; U+022E9
  scpolint; U+02A13
  scsim; U+0227F
  Scy; U+00421
  scy; U+00441
  sdot; U+022C5
  sdotb; U+022A1
  sdote; U+02A66
  searhk; U+02925
  seArr; U+021D8
  searr; U+02198
  searrow; U+02198
  sect; U+000A7
  semi; U+0003B
  seswar; U+02929
  setminus; U+02216
  setmn; U+02216
  sext; U+02736
  Sfr; U+1D516
  sfr; U+1D530
  sfrown; U+02322
  sharp; U+0266F
  SHCHcy; U+00429
  shchcy; U+00449
  SHcy; U+00428
  shcy; U+00448
  ShortDownArrow; U+02193
  ShortLeftArrow; U+02190
  shortmid; U+02223
  shortparallel; U+02225
  ShortRightArrow; U+02192
  ShortUpArrow; U+02191
  shy; U+000AD
  Sigma; U+003A3
  sigma; U+003C3
  sigmaf; U+003C2
  sigmav; U+003C2
  sim; U+0223C
  simdot; U+02A6A
  sime; U+02243
  simeq; U+02243
  simg; U+02A9E
  simgE; U+02AA0
  siml; U+02A9D
  simlE; U+02A9F
  simne; U+02246
  simplus; U+02A24
  simrarr; U+02972
  slarr; U+02190
  SmallCircle; U+02218
  smallsetminus; U+02216
  smashp; U+02A33
  smeparsl; U+029E4
  smid; U+02223
  smile; U+02323
  smt; U+02AAA
  smte; U+02AAC
  smtes; U+02AAC U+0FE00
  SOFTcy; U+0042C
  softcy; U+0044C
  sol; U+0002F
  solb; U+029C4
  solbar; U+0233F
  Sopf; U+1D54A
  sopf; U+1D564
  spades; U+02660
  spadesuit; U+02660
  spar; U+02225
  sqcap; U+02293
  sqcaps; U+02293 U+0FE00
  sqcup; U+02294
  sqcups; U+02294 U+0FE00
  Sqrt; U+0221A
  sqsub; U+0228F
  sqsube; U+02291
  sqsubset; U+0228F
  sqsubseteq; U+02291
  sqsup; U+02290
  sqsupe; U+02292
  sqsupset; U+02290
  sqsupseteq; U+02292
  squ; U+025A1
  Square; U+025A1
  square; U+025A1
  SquareIntersection; U+02293
  SquareSubset; U+0228F
  SquareSubsetEqual; U+02291
  SquareSuperset; U+02290
  SquareSupersetEqual; U+02292
  SquareUnion; U+02294
  squarf; U+025AA
  squf; U+025AA
  srarr; U+02192
  Sscr; U+1D4AE
  sscr; U+1D4C8
  ssetmn; U+02216
  ssmile; U+02323
  sstarf; U+022C6
  Star; U+022C6
  star; U+02606
  starf; U+02605
  straightepsilon; U+003F5
  straightphi; U+003D5
  strns; U+000AF
  Sub; U+022D0
  sub; U+02282
  subdot; U+02ABD
  subE; U+02AC5
  sube; U+02286
  subedot; U+02AC3
  submult; U+02AC1
  subnE; U+02ACB
  subne; U+0228A
  subplus; U+02ABF
  subrarr; U+02979
  Subset; U+022D0
  subset; U+02282
  subseteq; U+02286
  subseteqq; U+02AC5
  SubsetEqual; U+02286
  subsetneq; U+0228A
  subsetneqq; U+02ACB
  subsim; U+02AC7
  subsub; U+02AD5
  subsup; U+02AD3
  succ; U+0227B
  succapprox; U+02AB8
  succcurlyeq; U+0227D
  Succeeds; U+0227B
  SucceedsEqual; U+02AB0
  SucceedsSlantEqual; U+0227D
  SucceedsTilde; U+0227F
  succeq; U+02AB0
  succnapprox; U+02ABA
  succneqq; U+02AB6
  succnsim; U+022E9
  succsim; U+0227F
  SuchThat; U+0220B
  Sum; U+02211
  sum; U+02211
  sung; U+0266A
  Sup; U+022D1
  sup; U+02283
  sup1; U+000B9
  sup2; U+000B2
  sup3; U+000B3
  supdot; U+02ABE
  supdsub; U+02AD8
  supE; U+02AC6
  supe; U+02287
  supedot; U+02AC4
  Superset; U+02283
  SupersetEqual; U+02287
  suphsol; U+027C9
  suphsub; U+02AD7
  suplarr; U+0297B
  supmult; U+02AC2
  supnE; U+02ACC
  supne; U+0228B
  supplus; U+02AC0
  Supset; U+022D1
  supset; U+02283
  supseteq; U+02287
  supseteqq; U+02AC6
  supsetneq; U+0228B
  supsetneqq; U+02ACC
  supsim; U+02AC8
  supsub; U+02AD4
  supsup; U+02AD6
  swarhk; U+02926
  swArr; U+021D9
  swarr; U+02199
  swarrow; U+02199
  swnwar; U+0292A
  szlig; U+000DF
  Tab; U+00009
  target; U+02316
  Tau; U+003A4
  tau; U+003C4
  tbrk; U+023B4
  Tcaron; U+00164
  tcaron; U+00165
  Tcedil; U+00162
  tcedil; U+00163
  Tcy; U+00422
  tcy; U+00442
  tdot; U+020DB
  telrec; U+02315
  Tfr; U+1D517
  tfr; U+1D531
  there4; U+02234
  Therefore; U+02234
  therefore; U+02234
  Theta; U+00398
  theta; U+003B8
  thetasym; U+003D1
  thetav; U+003D1
  thickapprox; U+02248
  thicksim; U+0223C
  ThickSpace; U+0205F U+0200A
  thinsp; U+02009
  ThinSpace; U+02009
  thkap; U+02248
  thksim; U+0223C
  THORN; U+000DE
  thorn; U+000FE
  Tilde; U+0223C
  tilde; U+002DC
  TildeEqual; U+02243
  TildeFullEqual; U+02245
  TildeTilde; U+02248
  times; U+000D7
  timesb; U+022A0
  timesbar; U+02A31
  timesd; U+02A30
  tint; U+0222D
  toea; U+02928
  top; U+022A4
  topbot; U+02336
  topcir; U+02AF1
  Topf; U+1D54B
  topf; U+1D565
  topfork; U+02ADA
  tosa; U+02929
  tprime; U+02034
  TRADE; U+02122
  trade; U+02122
  triangle; U+025B5
  triangledown; U+025BF
  triangleleft; U+025C3
  trianglelefteq; U+022B4
  triangleq; U+0225C
  triangleright; U+025B9
  trianglerighteq; U+022B5
  tridot; U+025EC
  trie; U+0225C
  triminus; U+02A3A
  TripleDot; U+020DB
  triplus; U+02A39
  trisb; U+029CD
  tritime; U+02A3B
  trpezium; U+023E2
  Tscr; U+1D4AF
  tscr; U+1D4C9
  TScy; U+00426
  tscy; U+00446
  TSHcy; U+0040B
  tshcy; U+0045B
  Tstrok; U+00166
  tstrok; U+00167
  twixt; U+0226C
  twoheadleftarrow; U+0219E
  twoheadrightarrow; U+021A0
  Uacute; U+000DA
  uacute; U+000FA
  Uarr; U+0219F
  uArr; U+021D1
  uarr; U+02191
  Uarrocir; U+02949
  Ubrcy; U+0040E
  ubrcy; U+0045E
  Ubreve; U+0016C
  ubreve; U+0016D
  Ucirc; U+000DB
  ucirc; U+000FB
  Ucy; U+00423
  ucy; U+00443
  udarr; U+021C5
  Udblac; U+00170
  udblac; U+00171
  udhar; U+0296E
  ufisht; U+0297E
  Ufr; U+1D518
  ufr; U+1D532
  Ugrave; U+000D9
  ugrave; U+000F9
  uHar; U+02963
  uharl; U+021BF
  uharr; U+021BE
  uhblk; U+02580
  ulcorn; U+0231C
  ulcorner; U+0231C
  ulcrop; U+0230F
  ultri; U+025F8
  Umacr; U+0016A
  umacr; U+0016B
  uml; U+000A8
  UnderBar; U+0005F
  UnderBrace; U+023DF
  UnderBracket; U+023B5
  UnderParenthesis; U+023DD
  Union; U+022C3
  UnionPlus; U+0228E
  Uogon; U+00172
  uogon; U+00173
  Uopf; U+1D54C
  uopf; U+1D566
  UpArrow; U+02191
  Uparrow; U+021D1
  uparrow; U+02191
  UpArrowBar; U+02912
  UpArrowDownArrow; U+021C5
  UpDownArrow; U+02195
  Updownarrow; U+021D5
  updownarrow; U+02195
  UpEquilibrium; U+0296E
  upharpoonleft; U+021BF
  upharpoonright; U+021BE
  uplus; U+0228E
  UpperLeftArrow; U+02196
  UpperRightArrow; U+02197
  Upsi; U+003D2
  upsi; U+003C5
  upsih; U+003D2
  Upsilon; U+003A5
  upsilon; U+003C5
  UpTee; U+022A5
  UpTeeArrow; U+021A5
  upuparrows; U+021C8
  urcorn; U+0231D
  urcorner; U+0231D
  urcrop; U+0230E
  Uring; U+0016E
  uring; U+0016F
  urtri; U+025F9
  Uscr; U+1D4B0
  uscr; U+1D4CA
  utdot; U+022F0
  Utilde; U+00168
  utilde; U+00169
  utri; U+025B5
  utrif; U+025B4
  uuarr; U+021C8
  Uuml; U+000DC
  uuml; U+000FC
  uwangle; U+029A7
  vangrt; U+0299C
  varepsilon; U+003F5
  varkappa; U+003F0
  varnothing; U+02205
  varphi; U+003D5
  varpi; U+003D6
  varpropto; U+0221D
  vArr; U+021D5
  varr; U+02195
  varrho; U+003F1
  varsigma; U+003C2
  varsubsetneq; U+0228A U+0FE00
  varsubsetneqq; U+02ACB U+0FE00
  varsupsetneq; U+0228B U+0FE00
  varsupsetneqq; U+02ACC U+0FE00
  vartheta; U+003D1
  vartriangleleft; U+022B2
  vartriangleright; U+022B3
  Vbar; U+02AEB
  vBar; U+02AE8
  vBarv; U+02AE9
  Vcy; U+00412
  vcy; U+00432
  VDash; U+022AB
  Vdash; U+022A9
  vDash; U+022A8
  vdash; U+022A2
  Vdashl; U+02AE6
  Vee; U+022C1
  vee; U+02228
  veebar; U+022BB
  veeeq; U+0225A
  vellip; U+022EE
  Verbar; U+02016
  verbar; U+0007C
  Vert; U+02016
  vert; U+0007C
  VerticalBar; U+02223
  VerticalLine; U+0007C
  VerticalSeparator; U+02758
  VerticalTilde; U+02240
  VeryThinSpace; U+0200A
  Vfr; U+1D519
  vfr; U+1D533
  vltri; U+022B2
  vnsub; U+02282 U+020D2
  vnsup; U+02283 U+020D2
  Vopf; U+1D54D
  vopf; U+1D567
  vprop; U+0221D
  vrtri; U+022B3
  Vscr; U+1D4B1
  vscr; U+1D4CB
  vsubnE; U+02ACB U+0FE00
  vsubne; U+0228A U+0FE00
  vsupnE; U+02ACC U+0FE00
  vsupne; U+0228B U+0FE00
  Vvdash; U+022AA
  vzigzag; U+0299A
  Wcirc; U+00174
  wcirc; U+00175
  wedbar; U+02A5F
  Wedge; U+022C0
  wedge; U+02227
  wedgeq; U+02259
  weierp; U+02118
  Wfr; U+1D51A
  wfr; U+1D534
  Wopf; U+1D54E
  wopf; U+1D568
  wp; U+02118
  wr; U+02240
  wreath; U+02240
  Wscr; U+1D4B2
  wscr; U+1D4CC
  xcap; U+022C2
  xcirc; U+025EF
  xcup; U+022C3
  xdtri; U+025BD
  Xfr; U+1D51B
  xfr; U+1D535
  xhArr; U+027FA
  xharr; U+027F7
  Xi; U+0039E
  xi; U+003BE
  xlArr; U+027F8
  xlarr; U+027F5
  xmap; U+027FC
  xnis; U+022FB
  xodot; U+02A00
  Xopf; U+1D54F
  xopf; U+1D569
  xoplus; U+02A01
  xotime; U+02A02
  xrArr; U+027F9
  xrarr; U+027F6
  Xscr; U+1D4B3
  xscr; U+1D4CD
  xsqcup; U+02A06
  xuplus; U+02A04
  xutri; U+025B3
  xvee; U+022C1
  xwedge; U+022C0
  Yacute; U+000DD
  yacute; U+000FD
  YAcy; U+0042F
  yacy; U+0044F
  Ycirc; U+00176
  ycirc; U+00177
  Ycy; U+0042B
  ycy; U+0044B
  yen; U+000A5
  Yfr; U+1D51C
  yfr; U+1D536
  YIcy; U+00407
  yicy; U+00457
  Yopf; U+1D550
  yopf; U+1D56A
  Yscr; U+1D4B4
  yscr; U+1D4CE
  YUcy; U+0042E
  yucy; U+0044E
  Yuml; U+00178
  yuml; U+000FF
  Zacute; U+00179
  zacute; U+0017A
  Zcaron; U+0017D
  zcaron; U+0017E
  Zcy; U+00417
  zcy; U+00437
  Zdot; U+0017B
  zdot; U+0017C
  zeetrf; U+02128
  ZeroWidthSpace; U+0200B
  Zeta; U+00396
  zeta; U+003B6
  Zfr; U+02128
  zfr; U+1D537
  ZHcy; U+00416
  zhcy; U+00436
  zigrarr; U+021DD
  Zopf; U+02124
  zopf; U+1D56B
  Zscr; U+1D4B5
  zscr; U+1D4CF
  zwj; U+0200D
  zwnj; U+0200C
MOJO_UTIL

$fatpacked{"Mojo/WebSocket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJO_WEBSOCKET';
  package Mojo::WebSocket;use Mojo::Base -strict;use Config;use Exporter 'import';use Mojo::Util qw(b64_encode sha1_bytes xor_encode);use constant DEBUG=>$ENV{MOJO_WEBSOCKET_DEBUG}|| 0;use constant GUID=>'258EAFA5-E914-47DA-95CA-C5AB0DC85B11';use constant MODERN=>(($Config{use64bitint}// '')eq 'define' || $Config{longsize}>= 8);use constant {WS_CONTINUATION=>0x0,WS_TEXT=>0x1,WS_BINARY=>0x2,WS_CLOSE=>0x8,WS_PING=>0x9,WS_PONG=>0xa };our@EXPORT_OK=(qw(WS_BINARY WS_CLOSE WS_CONTINUATION WS_PING WS_PONG WS_TEXT),qw(build_frame challenge client_handshake parse_frame server_handshake));sub build_frame {my ($masked,$fin,$rsv1,$rsv2,$rsv3,$op,$payload)=@_;warn "-- Building frame ($fin, $rsv1, $rsv2, $rsv3, $op)\n" if DEBUG;my$head=$op + ($fin ? 128 : 0);$head |= 0b01000000 if$rsv1;$head |= 0b00100000 if$rsv2;$head |= 0b00010000 if$rsv3;my$frame=pack 'C',$head;my$len=length$payload;if ($len < 126){warn "-- Small payload ($len)\n@{[dumper $payload]}" if DEBUG;$frame .= pack 'C',$masked ? ($len | 128): $len}elsif ($len < 65536){warn "-- Extended 16-bit payload ($len)\n@{[dumper $payload]}" if DEBUG;$frame .= pack 'Cn',$masked ? (126 | 128): 126,$len}else {warn "-- Extended 64-bit payload ($len)\n@{[dumper $payload]}" if DEBUG;$frame .= pack 'C',$masked ? (127 | 128): 127;$frame .= MODERN ? pack('Q>',$len): pack('NN',0,$len & 0xffffffff)}if ($masked){my$mask=pack 'N',int(rand 9 x 7);$payload=$mask .xor_encode($payload,$mask x 128)}return$frame .$payload}sub challenge {my$tx=shift;my$headers=$tx->res->headers;$tx->compressed(1)if ($headers->sec_websocket_extensions // '')=~ /permessage-deflate/;return _challenge($tx->req->headers->sec_websocket_key)eq $headers->sec_websocket_accept}sub client_handshake {my$tx=shift;my$headers=$tx->req->headers;$headers->upgrade('websocket')unless$headers->upgrade;$headers->connection('Upgrade')unless$headers->connection;$headers->sec_websocket_version(13)unless$headers->sec_websocket_version;my$challenge=b64_encode sprintf('%16u',int(rand 9 x 16)),'';$headers->sec_websocket_key($challenge)unless$headers->sec_websocket_key;return$tx}sub parse_frame {my ($buffer,$max)=@_;return undef unless length $$buffer >= 2;my ($first,$second)=unpack 'C*',substr($$buffer,0,2);my$fin=($first & 0b10000000)==0b10000000 ? 1 : 0;my$rsv1=($first & 0b01000000)==0b01000000 ? 1 : 0;my$rsv2=($first & 0b00100000)==0b00100000 ? 1 : 0;my$rsv3=($first & 0b00010000)==0b00010000 ? 1 : 0;my$op=$first & 0b00001111;warn "-- Parsing frame ($fin, $rsv1, $rsv2, $rsv3, $op)\n" if DEBUG;my ($hlen,$len)=(2,$second & 0b01111111);if ($len < 126){warn "-- Small payload ($len)\n" if DEBUG}elsif ($len==126){return undef unless length $$buffer > 4;$hlen=4;$len=unpack 'n',substr($$buffer,2,2);warn "-- Extended 16-bit payload ($len)\n" if DEBUG}elsif ($len==127){return undef unless length $$buffer > 10;$hlen=10;my$ext=substr $$buffer,2,8;$len=MODERN ? unpack('Q>',$ext): unpack('N',substr($ext,4,4));warn "-- Extended 64-bit payload ($len)\n" if DEBUG}return 1 if$len > $max;$len += 4 if my$masked=$second & 0b10000000;return undef if length $$buffer < ($hlen + $len);substr $$buffer,0,$hlen,'';my$payload=$len ? substr($$buffer,0,$len,''): '';$payload=xor_encode($payload,substr($payload,0,4,'')x 128)if$masked;warn dumper$payload if DEBUG;return [$fin,$rsv1,$rsv2,$rsv3,$op,$payload]}sub server_handshake {my$tx=shift;my$headers=$tx->res->headers;$headers->upgrade('websocket')->connection('Upgrade');$headers->sec_websocket_accept(_challenge($tx->req->headers->sec_websocket_key));return$tx}sub _challenge {b64_encode(sha1_bytes(($_[0]|| '').GUID),'')}1;
MOJO_WEBSOCKET

$fatpacked{"Mojolicious.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS';
  package Mojolicious;use Mojo::Base 'Mojo';use Carp ();use Mojo::Exception;use Mojo::Util;use Mojolicious::Commands;use Mojolicious::Controller;use Mojolicious::Plugins;use Mojolicious::Renderer;use Mojolicious::Routes;use Mojolicious::Sessions;use Mojolicious::Static;use Mojolicious::Types;use Mojolicious::Validator;use Scalar::Util ();use Time::HiRes ();has commands=>sub {my$commands=Mojolicious::Commands->new(app=>shift);Scalar::Util::weaken$commands->{app};return$commands};has controller_class=>'Mojolicious::Controller';has mode=>sub {$ENV{MOJO_MODE}|| $ENV{PLACK_ENV}|| 'development'};has moniker=>sub {Mojo::Util::decamelize ref shift};has plugins=>sub {Mojolicious::Plugins->new};has renderer=>sub {Mojolicious::Renderer->new};has routes=>sub {Mojolicious::Routes->new};has secrets=>sub {my$self=shift;$self->log->debug('Your secret passphrase needs to be changed');return [$self->moniker]};has sessions=>sub {Mojolicious::Sessions->new};has static=>sub {Mojolicious::Static->new};has types=>sub {Mojolicious::Types->new};has validator=>sub {Mojolicious::Validator->new};our$CODENAME='Clinking Beer Mugs';our$VERSION='6.40';sub AUTOLOAD {my$self=shift;my ($package,$method)=our$AUTOLOAD =~ /^(.+)::(.+)$/;Carp::croak "Undefined subroutine &${package}::$method called" unless Scalar::Util::blessed$self && $self->isa(__PACKAGE__);Carp::croak qq{Can't locate object method "$method" via package "$package"} unless my$helper=$self->renderer->get_helper($method);return$self->build_controller->$helper(@_)}sub build_controller {my ($self,$tx)=@_;$tx ||= $self->build_tx;my$stash={};if (my$sub=$tx->can('stash')){($stash,$tx)=($tx->$sub,$tx->tx)}my$defaults=$self->defaults;@$stash{keys %$defaults}=values %$defaults;my$c =$self->controller_class->new(app=>$self,stash=>$stash,tx=>$tx);Scalar::Util::weaken$c->{app};return$c}sub build_tx {my$self=shift;my$tx=Mojo::Transaction::HTTP->new;$self->plugins->emit_hook(after_build_tx=>$tx,$self);return$tx}sub defaults {Mojo::Util::_stash(defaults=>@_)}sub dispatch {my ($self,$c)=@_;my$plugins=$self->plugins->emit_hook(before_dispatch=>$c);my$tx=$c->tx;$self->static->dispatch($c)and $plugins->emit_hook(after_static=>$c)unless$tx->res->code;my$stash=$c->stash;unless ($stash->{'mojo.static'}|| $stash->{'mojo.started'}){my$req=$c->req;my$method=$req->method;my$path=$req->url->path->to_abs_string;$self->log->debug(qq{$method "$path"});$stash->{'mojo.started'}=[Time::HiRes::gettimeofday]}$plugins->emit_hook(before_routes=>$c);$c->helpers->reply->not_found unless$tx->res->code || $self->routes->dispatch($c)|| $tx->res->code}sub handler {my$self=shift;++$self->{dispatch}and $self->hook(around_action=>sub {$_[2]($_[1])})and $self->hook(around_dispatch=>sub {$_[1]->app->dispatch($_[1])})unless$self->{dispatch};my$c=$self->build_controller(@_);Scalar::Util::weaken$c->{tx};$self->plugins->emit_chain(around_dispatch=>$c);$self->log->debug('Nothing has been rendered, expecting delayed response')unless$c->stash->{'mojo.rendered'}}sub helper {shift->renderer->add_helper(@_)}sub hook {shift->plugins->on(@_)}sub new {my$self=shift->SUPER::new(@_);my$home=$self->home;push @{$self->renderer->paths},$home->rel_dir('templates');push @{$self->static->paths},$home->rel_dir('public');my$r=$self->routes->namespaces(["@{[ref $self]}::Controller",ref$self]);$r->hide(qw(app continue cookie every_cookie every_param));$r->hide(qw(every_signed_cookie finish flash helpers match on param));$r->hide(qw(redirect_to render render_later render_maybe render_to_string));$r->hide(qw(rendered req res respond_to send session signed_cookie stash));$r->hide(qw(tx url_for validation write write_chunk));my$mode=$self->mode;$self->log->path($home->rel_file("log/$mode.log"))if -d $home->rel_file('log')&& -w _;$self->plugin($_)for qw(HeaderCondition DefaultHelpers TagHelpers EPLRenderer EPRenderer);$self->hook(around_dispatch=>\&_exception);$self->log->level('info')unless$mode eq 'development';$self->startup;return$self}sub plugin {my$self=shift;$self->plugins->register_plugin(shift,$self,@_)}sub start {my$self=shift;$_->warmup for$self->static,$self->renderer;return$self->commands->run(@_ ? @_ : @ARGV)}sub startup {}sub _exception {my ($next,$c)=@_;local$SIG{__DIE__}=sub {ref $_[0]? CORE::die($_[0]): Mojo::Exception->throw(@_)};$c->helpers->reply->exception($@)unless eval {$next->();1}}1;
MOJOLICIOUS

$fatpacked{"Mojolicious/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND';
  package Mojolicious::Command;use Mojo::Base -base;use Carp 'croak';use Cwd 'getcwd';use File::Basename 'dirname';use File::Path 'mkpath';use File::Spec::Functions qw(catdir catfile);use Mojo::Loader 'data_section';use Mojo::Server;use Mojo::Template;use Mojo::Util qw(spurt unindent);use Pod::Usage 'pod2usage';has app=>sub {Mojo::Server->new->build_app('Mojo::HelloWorld')};has description=>'No description';has 'quiet';has usage=>"Usage: APPLICATION\n";sub chmod_file {my ($self,$path,$mod)=@_;chmod$mod,$path or croak qq{Can't chmod file "$path": $!};say "  [chmod] $path " .sprintf('%lo',$mod)unless$self->quiet;return$self}sub chmod_rel_file {$_[0]->chmod_file($_[0]->rel_file($_[1]),$_[2])}sub create_dir {my ($self,$path)=@_;if (-d $path){say "  [exist] $path" unless$self->quiet}else {mkpath$path or croak qq{Can't make directory "$path": $!};say "  [mkdir] $path" unless$self->quiet}return$self}sub create_rel_dir {$_[0]->create_dir($_[0]->rel_dir($_[1]))}sub extract_usage {my$self=shift;open my$handle,'>',\my$output;pod2usage -exitval=>'noexit',-input=>(caller)[1],-output=>$handle;$output =~ s/^.*\n//;$output =~ s/\n$//;return unindent$output}sub help {print shift->usage}sub rel_dir {catdir getcwd(),split('/',pop)}sub rel_file {catfile getcwd(),split('/',pop)}sub render_data {my ($self,$name)=(shift,shift);Mojo::Template->new->name("template $name from DATA section")->render(data_section(ref$self,$name),@_)}sub render_to_file {my ($self,$data,$path)=(shift,shift,shift);return$self->write_file($path,$self->render_data($data,@_))}sub render_to_rel_file {my$self=shift;$self->render_to_file(shift,$self->rel_dir(shift),@_)}sub run {croak 'Method "run" not implemented by subclass'}sub write_file {my ($self,$path,$data)=@_;$self->create_dir(dirname$path);spurt$data,$path;say "  [write] $path" unless$self->quiet;return$self}sub write_rel_file {$_[0]->write_file($_[0]->rel_file($_[1]),$_[2])}1;
MOJOLICIOUS_COMMAND

$fatpacked{"Mojolicious/Command/cgi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_CGI';
  package Mojolicious::Command::cgi;use Mojo::Base 'Mojolicious::Command';use Getopt::Long qw(GetOptionsFromArray :config no_auto_abbrev no_ignore_case);use Mojo::Server::CGI;has description=>'Start application with CGI';has usage=>sub {shift->extract_usage};sub run {my ($self,@args)=@_;GetOptionsFromArray \@args,nph=>\(my$nph=0);Mojo::Server::CGI->new(app=>$self->app,nph=>$nph)->run}1;
MOJOLICIOUS_COMMAND_CGI

$fatpacked{"Mojolicious/Command/cpanify.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_CPANIFY';
  package Mojolicious::Command::cpanify;use Mojo::Base 'Mojolicious::Command';use File::Basename 'basename';use Getopt::Long qw(GetOptionsFromArray :config no_auto_abbrev no_ignore_case);has description=>'Upload distribution to CPAN';has usage=>sub {shift->extract_usage};sub run {my ($self,@args)=@_;GetOptionsFromArray \@args,'p|password=s'=>\(my$password=''),'u|user=s'=>\(my$user='');die$self->usage unless my$file=shift@args;my$tx=$self->app->ua->tap(sub {$_->proxy->detect})->post("https://$user:$password\@pause.perl.org/pause/authenquery"=>form=>{HIDDENNAME=>$user,CAN_MULTIPART=>1,pause99_add_uri_upload=>basename($file),SUBMIT_pause99_add_uri_httpupload=>' Upload this file from my disk ',pause99_add_uri_uri=>'',pause99_add_uri_httpupload=>{file=>$file},});unless ($tx->success){my$code=$tx->res->code // 0;my$msg=$tx->error->{message};if ($code==401){$msg='Wrong username or password.'}elsif ($code==409){$msg='File already exists on CPAN.'}die qq{Problem uploading file "$file": $msg\n}}say 'Upload successful!'}1;
MOJOLICIOUS_COMMAND_CPANIFY

$fatpacked{"Mojolicious/Command/daemon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_DAEMON';
  package Mojolicious::Command::daemon;use Mojo::Base 'Mojolicious::Command';use Getopt::Long qw(GetOptionsFromArray :config no_auto_abbrev no_ignore_case);use Mojo::Server::Daemon;has description=>'Start application with HTTP and WebSocket server';has usage=>sub {shift->extract_usage};sub run {my ($self,@args)=@_;my$daemon=Mojo::Server::Daemon->new(app=>$self->app);GetOptionsFromArray \@args,'b|backlog=i'=>sub {$daemon->backlog($_[1])},'c|clients=i'=>sub {$daemon->max_clients($_[1])},'i|inactivity-timeout=i'=>sub {$daemon->inactivity_timeout($_[1])},'l|listen=s'=>\my@listen,'p|proxy'=>sub {$daemon->reverse_proxy(1)},'r|requests=i'=>sub {$daemon->max_requests($_[1])};$daemon->listen(\@listen)if@listen;$daemon->run}1;
MOJOLICIOUS_COMMAND_DAEMON

$fatpacked{"Mojolicious/Command/eval.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_EVAL';
  package Mojolicious::Command::eval;use Mojo::Base 'Mojolicious::Command';use Getopt::Long qw(GetOptionsFromArray :config no_auto_abbrev no_ignore_case);has description=>'Run code against application';has usage=>sub {shift->extract_usage};sub run {my ($self,@args)=@_;GetOptionsFromArray \@args,'v|verbose'=>\my$v1,'V'=>\my$v2;my$code=shift@args || '';my$app=$self->app;no warnings;my$result=eval "package main; sub app; local *app = sub { \$app }; $code";return $@ ? die $@ : $result unless defined$result && ($v1 || $v2);$v2 ? print($app->dumper($result)): say$result}1;
MOJOLICIOUS_COMMAND_EVAL

$fatpacked{"Mojolicious/Command/generate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE';
  package Mojolicious::Command::generate;use Mojo::Base 'Mojolicious::Commands';has description=>'Generate files and directories from templates';has hint=><<EOF;has message=>sub {shift->extract_usage ."\nGenerators:\n"};has namespaces=>sub {['Mojolicious::Command::generate']};sub help {shift->run(@_)}1;
  
  See 'APPLICATION generate help GENERATOR' for more information on a specific
  generator.
  EOF
MOJOLICIOUS_COMMAND_GENERATE

$fatpacked{"Mojolicious/Command/generate/app.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_APP';
  package Mojolicious::Command::generate::app;use Mojo::Base 'Mojolicious::Command';use Mojo::Util qw(class_to_file class_to_path);has description=>'Generate Mojolicious application directory structure';has usage=>sub {shift->extract_usage};sub run {my ($self,$class)=@_;$class ||= 'MyApp';die <<EOF unless$class =~ /^[A-Z](?:\w|::)+$/;my$name=class_to_file$class;$self->render_to_rel_file('mojo',"$name/script/$name",$class);$self->chmod_rel_file("$name/script/$name",0744);my$app=class_to_path$class;$self->render_to_rel_file('appclass',"$name/lib/$app",$class);my$controller="${class}::Controller::Example";my$path=class_to_path$controller;$self->render_to_rel_file('controller',"$name/lib/$path",$controller);$self->render_to_rel_file('test',"$name/t/basic.t",$class);$self->render_to_rel_file('static',"$name/public/index.html");$self->render_to_rel_file('layout',"$name/templates/layouts/default.html.ep");$self->render_to_rel_file('welcome',"$name/templates/example/welcome.html.ep")}1;__DATA__ 
  Your application name has to be a well formed (CamelCase) Perl module name
  like "MyApp".
  EOF
  @@ mojo
  % my $class = shift;
  #!/usr/bin/env perl
  
  use strict;
  use warnings;
  
  use FindBin;
  BEGIN { unshift @INC, "$FindBin::Bin/../lib" }
  
  # Start command line interface for application
  require Mojolicious::Commands;
  Mojolicious::Commands->start_app('<%= $class %>');
  
  @@ appclass
  % my $class = shift;
  package <%= $class %>;
  use Mojo::Base 'Mojolicious';
  
  # This method will run once at server start
  sub startup {
    my $self = shift;
  
    # Documentation browser under "/perldoc"
    $self->plugin('PODRenderer');
  
    # Router
    my $r = $self->routes;
  
    # Normal route to controller
    $r->get('/')->to('example#welcome');
  }
  
  1;
  
  @@ controller
  % my $class = shift;
  package <%= $class %>;
  use Mojo::Base 'Mojolicious::Controller';
  
  # This action will render a template
  sub welcome {
    my $self = shift;
  
    # Render template "example/welcome.html.ep" with message
    $self->render(msg => 'Welcome to the Mojolicious real-time web framework!');
  }
  
  1;
  
  @@ static
  <!DOCTYPE html>
  <html>
    <head>
      <title>Welcome to the Mojolicious real-time web framework!</title>
    </head>
    <body>
      <h2>Welcome to the Mojolicious real-time web framework!</h2>
      This is the static document "public/index.html",
      <a href="/">click here</a> to get back to the start.
    </body>
  </html>
  
  @@ test
  % my $class = shift;
  use Mojo::Base -strict;
  
  use Test::More;
  use Test::Mojo;
  
  my $t = Test::Mojo->new('<%= $class %>');
  $t->get_ok('/')->status_is(200)->content_like(qr/Mojolicious/i);
  
  done_testing();
  
  @@ layout
  <!DOCTYPE html>
  <html>
    <head><title><%%= title %></title></head>
    <body><%%= content %></body>
  </html>
  
  @@ welcome
  %% layout 'default';
  %% title 'Welcome';
  <h2><%%= $msg %></h2>
  This page was generated from the template "templates/example/welcome.html.ep"
  and the layout "templates/layouts/default.html.ep",
  <%%= link_to 'click here' => url_for %> to reload the page or
  <%%= link_to 'here' => '/index.html' %> to move forward to a static page. To
  learn more, you can also browse through the documentation
  <%%= link_to 'here' => '/perldoc' %>.
MOJOLICIOUS_COMMAND_GENERATE_APP

$fatpacked{"Mojolicious/Command/generate/lite_app.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_LITE_APP';
  package Mojolicious::Command::generate::lite_app;use Mojo::Base 'Mojolicious::Command';has description=>'Generate Mojolicious::Lite application';has usage=>sub {shift->extract_usage};sub run {my ($self,$name)=@_;$name ||= 'myapp.pl';$self->render_to_rel_file('liteapp',$name);$self->chmod_rel_file($name,0744)}1;__DATA__ 
  @@ liteapp
  #!/usr/bin/env perl
  use Mojolicious::Lite;
  
  # Documentation browser under "/perldoc"
  plugin 'PODRenderer';
  
  get '/' => sub {
    my $c = shift;
    $c->render(template => 'index');
  };
  
  app->start;
  <% %>__DATA__
  
  <% %>@@ index.html.ep
  %% layout 'default';
  %% title 'Welcome';
  <h1>Welcome to the Mojolicious real-time web framework!</h1>
  To learn more, you can browse through the documentation
  <%%= link_to 'here' => '/perldoc' %>.
  
  <% %>@@ layouts/default.html.ep
  <!DOCTYPE html>
  <html>
    <head><title><%%= title %></title></head>
    <body><%%= content %></body>
  </html>
MOJOLICIOUS_COMMAND_GENERATE_LITE_APP

$fatpacked{"Mojolicious/Command/generate/makefile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_MAKEFILE';
  package Mojolicious::Command::generate::makefile;use Mojo::Base 'Mojolicious::Command';use Mojolicious;has description=>'Generate "Makefile.PL"';has usage=>sub {shift->extract_usage};sub run {shift->render_to_rel_file('makefile','Makefile.PL')}1;__DATA__ 
  @@ makefile
  use strict;
  use warnings;
  
  use ExtUtils::MakeMaker;
  
  WriteMakefile(
    VERSION   => '0.01',
    PREREQ_PM => {'Mojolicious' => '<%= $Mojolicious::VERSION %>'},
    test      => {TESTS => 't/*.t'}
  );
MOJOLICIOUS_COMMAND_GENERATE_MAKEFILE

$fatpacked{"Mojolicious/Command/generate/plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GENERATE_PLUGIN';
  package Mojolicious::Command::generate::plugin;use Mojo::Base 'Mojolicious::Command';use Mojo::Util qw(camelize class_to_path);use Mojolicious;has description=>'Generate Mojolicious plugin directory structure';has usage=>sub {shift->extract_usage};sub run {my ($self,$name)=@_;$name ||= 'MyPlugin';my$class=$name =~ /^[a-z]/ ? camelize$name : $name;$class="Mojolicious::Plugin::$class";my$app=class_to_path$class;my$dir=join '-',split('::',$class);$self->render_to_rel_file('class',"$dir/lib/$app",$class,$name);$self->render_to_rel_file('test',"$dir/t/basic.t",$name);$self->render_to_rel_file('makefile',"$dir/Makefile.PL",$class,$app)}1;__DATA__ 
  @@ class
  % my ($class, $name) = @_;
  package <%= $class %>;
  use Mojo::Base 'Mojolicious::Plugin';
  
  our $VERSION = '0.01';
  
  sub register {
    my ($self, $app) = @_;
  }
  
  1;
  <% %>__END__
  
  <% %>=encoding utf8
  
  <% %>=head1 NAME
  
  <%= $class %> - Mojolicious Plugin
  
  <% %>=head1 SYNOPSIS
  
    # Mojolicious
    $self->plugin('<%= $name %>');
  
    # Mojolicious::Lite
    plugin '<%= $name %>';
  
  <% %>=head1 DESCRIPTION
  
  L<<%= $class %>> is a L<Mojolicious> plugin.
  
  <% %>=head1 METHODS
  
  L<<%= $class %>> inherits all methods from
  L<Mojolicious::Plugin> and implements the following new ones.
  
  <% %>=head2 register
  
    $plugin->register(Mojolicious->new);
  
  Register plugin in L<Mojolicious> application.
  
  <% %>=head1 SEE ALSO
  
  L<Mojolicious>, L<Mojolicious::Guides>, L<http://mojolicious.org>.
  
  <% %>=cut
  
  @@ test
  % my $name = shift;
  use Mojo::Base -strict;
  
  use Test::More;
  use Mojolicious::Lite;
  use Test::Mojo;
  
  plugin '<%= $name %>';
  
  get '/' => sub {
    my $c = shift;
    $c->render(text => 'Hello Mojo!');
  };
  
  my $t = Test::Mojo->new;
  $t->get_ok('/')->status_is(200)->content_is('Hello Mojo!');
  
  done_testing();
  
  @@ makefile
  % my ($class, $path) = @_;
  use strict;
  use warnings;
  
  use ExtUtils::MakeMaker;
  
  WriteMakefile(
    NAME         => '<%= $class %>',
    VERSION_FROM => 'lib/<%= $path %>',
    AUTHOR       => 'A Good Programmer <nospam@cpan.org>',
    PREREQ_PM    => {'Mojolicious' => '<%= $Mojolicious::VERSION %>'},
    test         => {TESTS => 't/*.t'}
  );
MOJOLICIOUS_COMMAND_GENERATE_PLUGIN

$fatpacked{"Mojolicious/Command/get.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_GET';
  package Mojolicious::Command::get;use Mojo::Base 'Mojolicious::Command';use Getopt::Long qw(GetOptionsFromArray :config no_auto_abbrev no_ignore_case);use Mojo::DOM;use Mojo::IOLoop;use Mojo::JSON qw(encode_json j);use Mojo::JSON::Pointer;use Mojo::Util qw(decode encode);use Scalar::Util 'weaken';has description=>'Perform HTTP request';has usage=>sub {shift->extract_usage};sub run {my ($self,@args)=@_;GetOptionsFromArray \@args,'C|charset=s'=>\my$charset,'c|content=s'=>\(my$content=''),'H|header=s'=>\my@headers,'M|method=s'=>\(my$method='GET'),'r|redirect'=>\my$redirect,'v|verbose'=>\my$verbose;@args=map {decode 'UTF-8',$_}@args;die$self->usage unless my$url=shift@args;my$selector=shift@args;my%headers=map {/^\s*([^:]+)\s*:\s*(.+)$/ ? ($1,$2): ()}@headers;my$ua=$self->app->ua->ioloop(Mojo::IOLoop->singleton);$ua->server->ioloop(Mojo::IOLoop->singleton);$ua->proxy->detect unless$url =~ m!^/!;$ua->max_redirects(10)if$redirect;my$buffer='';$ua->on(start=>sub {my ($ua,$tx)=@_;weaken$tx;$tx->res->content->on(body=>sub {warn _header($tx->req),_header($tx->res)})if$verbose;$tx->res->content->unsubscribe('read')->on(read=>sub {return if$redirect && $tx->res->is_status_class(300);defined$selector ? ($buffer .= pop): print pop})});$verbose=1 if$method eq 'HEAD';STDOUT->autoflush(1);my$tx=$ua->start($ua->build_tx($method,$url,\%headers,$content));my$err=$tx->error;warn qq{Problem loading URL "@{[$tx->req->url]}": $err->{message}\n} if$err &&!$err->{code};return unless defined$selector;return _json($buffer,$selector)if$selector eq '' || $selector =~ m!^/!;$charset //= $tx->res->content->charset || $tx->res->default_charset;_select($buffer,$selector,$charset,@args)}sub _header {$_[0]->build_start_line,$_[0]->headers->to_string,"\n\n"}sub _json {return unless my$data=j(shift);return unless defined($data=Mojo::JSON::Pointer->new($data)->get(shift));return _say($data)unless ref$data eq 'HASH' || ref$data eq 'ARRAY';say encode_json($data)}sub _say {$_ ne '' && say encode('UTF-8',$_)for @_}sub _select {my ($buffer,$selector,$charset,@args)=@_;$buffer=decode($charset,$buffer)// $buffer if$charset;my$dom=Mojo::DOM->new($buffer);my$results=$dom->find($selector);while (defined(my$command=shift@args)){($results=$results->slice($command))and next if$command =~ /^\d+$/;return _say($results->map('text')->each)if$command eq 'text';return _say($results->map('all_text')->each)if$command eq 'all';return _say($results->map(attr=>$args[0]// '')->each)if$command eq 'attr';die qq{Unknown command "$command".\n}}_say($results->each)}1;
MOJOLICIOUS_COMMAND_GET

$fatpacked{"Mojolicious/Command/inflate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_INFLATE';
  package Mojolicious::Command::inflate;use Mojo::Base 'Mojolicious::Command';use Mojo::Loader qw(data_section file_is_binary);use Mojo::Util 'encode';has description=>'Inflate embedded files to real files';has usage=>sub {shift->extract_usage};sub run {my$self=shift;my%all;my$app=$self->app;for my$class (@{$app->renderer->classes},@{$app->static->classes}){for my$name (keys %{data_section$class}){my$data=data_section$class,$name;$data=encode 'UTF-8',$data unless file_is_binary$class,$name;$all{$name}=$data}}for my$name (grep {/\.\w+$/}keys%all){my$prefix=$name =~ /\.\w+\.\w+$/ ? 'templates' : 'public';$self->write_file($self->rel_file("$prefix/$name"),$all{$name})}}1;
MOJOLICIOUS_COMMAND_INFLATE

$fatpacked{"Mojolicious/Command/prefork.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_PREFORK';
  package Mojolicious::Command::prefork;use Mojo::Base 'Mojolicious::Command';use Getopt::Long qw(GetOptionsFromArray :config no_auto_abbrev no_ignore_case);use Mojo::Server::Prefork;has description=>'Start application with preforking HTTP and WebSocket server';has usage=>sub {shift->extract_usage};sub run {my ($self,@args)=@_;my$prefork=Mojo::Server::Prefork->new(app=>$self->app);GetOptionsFromArray \@args,'a|accepts=i'=>sub {$prefork->accepts($_[1])},'b|backlog=i'=>sub {$prefork->backlog($_[1])},'c|clients=i'=>sub {$prefork->max_clients($_[1])},'G|graceful-timeout=i'=>sub {$prefork->graceful_timeout($_[1])},'I|heartbeat-interval=i'=>sub {$prefork->heartbeat_interval($_[1])},'H|heartbeat-timeout=i'=>sub {$prefork->heartbeat_timeout($_[1])},'i|inactivity-timeout=i'=>sub {$prefork->inactivity_timeout($_[1])},'l|listen=s'=>\my@listen,'M|multi-accept=i'=>sub {$prefork->multi_accept($_[1])},'P|pid-file=s'=>sub {$prefork->pid_file($_[1])},'p|proxy'=>sub {$prefork->reverse_proxy(1)},'r|requests=i'=>sub {$prefork->max_requests($_[1])},'w|workers=i'=>sub {$prefork->workers($_[1])};$prefork->listen(\@listen)if@listen;$prefork->run}1;
MOJOLICIOUS_COMMAND_PREFORK

$fatpacked{"Mojolicious/Command/psgi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_PSGI';
  package Mojolicious::Command::psgi;use Mojo::Base 'Mojolicious::Command';use Mojo::Server::PSGI;has description=>'Start application with PSGI';has usage=>sub {shift->extract_usage};sub run {Mojo::Server::PSGI->new(app=>shift->app)->to_psgi_app}1;
MOJOLICIOUS_COMMAND_PSGI

$fatpacked{"Mojolicious/Command/routes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_ROUTES';
  package Mojolicious::Command::routes;use Mojo::Base 'Mojolicious::Command';use re 'regexp_pattern';use Getopt::Long qw(GetOptionsFromArray :config no_auto_abbrev no_ignore_case);use Mojo::Util qw(encode tablify);has description=>'Show available routes';has usage=>sub {shift->extract_usage};sub run {my ($self,@args)=@_;GetOptionsFromArray \@args,'v|verbose'=>\my$verbose;my$rows=[];_walk($_,0,$rows,$verbose)for @{$self->app->routes->children};print encode('UTF-8',tablify($rows))}sub _walk {my ($route,$depth,$rows,$verbose)=@_;my$prefix='';if (my$i=$depth * 2){$prefix .= ' ' x $i .'+'}push @$rows,my$row=[$prefix .($route->pattern->unparsed || '/')];my@flags;push@flags,@{$route->over || []}? 'C' : '.';push@flags,(my$partial=$route->partial)? 'D' : '.';push@flags,$route->inline ? 'U' : '.';push@flags,$route->is_websocket ? 'W' : '.';push @$row,join('',@flags)if$verbose;my$via=$route->via;push @$row,!$via ? '*' : uc join ',',@$via;my$name=$route->name;push @$row,$route->has_custom_name ? qq{"$name"} : $name;my$pattern=$route->pattern;$pattern->match('/',$route->is_endpoint &&!$partial);push @$row,(regexp_pattern$pattern->regex)[0]if$verbose;$depth++;_walk($_,$depth,$rows,$verbose)for @{$route->children};$depth--}1;
MOJOLICIOUS_COMMAND_ROUTES

$fatpacked{"Mojolicious/Command/test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_TEST';
  package Mojolicious::Command::test;use Mojo::Base 'Mojolicious::Command';use Getopt::Long qw(GetOptionsFromArray :config no_auto_abbrev no_ignore_case);has description=>'Run tests';has usage=>sub {shift->extract_usage};sub run {my ($self,@args)=@_;GetOptionsFromArray \@args,'v|verbose'=>\$ENV{HARNESS_VERBOSE};if (!@args && (my$home=$self->app->home)){die "Can't find test directory.\n" unless -d $home->rel_dir('t');my$files=$home->list_files('t');/\.t$/ and push@args,$home->rel_file("t/$_")for @$files;say qq{Running tests from "},$home->rel_dir('t').'".'}$ENV{HARNESS_OPTIONS}//= 'c';require Test::Harness;local$Test::Harness::switches='';Test::Harness::runtests(sort@args)}1;
MOJOLICIOUS_COMMAND_TEST

$fatpacked{"Mojolicious/Command/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMAND_VERSION';
  package Mojolicious::Command::version;use Mojo::Base 'Mojolicious::Command';use Mojo::IOLoop::Client;use Mojolicious;has description=>'Show versions of available modules';has usage=>sub {shift->extract_usage};sub run {my$self=shift;my$ev=eval 'use Mojo::Reactor::EV; 1' ? $EV::VERSION : 'n/a';my$class='Mojo::IOLoop::Client';my$socks=$class->SOCKS ? $IO::Socket::Socks::VERSION : 'n/a';my$tls=$class->TLS ? $IO::Socket::SSL::VERSION : 'n/a';my$ndn=$class->NDN ? $Net::DNS::Native::VERSION : 'n/a';print <<EOF;my$latest=eval {$self->app->ua->max_redirects(10)->tap(sub {$_->proxy->detect})->get('api.metacpan.org/v0/release/Mojolicious')->res->json->{version}}or return;my$msg='This version is up to date, have fun!';$msg='Thanks for testing a development release, you are awesome!' if$latest < $Mojolicious::VERSION;$msg="You might want to update your Mojolicious to $latest!" if$latest > $Mojolicious::VERSION;say$msg}1;
  CORE
    Perl        ($^V, $^O)
    Mojolicious ($Mojolicious::VERSION, $Mojolicious::CODENAME)
  
  OPTIONAL
    EV 4.0+                 ($ev)
    IO::Socket::Socks 0.64+ ($socks)
    IO::Socket::SSL 1.94+   ($tls)
    Net::DNS::Native 0.15+  ($ndn)
  
  EOF
MOJOLICIOUS_COMMAND_VERSION

$fatpacked{"Mojolicious/Commands.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_COMMANDS';
  package Mojolicious::Commands;use Mojo::Base 'Mojolicious::Command';use Getopt::Long 'GetOptionsFromArray';use Mojo::Loader qw(find_modules find_packages load_class);use Mojo::Server;use Mojo::Util 'tablify';has hint=><<EOF;has message=>sub {shift->extract_usage ."\nCommands:\n"};has namespaces=>sub {['Mojolicious::Command']};sub detect {return 'psgi' if defined$ENV{PLACK_ENV};return 'cgi' if defined$ENV{PATH_INFO}|| defined$ENV{GATEWAY_INTERFACE};return undef}sub run {my ($self,$name,@args)=@_;return$self->app if defined$ENV{MOJO_APP_LOADER};if (!$ENV{MOJO_NO_DETECT}&& (my$env=$self->detect)){$name=$env}if ($name && $name =~ /^\w+$/ && ($name ne 'help' || $args[0])){$name=shift@args if my$help=$name eq 'help';$help=$ENV{MOJO_HELP}||= $help;_args(\@args);my$module;$module=_command("${_}::$name",1)and last for @{$self->namespaces};die qq{Unknown command "$name", maybe you need to install it?\n} unless$module;my$command=$module->new(app=>$self->app);return$help ? $command->help(@args): $command->run(@args)}return 1 if$ENV{HARNESS_ACTIVE};my%all;for my$ns (@{$self->namespaces}){$all{substr $_,length "${ns}::"}//= $_->new->description for grep {_command($_)}find_modules($ns),find_packages($ns)}my@rows=map {[" $_",$all{$_}]}sort keys%all;return print$self->message,tablify(\@rows),$self->hint}sub start_app {shift;Mojo::Server->new->build_app(shift)->start(@_)}sub _args {return if __PACKAGE__->detect;my$save =Getopt::Long::Configure(qw(no_auto_abbrev no_ignore_case pass_through));GetOptionsFromArray shift,'h|help'=>\$ENV{MOJO_HELP},'home=s'=>\$ENV{MOJO_HOME},'m|mode=s'=>\$ENV{MOJO_MODE};Getopt::Long::Configure($save)}BEGIN {_args([@ARGV])}sub _command {my ($module,$fatal)=@_;return$module->isa('Mojolicious::Command')? $module : undef unless my$e=load_class$module;$fatal && ref$e ? die$e : return undef}1;
  
  See 'APPLICATION help COMMAND' for more information on a specific command.
  EOF
MOJOLICIOUS_COMMANDS

$fatpacked{"Mojolicious/Controller.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_CONTROLLER';
  package Mojolicious::Controller;use Mojo::Base -base;use Carp ();use Mojo::ByteStream;use Mojo::URL;use Mojo::Util;use Mojolicious::Routes::Match;use Scalar::Util ();use Time::HiRes ();has [qw(app tx)];has match=>sub {Mojolicious::Routes::Match->new(root=>shift->app->routes)};my%RESERVED=map {$_=>1}(qw(action app cb controller data extends format handler inline json layout),qw(namespace path status template text variant));sub AUTOLOAD {my$self=shift;my ($package,$method)=our$AUTOLOAD =~ /^(.+)::(.+)$/;Carp::croak "Undefined subroutine &${package}::$method called" unless Scalar::Util::blessed$self && $self->isa(__PACKAGE__);Carp::croak qq{Can't locate object method "$method" via package "$package"} unless my$helper=$self->app->renderer->get_helper($method);return$self->$helper(@_)}sub continue {$_[0]->app->routes->continue($_[0])}sub cookie {my ($self,$name)=(shift,shift);if (@_){my$cookie={name=>$name,value=>shift,%{shift || {}}};$self->app->log->error(qq{Cookie "$name" is bigger than 4096 bytes})if length$cookie->{value}> 4096;$self->res->cookies($cookie);return$self}return undef unless my$cookie=$self->req->cookie($name);return$cookie->value}sub every_cookie {[map {$_->value}@{shift->req->every_cookie(shift)}]}sub every_param {my ($self,$name)=@_;my$captures=$self->stash->{'mojo.captures'}||= {};if (!$RESERVED{$name}&& exists$captures->{$name}){my$value=$captures->{$name};return ref$value eq 'ARRAY' ? $value : [$value]}my$req=$self->req;my$uploads=$req->every_upload($name);return @$uploads ? $uploads : $req->every_param($name)}sub every_signed_cookie {my ($self,$name)=@_;my$secrets=$self->app->secrets;my@results;for my$value (@{$self->every_cookie($name)}){if ($value =~ s/--([^\-]+)$//){my$signature=$1;my$valid;for my$secret (@$secrets){my$check=Mojo::Util::hmac_sha1_sum($value,$secret);++$valid and last if Mojo::Util::secure_compare($signature,$check)}if ($valid){push@results,$value}else {$self->app->log->debug(qq{Cookie "$name" has a bad signature})}}else {$self->app->log->debug(qq{Cookie "$name" is not signed})}}return \@results}sub finish {my$self=shift;my$tx=$self->tx;$tx->finish(@_)and return$tx->established ? $self : $self->rendered(101)if$tx->is_websocket;return @_ ? $self->write_chunk(@_)->write_chunk(''): $self->write_chunk('')if$tx->res->content->is_chunked;return @_ ? $self->write(@_)->write(''): $self->write('')}sub flash {my$self=shift;my$session=$self->session;return$session->{flash}? $session->{flash}{$_[0]}: undef if @_==1 &&!ref $_[0];my$values=ref $_[0]? $_[0]: {@_};@{$session->{new_flash}||= {}}{keys %$values}=values %$values;return$self}sub helpers {$_[0]->app->renderer->get_helper('')->($_[0])}sub on {my ($self,$name,$cb)=@_;my$tx=$self->tx;$self->rendered(101)if$tx->is_websocket &&!$tx->established;return$tx->on($name=>sub {shift;$self->$cb(@_)})}sub param {my ($self,$name)=(shift,shift);return$self->every_param($name)->[-1]unless @_;$self->stash->{'mojo.captures'}{$name}=@_ > 1 ? [@_]: $_[0];return$self}sub redirect_to {my$self=shift;my$res=$self->res;$res->headers->location($self->url_for(@_));return$self->rendered($res->is_status_class(300)? (): 302)}sub render {my$self=shift;my ($template,$args)=(@_ % 2 ? shift : undef,{@_});$args->{template}=$template if$template;my$app=$self->app;my$plugins=$app->plugins->emit_hook(before_render=>$self,$args);my$maybe=delete$args->{'mojo.maybe'};my$ts=$args->{'mojo.string'};my ($output,$format)=$app->renderer->render($self,$args);return defined$output ? Mojo::ByteStream->new($output): undef if$ts;return$maybe ? undef :!$self->helpers->reply->not_found unless defined$output;$plugins->emit_hook(after_render=>$self,\$output,$format);my$headers=$self->res->body($output)->headers;$headers->content_type($app->types->type($format)|| 'text/plain')unless$headers->content_type;return!!$self->rendered($self->stash->{status})}sub render_later {shift->stash('mojo.rendered'=>1)}sub render_maybe {shift->render(@_,'mojo.maybe'=>1)}sub render_to_string {shift->render(@_,'mojo.string'=>1)}sub rendered {my ($self,$status)=@_;my$res=$self->res;$res->code($status || 200)if$status ||!$res->code;my$stash=$self->stash;if (!$stash->{'mojo.finished'}&& ++$stash->{'mojo.finished'}){my$app=$self->render_later->app;if (my$started=delete$stash->{'mojo.started'}){my$elapsed=sprintf '%f',Time::HiRes::tv_interval($started,[Time::HiRes::gettimeofday()]);my$rps=$elapsed==0 ? '??' : sprintf '%.3f',1 / $elapsed;my$code=$res->code;my$msg=$res->message || $res->default_message($code);$app->log->debug("$code $msg (${elapsed}s, $rps/s)")}$app->plugins->emit_hook_reverse(after_dispatch=>$self);$app->sessions->store($self)}$self->tx->resume;return$self}sub req {shift->tx->req}sub res {shift->tx->res}sub respond_to {my ($self,$args)=(shift,ref $_[0]? $_[0]: {@_});my$target;my$renderer=$self->app->renderer;my@formats=@{$renderer->accepts($self)};for my$format (@formats ? @formats : ($renderer->default_format)){next unless$target=$args->{$format};$self->stash->{format}=$format;last}unless ($target){return$self->rendered(204)unless$target=$args->{any};delete$self->stash->{format}}ref$target eq 'CODE' ? $target->($self): $self->render(%$target);return$self}sub send {my ($self,$msg,$cb)=@_;my$tx=$self->tx;Carp::croak 'No WebSocket connection to send message to' unless$tx->is_websocket;$tx->send($msg,$cb ? sub {shift;$self->$cb(@_)}: ());return$tx->established ? $self : $self->rendered(101)}sub session {my$self=shift;my$stash=$self->stash;$self->app->sessions->load($self)unless exists$stash->{'mojo.active_session'};my$session=$stash->{'mojo.session'}||= {};return$session unless @_;return$session->{$_[0]}unless @_ > 1 || ref $_[0];my$values=ref $_[0]? $_[0]: {@_};@$session{keys %$values}=values %$values;return$self}sub signed_cookie {my ($self,$name,$value,$options)=@_;return$self->every_signed_cookie($name)->[-1]unless defined$value;my$checksum=Mojo::Util::hmac_sha1_sum($value,$self->app->secrets->[0]);return$self->cookie($name,"$value--$checksum",$options)}sub stash {Mojo::Util::_stash(stash=>@_)}sub url_for {my$self=shift;my$target=shift // '';return$target if Scalar::Util::blessed$target && $target->isa('Mojo::URL');return Mojo::URL->new($target)if$target =~ m!^(?:[^:/?#]+:|//|#)!;my$url=Mojo::URL->new;my$req=$self->req;my$base=$url->base($req->url->base->clone)->base->userinfo(undef);my$path=$url->path;if ($target =~ m!^/!){if (defined(my$prefix=$self->stash->{path})){my$real=$req->url->path->to_route;$real =~ s!/?\Q$prefix\E$!$target!;$target=$real}$url->parse($target)}else {my$generated=$self->match->path_for($target,@_);$path->parse($generated->{path})if$generated->{path};$base->scheme($base->protocol eq 'https' ? 'wss' : 'ws')if$generated->{websocket}}my$base_path=$base->path;unshift @{$path->parts},@{$base_path->parts};$base_path->parts([])->trailing_slash(0);return$url}sub validation {my$self=shift;my$stash=$self->stash;return$stash->{'mojo.validation'}if$stash->{'mojo.validation'};my$req=$self->req;my$token=$self->session->{csrf_token};my$header=$req->headers->header('X-CSRF-Token');my$hash=$req->params->to_hash;$hash->{csrf_token}//= $header if$token && $header;$hash->{$_}=$req->every_upload($_)for map {$_->name}@{$req->uploads};my$validation=$self->app->validator->validation->input($hash);return$stash->{'mojo.validation'}=$validation->csrf_token($token)}sub write {my ($self,$chunk,$cb)=@_;$self->res->content->write($chunk,$cb ? sub {shift;$self->$cb(@_)}: ());return$self->rendered}sub write_chunk {my ($self,$chunk,$cb)=@_;my$content=$self->res->content;$content->write_chunk($chunk,$cb ? sub {shift;$self->$cb(@_)}: ());return$self->rendered}1;
MOJOLICIOUS_CONTROLLER

$fatpacked{"Mojolicious/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_LITE';
  package Mojolicious::Lite;use Mojo::Base 'Mojolicious';use File::Basename qw(basename dirname);use File::Spec::Functions 'catdir';use Mojo::UserAgent::Server;use Mojo::Util 'monkey_patch';sub import {$ENV{MOJO_EXE}||= (caller)[1];local$ENV{MOJO_HOME}=catdir split('/',dirname$ENV{MOJO_EXE})unless$ENV{MOJO_HOME};my$caller=caller;no strict 'refs';push @{"${caller}::ISA"},'Mojo';my$moniker=basename$ENV{MOJO_EXE};$moniker =~ s/\.(?:pl|pm|t)$//i;my$app=shift->new(moniker=>$moniker);my$routes=$app->routes->namespaces([]);$app->static->classes->[0]=$app->renderer->classes->[0]=$caller;my$root=$routes;for my$name (qw(any get options patch post put websocket)){monkey_patch$caller,$name,sub {$routes->$name(@_)}}monkey_patch$caller,$_,sub {$app}for qw(new app);monkey_patch$caller,del=>sub {$routes->delete(@_)};monkey_patch$caller,group=>sub (&) {(my$old,$root)=($root,$routes);shift->();($routes,$root)=($root,$old)};monkey_patch$caller,helper=>sub {$app->helper(@_)},hook=>sub {$app->hook(@_)},plugin=>sub {$app->plugin(@_)},under=>sub {$routes=$root->under(@_)};Mojo::UserAgent::Server->app($app)unless Mojo::UserAgent::Server->app;Mojo::Base->import(-strict)}1;
MOJOLICIOUS_LITE

$fatpacked{"Mojolicious/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN';
  package Mojolicious::Plugin;use Mojo::Base -base;use Carp 'croak';sub register {croak 'Method "register" not implemented by subclass'}1;
MOJOLICIOUS_PLUGIN

$fatpacked{"Mojolicious/Plugin/Charset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_CHARSET';
  package Mojolicious::Plugin::Charset;use Mojo::Base 'Mojolicious::Plugin';sub register {my ($self,$app,$conf)=@_;return unless my$c=$conf->{charset};$app->types->type(html=>"text/html;charset=$c");$app->renderer->encoding($c);$app->hook(before_dispatch=>sub {shift->req->default_charset($c)->url->query->charset($c)})}1;
MOJOLICIOUS_PLUGIN_CHARSET

$fatpacked{"Mojolicious/Plugin/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_CONFIG';
  package Mojolicious::Plugin::Config;use Mojo::Base 'Mojolicious::Plugin';use File::Spec::Functions 'file_name_is_absolute';use Mojo::Util qw(decode slurp);sub load {my ($self,$file,$conf,$app)=@_;$app->log->debug(qq{Reading configuration file "$file"});return$self->parse(decode('UTF-8',slurp$file),$file,$conf,$app)}sub parse {my ($self,$content,$file,$conf,$app)=@_;my$config=eval 'package Mojolicious::Plugin::Config::Sandbox; no warnings;' ."sub app; local *app = sub { \$app }; use Mojo::Base -strict; $content";die qq{Can't load configuration from file "$file": $@} if $@;die qq{Configuration file "$file" did not return a hash reference.\n} unless ref$config eq 'HASH';return$config}sub register {my ($self,$app,$conf)=@_;my$file=$conf->{file}|| $ENV{MOJO_CONFIG};$file ||= $app->moniker .'.' .($conf->{ext}|| 'conf');my$mode=$file =~ /^(.*)\.([^.]+)$/ ? join('.',$1,$app->mode,$2): '';my$home=$app->home;$file=$home->rel_file($file)unless file_name_is_absolute$file;$mode=$home->rel_file($mode)if$mode &&!file_name_is_absolute$mode;$mode=undef unless$mode && -e $mode;my$config={};if (-e $file){$config=$self->load($file,$conf,$app)}elsif (!$conf->{default}&&!$mode){die qq{Configuration file "$file" missing, maybe you need to create it?\n}}$config={%$config,%{$self->load($mode,$conf,$app)}}if$mode;$config={%{$conf->{default}},%$config}if$conf->{default};return$app->defaults(config=>$app->config)->config($config)->config}1;
MOJOLICIOUS_PLUGIN_CONFIG

$fatpacked{"Mojolicious/Plugin/DefaultHelpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_DEFAULTHELPERS';
  package Mojolicious::Plugin::DefaultHelpers;use Mojo::Base 'Mojolicious::Plugin';use Mojo::ByteStream;use Mojo::Collection;use Mojo::Exception;use Mojo::IOLoop;use Mojo::Util qw(dumper hmac_sha1_sum steady_time);sub register {my ($self,$app)=@_;for my$name (qw(app flash param stash session url_for validation)){$app->helper($name=>sub {shift->$name(@_)})}for my$name (qw(extends layout title)){$app->helper($name=>sub {shift->stash($name,@_)})}$app->helper(accepts=>sub {$_[0]->app->renderer->accepts(@_)});$app->helper(b=>sub {shift;Mojo::ByteStream->new(@_)});$app->helper(c=>sub {shift;Mojo::Collection->new(@_)});$app->helper(config=>sub {shift->app->config(@_)});$app->helper(content=>sub {_content(0,0,@_)});$app->helper(content_for=>sub {_content(1,0,@_)});$app->helper(content_with=>sub {_content(0,1,@_)});$app->helper($_=>$self->can("_$_"))for qw(csrf_token current_route delay inactivity_timeout is_fresh url_with);$app->helper(dumper=>sub {shift;dumper @_});$app->helper(include=>sub {shift->render_to_string(@_)});$app->helper("reply.$_"=>$self->can("_$_"))for qw(asset static);$app->helper('reply.exception'=>sub {_development('exception',@_)});$app->helper('reply.not_found'=>sub {_development('not_found',@_)});$app->helper(ua=>sub {shift->app->ua})}sub _asset {my$c=shift;$c->app->static->serve_asset($c,@_);$c->rendered}sub _block {ref $_[0]eq 'CODE' ? $_[0](): $_[0]}sub _content {my ($append,$replace,$c,$name,$content)=@_;$name ||= 'content';my$hash=$c->stash->{'mojo.content'}||= {};if (defined$content){if ($append){$hash->{$name}.= _block($content)}if ($replace){$hash->{$name}=_block($content)}else {$hash->{$name}//= _block($content)}}return Mojo::ByteStream->new($hash->{$name}// '')}sub _csrf_token {my$c=shift;return$c->session->{csrf_token}||= hmac_sha1_sum($$ .steady_time .rand 999,$c->app->secrets->[0])}sub _current_route {return '' unless my$route=shift->match->endpoint;return @_ ? $route->name eq shift : $route->name}sub _delay {my$c=shift;my$tx=$c->render_later->tx;my$delay=Mojo::IOLoop->delay(@_);$delay->catch(sub {$c->helpers->reply->exception(pop)and undef$tx})->wait}sub _development {my ($page,$c,$e)=@_;my$app=$c->app;$app->log->error($e=Mojo::Exception->new($e))if$page eq 'exception';my$stash=$c->stash;my%snapshot=map {$_=>$stash->{$_}}grep {!/^mojo\./ and defined$stash->{$_}}keys %$stash;my$mode=$app->mode;my$renderer=$app->renderer;my$options={exception=>$page eq 'exception' ? $e : undef,format=>$stash->{format}|| $renderer->default_format,handler=>undef,snapshot=>\%snapshot,status=>$page eq 'exception' ? 500 : 404,template=>"$page.$mode" };my$bundled='mojo/' .($mode eq 'development' ? 'debug' : $page);return$c if _fallbacks($c,$options,$page,$bundled);_fallbacks($c,{%$options,format=>'html'},$page,$bundled);return$c}sub _fallbacks {my ($c,$options,$template,$bundled)=@_;return 1 if$c->render_maybe(%$options);return 1 if$c->render_maybe(%$options,template=>$template);my$stash=$c->stash;return undef unless$stash->{format}eq 'html';delete @$stash{qw(extends layout)};return$c->render_maybe($bundled,%$options,handler=>'ep')}sub _inactivity_timeout {my ($c,$timeout)=@_;my$stream=Mojo::IOLoop->stream($c->tx->connection // '');$stream->timeout($timeout)if$stream;return$c}sub _is_fresh {my ($c,%options)=@_;return$c->app->static->is_fresh($c,\%options)}sub _static {my ($c,$file)=@_;return!!$c->rendered if$c->app->static->serve($c,$file);$c->app->log->debug(qq{Static file "$file" not found});return!$c->helpers->reply->not_found}sub _url_with {my$c=shift;return$c->url_for(@_)->query($c->req->url->query->clone)}1;
MOJOLICIOUS_PLUGIN_DEFAULTHELPERS

$fatpacked{"Mojolicious/Plugin/EPLRenderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_EPLRENDERER';
  package Mojolicious::Plugin::EPLRenderer;use Mojo::Base 'Mojolicious::Plugin';use Mojo::Template;use Mojo::Util qw(encode md5_sum);sub register {$_[1]->renderer->add_handler(epl=>\&_epl)}sub _epl {my ($renderer,$c,$output,$options)=@_;my$mt=delete$options->{'mojo.template'}|| Mojo::Template->new;my$log=$c->app->log;if ($mt->compiled){$log->debug("Rendering cached @{[$mt->name]}");$$output=$mt->interpret($c)}else {my$inline=$options->{inline};my$name=defined$inline ? md5_sum encode('UTF-8',$inline): undef;return unless defined($name //= $renderer->template_name($options));if (defined$inline){$log->debug(qq{Rendering inline template "$name"});$$output=$mt->name(qq{inline template "$name"})->render($inline,$c)}else {if (my$encoding=$renderer->encoding){$mt->encoding($encoding)}if (defined(my$path=$renderer->template_path($options))){$log->debug(qq{Rendering template "$name"});$$output=$mt->name(qq{template "$name"})->render_file($path,$c)}elsif (my$d=$renderer->get_data_template($options)){$log->debug(qq{Rendering template "$name" from DATA section});$$output =$mt->name(qq{template "$name" from DATA section})->render($d,$c)}else {$log->debug(qq{Template "$name" not found})}}}die $$output if ref $$output}1;
MOJOLICIOUS_PLUGIN_EPLRENDERER

$fatpacked{"Mojolicious/Plugin/EPRenderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_EPRENDERER';
  package Mojolicious::Plugin::EPRenderer;use Mojo::Base 'Mojolicious::Plugin';use Mojo::Template;use Mojo::Util qw(encode md5_sum monkey_patch);sub DESTROY {Mojo::Util::_teardown(shift->{namespace})}sub register {my ($self,$app,$conf)=@_;my$template={auto_escape=>1,%{$conf->{template}|| {}}};my$ns=$self->{namespace}=$template->{namespace}//= 'Mojo::Template::Sandbox::' .md5_sum "$self";$app->renderer->default_handler('ep')->add_handler($conf->{name}|| 'ep'=>sub {my ($renderer,$c,$output,$options)=@_;my$name=$options->{inline}// $renderer->template_name($options);return unless defined$name;my@keys=sort grep {/^\w+$/}keys %{$c->stash};my$key=md5_sum encode 'UTF-8',join(',',$name,@keys);my$cache=$renderer->cache;unless ($options->{'mojo.template'}=$cache->get($key)){my$mt=$options->{'mojo.template'}=Mojo::Template->new($template);++$self->{helpers}and _helpers($ns,$renderer->helpers)unless$self->{helpers};my$prepend='my $self = my $c = shift; my $_S = $c->stash; {';$prepend .= join '',map {" my \$$_ = \$_S->{'$_'};"}@keys;$mt->prepend($prepend .$mt->prepend)->append(';}' .$mt->append);$cache->set($key=>$mt)}no strict 'refs';no warnings 'redefine';local *{"${ns}::_C"}=sub {$c};$renderer->handlers->{epl}($renderer,$c,$output,$options)})}sub _helpers {my ($class,$helpers)=@_;for my$method (grep {/^\w+$/}keys %$helpers){my$sub=$helpers->{$method};monkey_patch$class,$method,sub {$class->_C->$sub(@_)}}}1;
MOJOLICIOUS_PLUGIN_EPRENDERER

$fatpacked{"Mojolicious/Plugin/HeaderCondition.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_HEADERCONDITION';
  package Mojolicious::Plugin::HeaderCondition;use Mojo::Base 'Mojolicious::Plugin';sub register {my ($self,$app)=@_;$app->routes->add_condition(headers=>\&_headers);$app->routes->add_condition(agent=>sub {_headers(@_[0 .. 2],{'User-Agent'=>$_[3]})});$app->routes->add_condition(host=>sub {_check($_[1]->req->url->to_abs->host,$_[3])})}sub _check {my ($value,$pattern)=@_;return 1 if$value && $pattern && ref$pattern eq 'Regexp' && $value =~ $pattern;return$value && defined$pattern && $pattern eq $value}sub _headers {my ($route,$c,$captures,$patterns)=@_;return undef unless$patterns && ref$patterns eq 'HASH' && keys %$patterns;my$headers=$c->req->headers;_check($headers->header($_),$patterns->{$_})|| return undef for keys %$patterns;return 1}1;
MOJOLICIOUS_PLUGIN_HEADERCONDITION

$fatpacked{"Mojolicious/Plugin/JSONConfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_JSONCONFIG';
  package Mojolicious::Plugin::JSONConfig;use Mojo::Base 'Mojolicious::Plugin::Config';use Mojo::JSON 'from_json';use Mojo::Template;sub parse {my ($self,$content,$file,$conf,$app)=@_;my$config=eval {from_json$self->render($content,$file,$conf,$app)};die qq{Can't parse config "$file": $@} if $@;die qq{Invalid config "$file"} unless ref$config eq 'HASH';return$config}sub register {shift->SUPER::register(shift,{ext=>'json',%{shift()}})}sub render {my ($self,$content,$file,$conf,$app)=@_;my$prepend=q[no strict 'refs'; no warnings 'redefine';];$prepend .= q[my $app = shift; sub app; local *app = sub { $app };];$prepend .= q[use Mojo::Base -strict; no warnings 'ambiguous';];my$mt=Mojo::Template->new($conf->{template}|| {})->name($file);my$output=$mt->prepend($prepend .$mt->prepend)->render($content,$app);return ref$output ? die$output : $output}1;
MOJOLICIOUS_PLUGIN_JSONCONFIG

$fatpacked{"Mojolicious/Plugin/Mount.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_MOUNT';
  package Mojolicious::Plugin::Mount;use Mojo::Base 'Mojolicious::Plugin';use Mojo::Server;sub register {my ($self,$app,$conf)=@_;my$path=(keys %$conf)[0];my$embed=Mojo::Server->new->load_app($conf->{$path});$embed->secrets($app->secrets);my$host;($host,$path)=($1 ? qr/^(?:.*\.)?\Q$2\E$/i : qr/^\Q$2\E$/i,$3)if$path =~ m!^(\*\.)?([^/]+)(/.*)?$!;my$route=$app->routes->route($path)->detour(app=>$embed);return$host ? $route->over(host=>$host): $route}1;
MOJOLICIOUS_PLUGIN_MOUNT

$fatpacked{"Mojolicious/Plugin/PODRenderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_PODRENDERER';
  package Mojolicious::Plugin::PODRenderer;use Mojo::Base 'Mojolicious::Plugin';use Mojo::Asset::File;use Mojo::ByteStream;use Mojo::DOM;use Mojo::URL;use Mojo::Util 'slurp';use Pod::Simple::XHTML;use Pod::Simple::Search;sub register {my ($self,$app,$conf)=@_;my$preprocess=$conf->{preprocess}|| 'ep';$app->renderer->add_handler($conf->{name}|| 'pod'=>sub {my ($renderer,$c,$output,$options)=@_;$renderer->handlers->{$preprocess}($renderer,$c,$output,$options);$$output=_pod_to_html($$output)if defined $$output});$app->helper(pod_to_html=>sub {shift;Mojo::ByteStream->new(_pod_to_html(@_))});return undef if$conf->{no_perldoc};my$defaults={module=>'Mojolicious/Guides',format=>'html'};return$app->routes->any('/perldoc/:module'=>$defaults=>[module=>qr/[^.]+/]=>\&_perldoc)}sub _indentation {(sort map {/^(\s+)/}@{shift()})[0]}sub _html {my ($c,$src)=@_;my$dom=Mojo::DOM->new(_pod_to_html($src));my$perldoc=$c->url_for('/perldoc/');$_->{href}=~ s!^https://metacpan\.org/pod/!$perldoc! and $_->{href}=~ s!::!/!gi for$dom->find('a[href]')->map('attr')->each;for my$e ($dom->find('pre > code')->each){my$str=$e->content;next if$str =~ /^\s*(?:\$|Usage:)\s+/m || $str !~ /[\$\@\%]\w|-&gt;\w/m;my$attrs=$e->attr;my$class=$attrs->{class};$attrs->{class}=defined$class ? "$class prettyprint" : 'prettyprint'}my$toc=Mojo::URL->new->fragment('toc');my@parts;for my$e ($dom->find('h1, h2, h3, h4')->each){push@parts,[]if$e->tag eq 'h1' ||!@parts;my$link=Mojo::URL->new->fragment($e->{id});push @{$parts[-1]},my$text=$e->all_text,$link;my$permalink=$c->link_to('#'=>$link,class=>'permalink');$e->content($permalink .$c->link_to($text=>$toc))}my$title='Perldoc';$dom->find('h1 + p')->first(sub {$title=shift->text});$c->content_for(perldoc=>"$dom");$c->render('mojo/perldoc',title=>$title,parts=>\@parts)}sub _perldoc {my$c=shift;my$module=join '::',split('/',$c->param('module'));my$path =Pod::Simple::Search->new->find($module,map {$_,"$_/pods"}@INC);return$c->redirect_to("https://metacpan.org/pod/$module")unless$path && -r $path;my$src=slurp$path;$c->respond_to(txt=>{data=>$src},html=>sub {_html($c,$src)})}sub _pod_to_html {return '' unless defined(my$pod=ref $_[0]eq 'CODE' ? shift->(): shift);my$parser=Pod::Simple::XHTML->new;$parser->perldoc_url_prefix('https://metacpan.org/pod/');$parser->$_('')for qw(html_header html_footer);$parser->strip_verbatim_indent(\&_indentation);$parser->output_string(\(my$output));return $@ unless eval {$parser->parse_string_document("$pod");1};return$output}1;
MOJOLICIOUS_PLUGIN_PODRENDERER

$fatpacked{"Mojolicious/Plugin/TagHelpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGIN_TAGHELPERS';
  package Mojolicious::Plugin::TagHelpers;use Mojo::Base 'Mojolicious::Plugin';use Mojo::ByteStream;use Mojo::DOM::HTML;use Scalar::Util 'blessed';sub register {my ($self,$app)=@_;my@time=qw(date datetime month time week);for my$name (@time,qw(color email number range search tel text url)){$app->helper("${name}_field"=>sub {_input(@_,type=>$name)})}my@helpers=(qw(csrf_field form_for hidden_field javascript label_for link_to),qw(select_field stylesheet submit_button tag_with_error text_area));$app->helper($_=>__PACKAGE__->can("_$_"))for@helpers;$app->helper(check_box=>sub {_input(shift,shift,value=>shift,@_,type=>'checkbox')});$app->helper(file_field=>sub {_empty_field('file',@_)});$app->helper(image=>sub {_tag('img',src=>shift->url_for(shift),@_)});$app->helper(input_tag=>sub {_input(@_)});$app->helper(password_field=>sub {_empty_field('password',@_)});$app->helper(radio_button=>sub {_input(shift,shift,value=>shift,@_,type=>'radio')});$app->helper($_=>sub {shift;_tag(@_)})for qw(t tag)}sub _csrf_field {my$c=shift;return _hidden_field($c,csrf_token=>$c->helpers->csrf_token,@_)}sub _empty_field {my ($type,$c,$name)=(shift,shift,shift);return _validation($c,$name,'input',name=>$name,@_,type=>$type)}sub _form_for {my ($c,@url)=(shift,shift);push@url,shift if ref $_[0]eq 'HASH';my$r=$c->app->routes->lookup($url[0]);my$method=$r ? $r->suggested_method : 'GET';my@post=$method ne 'GET' ? (method=>'POST'): ();my$url=$c->url_for(@url);$url->query({_method=>$method})if@post && $method ne 'POST';return _tag('form',action=>$url,@post,@_)}sub _hidden_field {my$c=shift;return _tag('input',name=>shift,value=>shift,@_,type=>'hidden')}sub _input {my ($c,$name)=(shift,shift);my%attrs=@_ % 2 ? (value=>shift,@_): @_;my@values=@{$c->every_param($name)};my$type=$attrs{type}|| '';if (@values && $type ne 'submit'){my$value=$attrs{value}// '';if ($type eq 'checkbox' || $type eq 'radio'){$attrs{value}=$value;delete$attrs{checked}if@values;$attrs{checked}=undef if grep {$_ eq $value}@values}else {$attrs{value}=$values[-1]}}return _validation($c,$name,'input',name=>$name,%attrs)}sub _javascript {my$c=shift;my$content =ref $_[-1]eq 'CODE' ? "//<![CDATA[\n" .pop->()."\n//]]>" : '';my@src=@_ % 2 ? (src=>$c->url_for(shift)): ();return _tag('script',@src,@_,sub {$content})}sub _label_for {my ($c,$name)=(shift,shift);my$content=ref $_[-1]eq 'CODE' ? pop : shift;return _validation($c,$name,'label',for=>$name,@_,$content)}sub _link_to {my ($c,$content)=(shift,shift);my@url=($content);unless (ref $_[-1]eq 'CODE'){@url=(shift);push @_,$content}push@url,shift if ref $_[0]eq 'HASH';return _tag('a',href=>$c->url_for(@url),@_)}sub _option {my ($values,$pair)=@_;$pair=[$pair=>$pair]unless ref$pair eq 'ARRAY';my%attrs=(value=>$pair->[1],@$pair[2 .. $#$pair]);delete$attrs{selected}if keys %$values;$attrs{selected}=undef if$values->{$pair->[1]};return _tag('option',%attrs,$pair->[0])}sub _select_field {my ($c,$name,$options,%attrs)=(shift,shift,shift,@_);my%values=map {$_=>1}@{$c->every_param($name)};my$groups='';for my$group (@$options){if (blessed$group && $group->isa('Mojo::Collection')){my ($label,$values,%attrs)=@$group;my$content=join '',map {_option(\%values,$_)}@$values;$groups .= _tag('optgroup',label=>$label,%attrs,sub {$content})}else {$groups .= _option(\%values,$group)}}return _validation($c,$name,'select',name=>$name,%attrs,sub {$groups})}sub _stylesheet {my$c=shift;my$content =ref $_[-1]eq 'CODE' ? "/*<![CDATA[*/\n" .pop->()."\n/*]]>*/" : '';return _tag('style',@_,sub {$content})unless @_ % 2;return _tag('link',rel=>'stylesheet',href=>$c->url_for(shift),@_)}sub _submit_button {my$c=shift;return _tag('input',value=>shift // 'Ok',@_,type=>'submit')}sub _tag {my$tree=['tag',shift,undef,undef];if (ref $_[-1]eq 'CODE'){push @$tree,['raw',pop->()]}elsif (@_ % 2){push @$tree,['text',pop]}my$attrs=$tree->[2]={@_};if ($attrs->{data}&& ref$attrs->{data}eq 'HASH'){while (my ($key,$value)=each %{$attrs->{data}}){$key =~ y/_/-/;$attrs->{lc "data-$key"}=$value}delete$attrs->{data}}return Mojo::ByteStream->new(Mojo::DOM::HTML::_render($tree))}sub _tag_with_error {my ($c,$tag)=(shift,shift);my ($content,%attrs)=(@_ % 2 ? pop : undef,@_);$attrs{class}.= $attrs{class}? ' field-with-error' : 'field-with-error';return _tag($tag,%attrs,defined$content ? $content : ())}sub _text_area {my ($c,$name)=(shift,shift);my$cb=ref $_[-1]eq 'CODE' ? pop : undef;my$content=@_ % 2 ? shift : undef;$content=$c->param($name)// $content // $cb // '';return _validation($c,$name,'textarea',name=>$name,@_,$content)}sub _validation {my ($c,$name)=(shift,shift);return _tag(@_)unless$c->validation->has_error($name);return$c->helpers->tag_with_error(@_)}1;
MOJOLICIOUS_PLUGIN_TAGHELPERS

$fatpacked{"Mojolicious/Plugins.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_PLUGINS';
  package Mojolicious::Plugins;use Mojo::Base 'Mojo::EventEmitter';use Mojo::Loader 'load_class';use Mojo::Util 'camelize';has namespaces=>sub {['Mojolicious::Plugin']};sub emit_chain {my ($self,$name,@args)=@_;my$wrapper;for my$cb (reverse @{$self->subscribers($name)}){my$next=$wrapper;$wrapper=sub {$cb->($next,@args)}}!$wrapper ? return : return$wrapper->()}sub emit_hook {my$self=shift;for my$cb (@{$self->subscribers(shift)}){$cb->(@_)}return$self}sub emit_hook_reverse {my$self=shift;for my$cb (reverse @{$self->subscribers(shift)}){$cb->(@_)}return$self}sub load_plugin {my ($self,$name)=@_;my$suffix=$name =~ /^[a-z]/ ? camelize$name : $name;my@classes=map {"${_}::$suffix"}@{$self->namespaces};for my$class (@classes,$name){return$class->new if _load($class)}die qq{Plugin "$name" missing, maybe you need to install it?\n}}sub register_plugin {shift->load_plugin(shift)->register(shift,ref $_[0]? $_[0]: {@_})}sub _load {my$module=shift;return$module->isa('Mojolicious::Plugin')unless my$e=load_class$module;ref$e ? die$e : return undef}1;
MOJOLICIOUS_PLUGINS

$fatpacked{"Mojolicious/Renderer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_RENDERER';
  package Mojolicious::Renderer;use Mojo::Base -base;use File::Spec::Functions 'catfile';use Mojo::Cache;use Mojo::JSON 'encode_json';use Mojo::Home;use Mojo::Loader 'data_section';use Mojo::Util qw(decamelize encode md5_sum monkey_patch slurp);has cache=>sub {Mojo::Cache->new};has classes=>sub {['main']};has default_format=>'html';has 'default_handler';has encoding=>'UTF-8';has handlers=>sub {{data=>sub {${$_[2]}=$_[3]{data}},text=>sub {${$_[2]}=$_[3]{text}},json=>sub {${$_[2]}=encode_json($_[3]{json})}}};has helpers=>sub {{}};has paths=>sub {[]};my$TEMPLATES=Mojo::Home->new(Mojo::Home->new->mojo_lib_dir)->rel_dir('Mojolicious/resources/templates');sub DESTROY {Mojo::Util::_teardown($_)for @{shift->{namespaces}}}sub accepts {my ($self,$c)=(shift,shift);my$req=$c->req;my@exts=@{$c->app->types->detect($req->headers->accept,$req->is_xhr)};if (!@exts && (my$format=$c->stash->{format}|| $req->param('format'))){push@exts,$format}return \@exts unless @_;for my$ext (@exts){return$ext if grep {$ext eq $_}@_}return@exts ? undef : shift}sub add_handler {$_[0]->handlers->{$_[1]}=$_[2]and return $_[0]}sub add_helper {my ($self,$name,$cb)=@_;$self->helpers->{$name}=$cb;delete$self->{proxy};return$self}sub get_data_template {my ($self,$options)=@_;return undef unless my$template=$self->template_name($options);return data_section$self->{index}{$template},$template}sub get_helper {my ($self,$name)=@_;if (my$h=$self->{proxy}{$name}|| $self->helpers->{$name}){return$h}my$found;my$class='Mojolicious::Renderer::Helpers::' .md5_sum "$name:$self";my$re=$name eq '' ? qr/^(([^.]+))/ : qr/^(\Q$name\E\.([^.]+))/;for my$key (keys %{$self->helpers}){$key =~ $re ? ($found,my$method)=(1,$2): next;my$sub=$self->get_helper($1);monkey_patch$class,$method=>sub {${shift()}->$sub(@_)}}$found ? push @{$self->{namespaces}},$class : return undef;return$self->{proxy}{$name}=sub {bless \(my$dummy=shift),$class}}sub render {my ($self,$c,$args)=@_;my$stash=$c->stash;local$stash->{layout}=$stash->{layout}if exists$stash->{layout};local$stash->{extends}=$stash->{extends}if exists$stash->{extends};local @{$stash}{keys %$args}if my$string=delete$args->{'mojo.string'};delete @{$stash}{qw(layout extends)}if$string;@$stash{keys %$args}=values %$args;my$options={encoding=>$self->encoding,handler=>$stash->{handler},template=>delete$stash->{template},variant=>$stash->{variant}};my$inline=$options->{inline}=delete$stash->{inline};$options->{handler}//= $self->default_handler if defined$inline;$options->{format}=$stash->{format}|| $self->default_format;my$output;if (defined(my$data=delete$stash->{data})){$self->handlers->{data}($self,$c,\$output,{data=>$data});return$output,$options->{format}}elsif (exists$stash->{json}){my$json=delete$stash->{json};$self->handlers->{json}($self,$c,\$output,{json=>$json});return$output,'json'}elsif (defined(my$text=delete$stash->{text})){$self->handlers->{text}($self,$c,\$output,{text=>$text})}else {$options->{template}||= $self->template_for($c);return ()unless$self->_render_template($c,\$output,$options)}my$content=$stash->{'mojo.content'}||= {};local$content->{content}=$output if$stash->{extends}|| $stash->{layout};while ((my$next=_next($stash))&&!defined$inline){@$options{qw(handler template)}=($stash->{handler},$next);$options->{format}=$stash->{format}|| $self->default_format;my$layout;$output=$layout if$self->_render_template($c,\$layout,$options);$content->{content}=$output if$content->{content}!~ /\S/ && $output =~ /\S/}$output=encode$options->{encoding},$output if!$string && $options->{encoding}&& $output;return$output,$options->{format}}sub template_for {my ($self,$c)=@_;my$stash=$c->stash;my ($controller,$action)=@$stash{qw(controller action)};return join '/',split('-',decamelize$controller),$action if$controller && $action;return undef unless my$route=$c->match->endpoint;return$route->name}sub template_handler {my ($self,$options)=@_;return undef unless my$file=$self->template_name($options);return$self->default_handler unless my$handlers=$self->{templates}{$file};return$handlers->[0]}sub template_name {my ($self,$options)=@_;return undef unless my$template=$options->{template};return undef unless my$format=$options->{format};$template .= ".$format";$self->warmup unless$self->{templates};my$handler=$options->{handler};if (defined(my$variant=$options->{variant})){$variant="$template+$variant";my$handlers=$self->{templates}{$variant}// [];$template=$variant if @$handlers &&!defined$handler || grep {$_ eq $handler}@$handlers}return defined$handler ? "$template.$handler" : $template}sub template_path {my$self=shift;return undef unless my$name=$self->template_name(shift);for my$path (@{$self->paths},$TEMPLATES){my$file=catfile$path,split('/',$name);return$file if -r $file}return undef}sub warmup {my$self=shift;my ($index,$templates)=@$self{qw(index templates)}=({},{});s/\.(\w+)$// and push @{$templates->{$_}},$1 for map {sort @{Mojo::Home->new($_)->list_files}}@{$self->paths},$TEMPLATES;for my$class (reverse @{$self->classes}){$index->{$_}=$class for my@keys=sort keys %{data_section$class};s/\.(\w+)$// and unshift @{$templates->{$_}},$1 for reverse@keys}}sub _next {my$stash=shift;return delete$stash->{extends}if$stash->{extends};return undef unless my$layout=delete$stash->{layout};return join '/','layouts',$layout}sub _render_template {my ($self,$c,$output,$options)=@_;my$handler=$options->{handler}||= $self->template_handler($options);return undef unless$handler;$c->app->log->error(qq{No handler for "$handler" available})and return undef unless my$renderer=$self->handlers->{$handler};$renderer->($self,$c,$output,$options);return 1 if defined $$output}1;
MOJOLICIOUS_RENDERER

$fatpacked{"Mojolicious/Routes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES';
  package Mojolicious::Routes;use Mojo::Base 'Mojolicious::Routes::Route';use List::Util 'first';use Mojo::Cache;use Mojo::Loader 'load_class';use Mojo::Util 'camelize';use Mojolicious::Routes::Match;use Scalar::Util 'weaken';has base_classes=>sub {[qw(Mojolicious::Controller Mojo)]};has cache=>sub {Mojo::Cache->new};has [qw(conditions shortcuts)]=>sub {{}};has hidden=>sub {[qw(attr has new tap)]};has namespaces=>sub {[]};sub add_condition {$_[0]->conditions->{$_[1]}=$_[2]and return $_[0]}sub add_shortcut {$_[0]->shortcuts->{$_[1]}=$_[2]and return $_[0]}sub continue {my ($self,$c)=@_;my$match=$c->match;my$stack=$match->stack;my$position=$match->position;return _render($c)unless my$field=$stack->[$position];my$stash=$c->stash;@{$stash->{'mojo.captures'}//= {}}{keys %$field}=values %$field;@$stash{keys %$field}=values %$field;my$continue;my$last=!$stack->[++$position];if (my$cb=$field->{cb}){$continue=$self->_callback($c,$cb,$last)}else {$continue=$self->_controller($c,$field,$last)}$match->position($position);$self->continue($c)if$last || $continue}sub dispatch {my ($self,$c)=@_;$self->match($c);@{$c->match->stack}? $self->continue($c): return undef;return 1}sub hide {push @{shift->hidden},@_}sub is_hidden {my ($self,$method)=@_;my$h=$self->{hiding}||= {map {$_=>1}@{$self->hidden}};return!!($h->{$method}|| index($method,'_')==0 || $method !~ /[a-z]/)}sub lookup {my ($self,$name)=@_;my$reverse=$self->{reverse}||= {};return$reverse->{$name}if exists$reverse->{$name};return undef unless my$route=$self->find($name);return$reverse->{$name}=$route}sub match {my ($self,$c)=@_;my$req=$c->req;my$path=$c->stash->{path};if (defined$path){$path="/$path" if$path !~ m!^/!}else {$path=$req->url->path->to_route}my$method=uc($req->url->query->clone->param('_method')|| $req->method);$method='GET' if$method eq 'HEAD';my$ws=$c->tx->is_websocket ? 1 : 0;my$match=Mojolicious::Routes::Match->new(root=>$self);$c->match($match);my$cache=$self->cache;if (my$result=$cache->get("$method:$path:$ws")){return$match->endpoint($result->{endpoint})->stack($result->{stack})}$match->find($c=>{method=>$method,path=>$path,websocket=>$ws});return unless my$route=$match->endpoint;$cache->set("$method:$path:$ws"=>{endpoint=>$route,stack=>$match->stack})}sub _action {shift->plugins->emit_chain(around_action=>@_)}sub _callback {my ($self,$c,$cb,$last)=@_;$c->stash->{'mojo.routed'}=1 if$last;my$app=$c->app;$app->log->debug('Routing to a callback');return _action($app,$c,$cb,$last)}sub _class {my ($self,$c,$field)=@_;return$field->{app}if ref$field->{app};my@classes;my$class=$field->{controller}? camelize$field->{controller}: '';if ($field->{app}){push@classes,$field->{app}}elsif (defined(my$ns=$field->{namespace})){if ($class){push@classes,$ns ? "${ns}::$class" : $class}elsif ($ns){push@classes,$ns}}elsif ($class){push@classes,"${_}::$class" for @{$self->namespaces}}my$log=$c->app->log;for my$class (@classes){next unless defined(my$found=$self->_load($class));return!$log->debug(qq{Class "$class" is not a controller})unless$found;my$new=$class->new(%$c);weaken$new->{$_}for qw(app tx);return$new}$log->debug(qq{Controller "$classes[-1]" does not exist})if@classes;return@classes ? undef : 0}sub _controller {my ($self,$old,$field,$last)=@_;my$new;unless ($new=$self->_class($old,$field)){return!!defined$new}my$class=ref$new;my$app=$old->app;my$log=$app->log;if ($new->isa('Mojo')){$log->debug(qq{Routing to application "$class"});if (my$sub=$new->can('routes')){my$r=$new->$sub;weaken$r->parent($old->match->endpoint)->{parent}unless$r->parent}$new->handler($old);$old->stash->{'mojo.routed'}=1}elsif (my$method=$field->{action}){if (!$self->is_hidden($method)){$log->debug(qq{Routing to controller "$class" and action "$method"});if (my$sub=$new->can($method)){$old->stash->{'mojo.routed'}=1 if$last;return 1 if _action($app,$new,$sub,$last)}else {$log->debug('Action not found in controller')}}else {$log->debug(qq{Action "$method" is not allowed})}}return undef}sub _load {my ($self,$app)=@_;return 1 if$self->{loaded}{$app};if (my$e=load_class$app){ref$e ? die$e : return undef}return 0 unless first {$app->isa($_)}@{$self->base_classes};return$self->{loaded}{$app}=1}sub _render {my$c=shift;my$stash=$c->stash;return if$stash->{'mojo.rendered'};$c->render_maybe or $stash->{'mojo.routed'}or $c->helpers->reply->not_found}1;
MOJOLICIOUS_ROUTES

$fatpacked{"Mojolicious/Routes/Match.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES_MATCH';
  package Mojolicious::Routes::Match;use Mojo::Base -base;use Mojo::Util;has [qw(endpoint root)];has position=>0;has stack=>sub {[]};sub find {$_[0]->_match($_[0]->root,$_[1],$_[2])}sub path_for {my ($self,$name,%values)=(shift,Mojo::Util::_options(@_));my$route;if (!$name || $name eq 'current'){return {}unless$route=$self->endpoint}else {return {path=>$name}unless$route=$self->root->lookup($name)}my$captures=$self->stack->[-1]|| {};%values=(%$captures,format=>undef,%values);my$pattern=$route->pattern;$values{format}//= defined$captures->{format}? $captures->{format}: $pattern->defaults->{format}if$pattern->constraints->{format};my$path=$route->render(\%values);return {path=>$path,websocket=>$route->has_websocket}}sub _match {my ($self,$r,$c,$options)=@_;my$path=$options->{path};my$partial=$r->partial;my$detect=(my$endpoint=$r->is_endpoint)&&!$partial;return undef unless my$captures=$r->pattern->match_partial(\$path,$detect);local$options->{path}=$path;local @{$self->{captures}||= {}}{keys %$captures}=values %$captures;$captures=$self->{captures};my$methods=$r->via;return undef if$methods &&!grep {$_ eq $options->{method}}@$methods;if (my$over=$r->over){my$conditions=$self->{conditions}||= $self->root->conditions;for (my$i=0;$i < @$over;$i += 2){return undef unless my$condition=$conditions->{$over->[$i]};return undef if!$condition->($r,$c,$captures,$over->[$i + 1])}}return undef if$r->is_websocket &&!$options->{websocket};my$empty=$path eq '' || $path eq '/';if ($partial){$captures->{path}=$path;$self->endpoint($r);$empty=1}if (($endpoint && $empty)|| $r->inline){push @{$self->stack},{%$captures};if ($endpoint && $empty){my$format=$captures->{format};if ($format){$_->{format}=$format for @{$self->stack}}return!!$self->endpoint($r)}delete @$captures{qw(app cb)}}my@snapshot=$r->parent ? ([@{$self->stack}],$captures): ([],{});for my$child (@{$r->children}){return 1 if$self->_match($child,$c,$options);$self->stack([@{$snapshot[0]}])->{captures}=$snapshot[1]}}1;
MOJOLICIOUS_ROUTES_MATCH

$fatpacked{"Mojolicious/Routes/Pattern.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES_PATTERN';
  package Mojolicious::Routes::Pattern;use Mojo::Base -base;use Mojo::Util 'deprecated';has [qw(constraints defaults)]=>sub {{}};has placeholder_start=>':';has [qw(placeholders tree)]=>sub {[]};has quote_end=>')';has quote_start=>'(';has [qw(regex unparsed)];has relaxed_start=>'#';has wildcard_start=>'*';sub format_regex {deprecated 'Mojolicious::Routes::Pattern::format_regex is DEPRECATED';return @_ > 1 ? $_[0]: undef}sub match {my ($self,$path,$detect)=@_;my$captures=$self->match_partial(\$path,$detect);return!$path || $path eq '/' ? $captures : undef}sub match_partial {my ($self,$pathref,$detect)=@_;$self->_compile($detect)unless$self->{regex};return undef unless my@captures=$$pathref =~ $self->regex;$$pathref=${^POSTMATCH};@captures=()if $#+==0;my$captures={%{$self->defaults}};for my$placeholder (@{$self->placeholders},'format'){last unless@captures;my$capture=shift@captures;$captures->{$placeholder}=$capture if defined$capture}return$captures}sub new {@_ > 1 ? shift->SUPER::new->parse(@_): shift->SUPER::new}sub parse {my$self=shift;my$pattern=@_ % 2 ? (shift // '/'): '/';$pattern =~ s!^/*|/+!/!g;return$self->constraints({@_})if$pattern eq '/';$pattern =~ s!/$!!;return$self->constraints({@_})->_tokenize($pattern)}sub render {my ($self,$values,$endpoint)=@_;my$optional=!(my$format=$values->{format});my$str='';for my$token (reverse @{$self->tree}){my ($op,$value)=@$token;my$fragment='';if ($op eq 'text'){($fragment,$optional)=($value,0)}elsif ($op eq 'slash'){$fragment='/' unless$optional}else {my$default=$self->defaults->{$value};$fragment=$values->{$value}// $default // '';if (!defined$default || ($default ne $fragment)){$optional=0}elsif ($optional){$fragment=''}}$str="$fragment$str"}return$endpoint && $format ? "$str.$format" : $str}sub _compile {my ($self,$detect)=@_;my$placeholders=$self->placeholders;my$constraints=$self->constraints;my$defaults=$self->defaults;my$block=my$regex='';my$optional=1;for my$token (reverse @{$self->tree}){my ($op,$value)=@$token;my$fragment='';if ($op eq 'text'){($fragment,$optional)=(quotemeta$value,0)}elsif ($op eq 'slash'){$regex=($optional ? "(?:/$block)?" : "/$block").$regex;($block,$optional)=('',1);next}else {unshift @$placeholders,$value;if ($op eq 'placeholder'){$fragment='([^/.]+)'}elsif ($op eq 'relaxed'){$fragment='([^/]+)'}else {$fragment='(.+)'}if (my$c=$constraints->{$value}){$fragment=_compile_req($c)}exists$defaults->{$value}? ($fragment .= '?'): ($optional=0)}$block="$fragment$block"}$regex="$block$regex" if$block;$regex .= _compile_format($constraints->{format},$defaults->{format})if$detect;$self->regex(qr/^$regex/ps)}sub _compile_format {my ($format,$default)=@_;return '/?(?:\.([^/]+))?$' unless defined$format;return '' unless$format;my$regex='\.' ._compile_req($format);return$default ? "/?(?:$regex)?\$" : "/?$regex\$"}sub _compile_req {my$req=shift;return "($req)" if ref$req ne 'ARRAY';return '(' .join('|',map {quotemeta}reverse sort @$req).')'}sub _tokenize {my ($self,$pattern)=@_;my$quote_end=$self->quote_end;my$quote_start=$self->quote_start;my$placeholder=$self->placeholder_start;my$relaxed=$self->relaxed_start;my$wildcard=$self->wildcard_start;my (@tree,$inside,$quoted);for my$char (split '',$pattern){if ($char eq $quote_start){push@tree,['placeholder',''];($inside,$quoted)=(1,1)}elsif ($char eq $placeholder){push@tree,['placeholder','']unless$inside++}elsif ($char eq $relaxed || $char eq $wildcard){push@tree,['placeholder','']unless$quoted;$tree[-1][0]=$char eq $relaxed ? 'relaxed' : 'wildcard';$inside=1}elsif ($char eq $quote_end){($inside,$quoted)=(0,0)}elsif ($char eq '/'){push@tree,['slash'];$inside=0}elsif ($inside){$tree[-1][-1].= $char}elsif ($tree[-1][0]eq 'text'){$tree[-1][-1].= $char}elsif (!$tree[-2]&& $tree[-1][0]eq 'slash'){@tree=(['text',"/$char"])}elsif ($tree[-2]&& $tree[-2][0]eq 'text' && $tree[-1][0]eq 'slash'){pop@tree && ($tree[-1][-1].= "/$char")}else {push@tree,['text',$char]}}return$self->unparsed($pattern)->tree(\@tree)}1;
MOJOLICIOUS_ROUTES_PATTERN

$fatpacked{"Mojolicious/Routes/Route.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_ROUTES_ROUTE';
  package Mojolicious::Routes::Route;use Mojo::Base -base;use Carp ();use Mojo::Util;use Mojolicious::Routes::Pattern;use Scalar::Util ();has [qw(inline parent partial)];has 'children'=>sub {[]};has pattern=>sub {Mojolicious::Routes::Pattern->new};sub AUTOLOAD {my$self=shift;my ($package,$method)=our$AUTOLOAD =~ /^(.+)::(.+)$/;Carp::croak "Undefined subroutine &${package}::$method called" unless Scalar::Util::blessed$self && $self->isa(__PACKAGE__);Carp::croak qq{Can't locate object method "$method" via package "$package"} unless my$shortcut=$self->root->shortcuts->{$method};return$self->$shortcut(@_)}sub add_child {my ($self,$route)=@_;Scalar::Util::weaken$route->remove->parent($self)->{parent};push @{$self->children},$route;return$self}sub any {shift->_generate_route(ref $_[0]eq 'ARRAY' ? shift : [],@_)}sub delete {shift->_generate_route(DELETE=>@_)}sub detour {shift->partial(1)->to(@_)}sub find {my ($self,$name)=@_;my@children=(@{$self->children});my$candidate;while (my$child=shift@children){$candidate=$child->has_custom_name ? return$child : $child if$child->name eq $name;push@children,@{$child->children}}return$candidate}sub get {shift->_generate_route(GET=>@_)}sub has_custom_name {!!shift->{custom}}sub has_websocket {my$self=shift;return$self->{has_websocket}if exists$self->{has_websocket};return$self->{has_websocket}=grep {$_->is_websocket}@{$self->_chain}}sub is_endpoint {$_[0]->inline ? undef :!@{$_[0]->children}}sub is_websocket {!!shift->{websocket}}sub name {my$self=shift;return$self->{name}unless @_;@$self{qw(name custom)}=(shift,1);return$self}sub new {shift->SUPER::new->parse(@_)}sub options {shift->_generate_route(OPTIONS=>@_)}sub over {my$self=shift;return$self->{over}unless @_;my$conditions=ref $_[0]eq 'ARRAY' ? $_[0]: [@_];return$self unless @$conditions;$self->{over}=$conditions;$self->root->cache->max_keys(0);return$self}sub parse {my$self=shift;$self->{name}=$self->pattern->parse(@_)->unparsed // '';$self->{name}=~ s/\W+//g;return$self}sub patch {shift->_generate_route(PATCH=>@_)}sub post {shift->_generate_route(POST=>@_)}sub put {shift->_generate_route(PUT=>@_)}sub remove {my$self=shift;return$self unless my$parent=$self->parent;@{$parent->children}=grep {$_ ne $self}@{$parent->children};return$self->parent(undef)}sub render {my ($self,$values)=@_;my$path=join '',map {$_->pattern->render($values,!@{$_->children}&&!$_->partial)}@{$self->_chain};return$path || '/'}sub root {shift->_chain->[0]}sub route {my$self=shift;my$route=$self->add_child(__PACKAGE__->new(@_))->children->[-1];my$format=$self->pattern->constraints->{format};$route->pattern->constraints->{format}//= 0 if defined$format &&!$format;return$route}sub suggested_method {my$self=shift;my%via;for my$route (@{$self->_chain}){next unless my@via=@{$route->via || []};%via=map {$_=>1}keys%via ? grep {$via{$_}}@via : @via}return 'POST' if$via{POST}&&!$via{GET};return$via{GET}? 'GET' : (sort keys%via)[0]|| 'GET'}sub to {my$self=shift;my$pattern=$self->pattern;return$pattern->defaults unless @_;my ($shortcut,%defaults)=Mojo::Util::_options(@_);if ($shortcut){if (ref$shortcut || $shortcut =~ /^[\w:]+$/){$defaults{app}=$shortcut}elsif ($shortcut =~ /^([\w\-:]+)?\#(\w+)?$/){$defaults{controller}=$1 if defined $1;$defaults{action}=$2 if defined $2}}@{$pattern->defaults}{keys%defaults}=values%defaults;return$self}sub to_string {join '',map {$_->pattern->unparsed // ''}@{shift->_chain}}sub under {shift->_generate_route(under=>@_)}sub via {my$self=shift;return$self->{via}unless @_;my$methods=[map uc($_),@{ref $_[0]? $_[0]: [@_]}];$self->{via}=$methods if @$methods;return$self}sub websocket {my$route=shift->get(@_);$route->{websocket}=1;return$route}sub _chain {my@chain=(my$parent=shift);unshift@chain,$parent while$parent=$parent->parent;return \@chain}sub _generate_route {my ($self,$methods,@args)=@_;my (@conditions,@constraints,%defaults,$name,$pattern);while (defined(my$arg=shift@args)){if (!ref$arg &&!$pattern){$pattern=$arg}elsif (!ref$arg && @args){push@conditions,$arg,shift@args}elsif (!ref$arg){$name=$arg}elsif (ref$arg eq 'CODE'){$defaults{cb}=$arg}elsif (ref$arg eq 'ARRAY'){push@constraints,@$arg}elsif (ref$arg eq 'HASH'){%defaults=(%defaults,%$arg)}}my$route =$self->route($pattern,@constraints)->over(\@conditions)->to(\%defaults);$methods eq 'under' ? $route->inline(1): $route->via($methods);return defined$name ? $route->name($name): $route}1;
MOJOLICIOUS_ROUTES_ROUTE

$fatpacked{"Mojolicious/Sessions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_SESSIONS';
  package Mojolicious::Sessions;use Mojo::Base -base;use Mojo::JSON;use Mojo::Util qw(b64_decode b64_encode);has [qw(cookie_domain secure)];has cookie_name=>'mojolicious';has cookie_path=>'/';has default_expiration=>3600;has deserialize=>sub {\&Mojo::JSON::j};has serialize=>sub {\&Mojo::JSON::encode_json};sub load {my ($self,$c)=@_;return unless my$value=$c->signed_cookie($self->cookie_name);$value =~ y/-/=/;return unless my$session=$self->deserialize->(b64_decode$value);my$expiration=$session->{expiration}// $self->default_expiration;return if!(my$expires=delete$session->{expires})&& $expiration;return if defined$expires && $expires <= time;my$stash=$c->stash;return unless$stash->{'mojo.active_session'}=keys %$session;$stash->{'mojo.session'}=$session;$session->{flash}=delete$session->{new_flash}if$session->{new_flash}}sub store {my ($self,$c)=@_;my$stash=$c->stash;return unless my$session=$stash->{'mojo.session'};return unless keys %$session || $stash->{'mojo.active_session'};my$old=delete$session->{flash};$session->{new_flash}=$old if$stash->{'mojo.static'};delete$session->{new_flash}unless keys %{$session->{new_flash}};my$expiration=$session->{expiration}// $self->default_expiration;my$default=delete$session->{expires};$session->{expires}=$default || time + $expiration if$expiration || $default;my$value=b64_encode$self->serialize->($session),'';$value =~ y/=/-/;my$options={domain=>$self->cookie_domain,expires=>$session->{expires},httponly=>1,path=>$self->cookie_path,secure=>$self->secure };$c->signed_cookie($self->cookie_name,$value,$options)}1;
MOJOLICIOUS_SESSIONS

$fatpacked{"Mojolicious/Static.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_STATIC';
  package Mojolicious::Static;use Mojo::Base -base;use File::Spec::Functions 'catfile';use Mojo::Asset::File;use Mojo::Asset::Memory;use Mojo::Date;use Mojo::Home;use Mojo::Loader 'data_section';use Mojo::Util 'md5_sum';has classes=>sub {['main']};has paths=>sub {[]};my$PUBLIC=Mojo::Home->new(Mojo::Home->new->mojo_lib_dir)->rel_dir('Mojolicious/resources/public');sub dispatch {my ($self,$c)=@_;my$req=$c->req;my$method=$req->method;return undef unless$method eq 'GET' || $method eq 'HEAD';my$stash=$c->stash;my$path=$req->url->path;$path=$stash->{path}? $path->new($stash->{path}): $path->clone;return undef unless my@parts=@{$path->canonicalize->parts};return undef if$parts[0]eq '..' ||!$self->serve($c,join('/',@parts));$stash->{'mojo.static'}=1;return!!$c->rendered}sub file {my ($self,$rel)=@_;for my$path (@{$self->paths}){next unless my$asset=$self->_get_file(catfile$path,split('/',$rel));return$asset}if (my$asset=$self->_get_data_file($rel)){return$asset}return$self->_get_file(catfile($PUBLIC,split('/',$rel)))}sub is_fresh {my ($self,$c,$options)=@_;my$res_headers=$c->res->headers;my ($last,$etag)=@$options{qw(last_modified etag)};$res_headers->last_modified(Mojo::Date->new($last)->to_string)if$last;$res_headers->etag($etag=qq{"$etag"})if$etag;my$req_headers=$c->req->headers;my$match=$req_headers->if_none_match;return undef unless (my$since=$req_headers->if_modified_since)|| $match;return undef if$match && ($etag // $res_headers->etag // '')ne $match;return!!$match unless ($last //= $res_headers->last_modified)&& $since;return _epoch($last)<= (_epoch($since)// 0)}sub serve {my ($self,$c,$rel)=@_;return undef unless my$asset=$self->file($rel);my$headers=$c->res->headers;return!!$self->serve_asset($c,$asset)if$headers->content_type;my$types=$c->app->types;my$type=$rel =~ /\.(\w+)$/ ? $types->type($1): undef;$headers->content_type($type || $types->type('txt'));return!!$self->serve_asset($c,$asset)}sub serve_asset {my ($self,$c,$asset)=@_;my$res=$c->res;$res->code(200)->headers->accept_ranges('bytes');my$mtime=$asset->mtime;my$options={etag=>md5_sum($mtime),last_modified=>$mtime};return$res->code(304)if$self->is_fresh($c,$options);return$res->content->asset($asset)unless my$range=$c->req->headers->range;return$res->code(416)unless my$size=$asset->size;return$res->code(416)unless$range =~ /^bytes=(\d+)?-(\d+)?/;my ($start,$end)=($1 // 0,defined $2 && $2 < $size ? $2 : $size - 1);return$res->code(416)if$start > $end;$res->code(206)->headers->content_length($end - $start + 1)->content_range("bytes $start-$end/$size");return$res->content->asset($asset->start_range($start)->end_range($end))}sub warmup {my$self=shift;my$index=$self->{index}={};for my$class (reverse @{$self->classes}){$index->{$_}=$class for keys %{data_section$class}}}sub _epoch {Mojo::Date->new(shift)->epoch}sub _get_data_file {my ($self,$rel)=@_;return undef if$rel !~ /\.\w+$/ || $rel =~ /\.\w+\.\w+$/;$self->warmup unless$self->{index};return undef unless defined(my$data=data_section($self->{index}{$rel},$rel));return Mojo::Asset::Memory->new->add_chunk($data)}sub _get_file {my ($self,$path)=@_;no warnings 'newline';return -f $path && -r _ ? Mojo::Asset::File->new(path=>$path): undef}1;
MOJOLICIOUS_STATIC

$fatpacked{"Mojolicious/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_TYPES';
  package Mojolicious::Types;use Mojo::Base -base;has mapping=>sub {{appcache=>['text/cache-manifest'],atom=>['application/atom+xml'],bin=>['application/octet-stream'],css=>['text/css'],gif=>['image/gif'],gz=>['application/x-gzip'],htm=>['text/html'],html=>['text/html;charset=UTF-8'],ico=>['image/x-icon'],jpeg=>['image/jpeg'],jpg=>['image/jpeg'],js=>['application/javascript'],json=>['application/json;charset=UTF-8'],mp3=>['audio/mpeg'],mp4=>['video/mp4'],ogg=>['audio/ogg'],ogv=>['video/ogg'],pdf=>['application/pdf'],png=>['image/png'],rss=>['application/rss+xml'],svg=>['image/svg+xml'],txt=>['text/plain;charset=UTF-8'],webm=>['video/webm'],woff=>['application/font-woff'],xml=>['application/xml','text/xml'],zip=>['application/zip']}};sub detect {my ($self,$accept,$prioritize)=@_;my%types;/^\s*([^,; ]+)(?:\s*\;\s*q\s*=\s*(\d+(?:\.\d+)?))?\s*$/i and $types{lc $1}=$2 // 1 for split ',',$accept // '';my@detected=sort {$types{$b}<=> $types{$a}}sort keys%types;return []if!$prioritize && @detected > 1;my%reverse;my$mapping=$self->mapping;for my$ext (sort keys %$mapping){my@types=@{$mapping->{$ext}};push @{$reverse{$_}},$ext for map {s/\;.*$//;lc $_}@types}return [map {@{$reverse{$_}// []}}@detected]}sub type {my ($self,$ext,$type)=@_;return$self->mapping->{lc$ext}[0]unless$type;$self->mapping->{lc$ext}=ref$type ? $type : [$type];return$self}1;
MOJOLICIOUS_TYPES

$fatpacked{"Mojolicious/Validator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_VALIDATOR';
  package Mojolicious::Validator;use Mojo::Base -base;use Mojolicious::Validator::Validation;has checks=>sub {{equal_to=>\&_equal_to,in=>\&_in,like=>sub {$_[2]!~ $_[3]},size=>\&_size,upload=>sub {!ref $_[2]||!$_[2]->isa('Mojo::Upload')}}};sub add_check {$_[0]->checks->{$_[1]}=$_[2]and return $_[0]}sub validation {Mojolicious::Validator::Validation->new(validator=>shift)}sub _equal_to {my ($validation,$name,$value,$to)=@_;return 1 unless defined(my$other=$validation->input->{$to});return$value ne $other}sub _in {my ($validation,$name,$value)=(shift,shift,shift);$value eq $_ && return undef for @_;return 1}sub _size {my ($validation,$name,$value,$min,$max)=@_;my$len=ref$value ? $value->size : length$value;return$len < $min || $len > $max}1;
MOJOLICIOUS_VALIDATOR

$fatpacked{"Mojolicious/Validator/Validation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOJOLICIOUS_VALIDATOR_VALIDATION';
  package Mojolicious::Validator::Validation;use Mojo::Base -base;use Carp ();use Scalar::Util ();has [qw(csrf_token topic validator)];has [qw(input output)]=>sub {{}};sub AUTOLOAD {my$self=shift;my ($package,$method)=our$AUTOLOAD =~ /^(.+)::(.+)$/;Carp::croak "Undefined subroutine &${package}::$method called" unless Scalar::Util::blessed$self && $self->isa(__PACKAGE__);return$self->check($method=>@_)if$self->validator->checks->{$method};Carp::croak qq{Can't locate object method "$method" via package "$package"}}sub check {my ($self,$check)=(shift,shift);return$self unless$self->is_valid;my$cb=$self->validator->checks->{$check};my$name=$self->topic;my$values=$self->output->{$name};for my$value (ref$values eq 'ARRAY' ? @$values : $values){next unless my$result=$self->$cb($name,$value,@_);return$self->error($name=>[$check,$result,@_])}return$self}sub csrf_protect {my$self=shift;my$token=$self->input->{csrf_token};$self->error(csrf_token=>['csrf_protect'])unless$token && $token eq ($self->csrf_token // '');return$self}sub error {my ($self,$name)=(shift,shift);return$self->{error}{$name}unless @_;$self->{error}{$name}=shift;delete$self->output->{$name};return$self}sub every_param {return []unless defined(my$value=shift->output->{shift()});return [ref$value eq 'ARRAY' ? @$value : $value]}sub failed {[sort keys %{shift->{error}}]}sub has_data {!!keys %{shift->input}}sub has_error {$_[1]? exists $_[0]{error}{$_[1]}:!!keys %{$_[0]{error}}}sub is_valid {exists $_[0]->output->{$_[1]// $_[0]->topic}}sub optional {my ($self,$name)=@_;my$input=$self->input->{$name};my@input=ref$input eq 'ARRAY' ? @$input : $input;$self->output->{$name}=$input unless grep {!defined($_)|| $_ eq ''}@input;return$self->topic($name)}sub param {shift->every_param(shift)->[-1]}sub passed {[sort keys %{shift->output}]}sub required {my ($self,$name)=@_;return$self if$self->optional($name)->is_valid;return$self->error($name=>['required'])}1;
MOJOLICIOUS_VALIDATOR_VALIDATION

$fatpacked{"Sub/Uplevel.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_UPLEVEL';
  package Sub::Uplevel;use 5.006;use strict;our$VERSION='0.25';our$CHECK_FRAMES;BEGIN {$CHECK_FRAMES=!!$CHECK_FRAMES}use constant CHECK_FRAMES=>$CHECK_FRAMES;if (not defined*CORE::GLOBAL::caller{CODE}){*CORE::GLOBAL::caller=\&_normal_caller}my@reload_list=qw/Exporter Exporter::Heavy/;sub import {no strict 'refs';my ($class,@args)=@_;for my$tag (@args,'uplevel'){if ($tag eq 'uplevel'){my$caller=caller(0);*{"$caller\::uplevel"}=\&uplevel}elsif($tag eq ':aggressive'){_force_reload(@reload_list)}else {die qq{"$tag" is not exported by the $class module\n}}}return}sub _force_reload {no warnings 'redefine';local $^W=0;for my$m (@_){$m =~ s{::}{/}g;$m .= ".pm";require$m if delete$INC{$m}}}our (@Up_Frames,$Caller_Proxy);sub _apparent_stack_height {my$height=1;while (1){last if!defined scalar$Caller_Proxy->($height);$height++}return$height - 1}sub uplevel {my$old_W=$^W;$^W=0;local$Caller_Proxy=*CORE::GLOBAL::caller{CODE}if*CORE::GLOBAL::caller{CODE}!=\&_uplevel_caller;local*CORE::GLOBAL::caller=\&_uplevel_caller;$^W=$old_W;if (CHECK_FRAMES and $_[0]>= _apparent_stack_height()){require Carp;Carp::carp("uplevel $_[0] is more than the caller stack")}local@Up_Frames=(shift,@Up_Frames);my$function=shift;return$function->(@_)}sub _normal_caller (;$) {my ($height)=@_;$height++;my@caller=CORE::caller($height);if (CORE::caller()eq 'DB'){package DB;@caller=CORE::caller($height)}return if!@caller;return$caller[0]if!wantarray;return @_ ? @caller : @caller[0..2]}sub _uplevel_caller (;$) {my$height=$_[0]|| 0;return$Caller_Proxy->($height + 1)if!@Up_Frames;my$saw_uplevel=0;my$adjust=0;for (my$up=0;$up <= $height + $adjust;$up++ ){my@caller=CORE::caller($up + 1);if(defined$caller[0]&& $caller[0]eq __PACKAGE__){$adjust += 1 + $Up_Frames[$saw_uplevel];$saw_uplevel++}}my@caller=$Caller_Proxy->($height + $adjust + 1);if (CORE::caller()eq 'DB'){package DB;@caller=$Sub::Uplevel::Caller_Proxy->($height + $adjust + 1)}return if!@caller;return$caller[0]if!wantarray;return @_ ? @caller : @caller[0..2]}1;
SUB_UPLEVEL

$fatpacked{"Test/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER';
  package Test::Builder;use 5.006;use strict;use warnings;our$VERSION='1.001014';$VERSION=eval$VERSION;BEGIN {if($] < 5.008){require Test::Builder::IO::Scalar}}BEGIN {use Config;if($] >= 5.008001 && $Config{useithreads}&& $INC{'threads.pm'}){require threads::shared;*share=sub (\[$@%]) {my$type=ref $_[0];my$data;if($type eq 'HASH'){%$data=%{$_[0]}}elsif($type eq 'ARRAY'){@$data=@{$_[0]}}elsif($type eq 'SCALAR'){$$data=${$_[0]}}else {die("Unknown type: " .$type)}$_[0]=&threads::shared::share($_[0]);if($type eq 'HASH'){%{$_[0]}=%$data}elsif($type eq 'ARRAY'){@{$_[0]}=@$data}elsif($type eq 'SCALAR'){${$_[0]}=$$data}else {die("Unknown type: " .$type)}return $_[0]}}else {*share=sub {return $_[0]};*lock=sub {0}}}our$Test=Test::Builder->new;sub new {my($class)=shift;$Test ||= $class->create;return$Test}sub create {my$class=shift;my$self=bless {},$class;$self->reset;return$self}sub _copy {my($src,$dest)=@_;%$dest=%$src;_share_keys($dest);return}sub child {my($self,$name)=@_;if($self->{Child_Name}){$self->croak("You already have a child named ($self->{Child_Name}) running")}my$parent_in_todo=$self->in_todo;my$orig_TODO=$self->find_TODO(undef,1,undef);my$class=ref$self;my$child=$class->create;$child->_indent($self->_indent .'    ');for my$method (qw(output failure_output todo_output)){$child->$method($self->$method)}if($parent_in_todo){$child->failure_output($self->todo_output)}$child->{Child_Error}=$?;$?=0;$child->{Parent}=$self;$child->{Parent_TODO}=$orig_TODO;$child->{Name}=$name || "Child of " .$self->name;$self->{Child_Name}=$child->name;return$child}sub subtest {my$self=shift;my($name,$subtests,@args)=@_;if ('CODE' ne ref$subtests){$self->croak("subtest()'s second argument must be a code ref")}my$error;my$child;my$parent={};{local$Test::Builder::Level=$Test::Builder::Level + 1;$child=$self->child($name);_copy($self,$parent);_copy($child,$self);my$run_the_subtests=sub {$self->note("Subtest: $name");$subtests->(@args);$self->done_testing unless$self->_plan_handled;1};if(!eval {$run_the_subtests->()}){$error=$@}}_copy($self,$child);_copy($parent,$self);$self->find_TODO(undef,1,$child->{Parent_TODO});die$error if$error and!eval {$error->isa('Test::Builder::Exception')};local$Test::Builder::Level=$Test::Builder::Level + 1;my$finalize=$child->finalize;$self->BAIL_OUT($child->{Bailed_Out_Reason})if$child->{Bailed_Out};return$finalize}sub _plan_handled {my$self=shift;return$self->{Have_Plan}|| $self->{No_Plan}|| $self->{Skip_All}}sub finalize {my$self=shift;return unless$self->parent;if($self->{Child_Name}){$self->croak("Can't call finalize() with child ($self->{Child_Name}) active")}local $?=0;$self->_ending;local$Test::Builder::Level=$Test::Builder::Level + 1;my$ok=1;$self->parent->{Child_Name}=undef;unless ($self->{Bailed_Out}){if ($self->{Skip_All}){$self->parent->skip($self->{Skip_All},$self->name)}elsif (not @{$self->{Test_Results}}){$self->parent->ok(0,sprintf q[No tests run for subtest "%s"],$self->name)}else {$self->parent->ok($self->is_passing,$self->name)}}$?=$self->{Child_Error};delete$self->{Parent};return$self->is_passing}sub _indent {my$self=shift;if(@_){$self->{Indent}=shift}return$self->{Indent}}sub parent {shift->{Parent}}sub name {shift->{Name}}sub DESTROY {my$self=shift;if ($self->parent and $$==$self->{Original_Pid}){my$name=$self->name;$self->diag(<<"FAIL");$self->parent->{In_Destroy}=1;$self->parent->ok(0,$name)}}our$Level;sub reset {my($self)=@_;$Level=1;$self->{Name}=$0;$self->is_passing(1);$self->{Ending}=0;$self->{Have_Plan}=0;$self->{No_Plan}=0;$self->{Have_Output_Plan}=0;$self->{Done_Testing}=0;$self->{Original_Pid}=$$;$self->{Child_Name}=undef;$self->{Indent}||= '';$self->{Curr_Test}=0;$self->{Test_Results}=&share([]);$self->{Exported_To}=undef;$self->{Expected_Tests}=0;$self->{Skip_All}=0;$self->{Use_Nums}=1;$self->{No_Header}=0;$self->{No_Ending}=0;$self->{Todo}=undef;$self->{Todo_Stack}=[];$self->{Start_Todo}=0;$self->{Opened_Testhandles}=0;$self->_share_keys;$self->_dup_stdhandles;return}sub _share_keys {my$self=shift;share($self->{Curr_Test});return}my%plan_cmds=(no_plan=>\&no_plan,skip_all=>\&skip_all,tests=>\&_plan_tests,);sub plan {my($self,$cmd,$arg)=@_;return unless$cmd;local$Level=$Level + 1;$self->croak("You tried to plan twice")if$self->{Have_Plan};if(my$method=$plan_cmds{$cmd}){local$Level=$Level + 1;$self->$method($arg)}else {my@args=grep {defined}($cmd,$arg);$self->croak("plan() doesn't understand @args")}return 1}sub _plan_tests {my($self,$arg)=@_;if($arg){local$Level=$Level + 1;return$self->expected_tests($arg)}elsif(!defined$arg){$self->croak("Got an undefined number of tests")}else {$self->croak("You said to run 0 tests")}return}sub expected_tests {my$self=shift;my($max)=@_;if(@_){$self->croak("Number of tests must be a positive integer.  You gave it '$max'")unless$max =~ /^\+?\d+$/;$self->{Expected_Tests}=$max;$self->{Have_Plan}=1;$self->_output_plan($max)unless$self->no_header}return$self->{Expected_Tests}}sub no_plan {my($self,$arg)=@_;$self->carp("no_plan takes no arguments")if$arg;$self->{No_Plan}=1;$self->{Have_Plan}=1;return 1}sub _output_plan {my($self,$max,$directive,$reason)=@_;$self->carp("The plan was already output")if$self->{Have_Output_Plan};my$plan="1..$max";$plan .= " # $directive" if defined$directive;$plan .= " $reason" if defined$reason;$self->_print("$plan\n");$self->{Have_Output_Plan}=1;return}sub done_testing {my($self,$num_tests)=@_;if(defined$num_tests){$self->{No_Plan}=0}else {$num_tests=$self->current_test}if($self->{Done_Testing}){my($file,$line)=@{$self->{Done_Testing}}[1,2];$self->ok(0,"done_testing() was already called at $file line $line");return}$self->{Done_Testing}=[caller];if($self->expected_tests && $num_tests!=$self->expected_tests){$self->ok(0,"planned to run @{[ $self->expected_tests ]} "."but done_testing() expects $num_tests")}else {$self->{Expected_Tests}=$num_tests}$self->_output_plan($num_tests)unless$self->{Have_Output_Plan};$self->{Have_Plan}=1;$self->is_passing(0)if$self->{Expected_Tests}!=$self->{Curr_Test};$self->is_passing(0)if$self->{Curr_Test}==0;return 1}sub has_plan {my$self=shift;return($self->{Expected_Tests})if$self->{Expected_Tests};return('no_plan')if$self->{No_Plan};return(undef)}sub skip_all {my($self,$reason)=@_;$self->{Skip_All}=$self->parent ? $reason : 1;$self->_output_plan(0,"SKIP",$reason)unless$self->no_header;if ($self->parent){die bless {}=>'Test::Builder::Exception'}exit(0)}sub exported_to {my($self,$pack)=@_;if(defined$pack){$self->{Exported_To}=$pack}return$self->{Exported_To}}sub ok {my($self,$test,$name)=@_;if ($self->{Child_Name}and not $self->{In_Destroy}){$name='unnamed test' unless defined$name;$self->is_passing(0);$self->croak("Cannot run test ($name) with active children")}$test=$test ? 1 : 0;lock$self->{Curr_Test};$self->{Curr_Test}++;$self->_unoverload_str(\$name);$self->diag(<<"ERR")if defined$name and $name =~ /^[\d\s]+$/;my$todo=$self->todo();my$in_todo=$self->in_todo;local$self->{Todo}=$todo if$in_todo;$self->_unoverload_str(\$todo);my$out;my$result=&share({});unless($test){$out .= "not ";@$result{'ok','actual_ok' }=(($self->in_todo ? 1 : 0),0)}else {@$result{'ok','actual_ok' }=(1,$test)}$out .= "ok";$out .= " $self->{Curr_Test}" if$self->use_numbers;if(defined$name){$name =~ s|#|\\#|g;$out .= " - $name";$result->{name}=$name}else {$result->{name}=''}if($self->in_todo){$out .= " # TODO $todo";$result->{reason}=$todo;$result->{type}='todo'}else {$result->{reason}='';$result->{type}=''}$self->{Test_Results}[$self->{Curr_Test}- 1 ]=$result;$out .= "\n";$self->_print($out);unless($test){my$msg=$self->in_todo ? "Failed (TODO)" : "Failed";$self->_print_to_fh($self->_diag_fh,"\n")if$ENV{HARNESS_ACTIVE};my(undef,$file,$line)=$self->caller;if(defined$name){$self->diag(qq[  $msg test '$name'\n]);$self->diag(qq[  at $file line $line.\n])}else {$self->diag(qq[  $msg test at $file line $line.\n])}}$self->is_passing(0)unless$test || $self->in_todo;$self->_check_is_passing_plan();return$test ? 1 : 0}sub _check_is_passing_plan {my$self=shift;my$plan=$self->has_plan;return unless defined$plan;return unless$plan !~ /\D/;$self->is_passing(0)if$plan < $self->{Curr_Test}}sub _unoverload {my$self=shift;my$type=shift;$self->_try(sub {require overload},die_on_fail=>1);for my$thing (@_){if($self->_is_object($$thing)){if(my$string_meth=overload::Method($$thing,$type)){$$thing=$$thing->$string_meth()}}}return}sub _is_object {my($self,$thing)=@_;return$self->_try(sub {ref$thing && $thing->isa('UNIVERSAL')})? 1 : 0}sub _unoverload_str {my$self=shift;return$self->_unoverload(q[""],@_)}sub _unoverload_num {my$self=shift;$self->_unoverload('0+',@_);for my$val (@_){next unless$self->_is_dualvar($$val);$$val=$$val + 0}return}sub _is_dualvar {my($self,$val)=@_;return 0 if ref$val;no warnings 'numeric';my$numval=$val + 0;return ($numval!=0 and $numval ne $val ? 1 : 0)}sub is_eq {my($self,$got,$expect,$name)=@_;local$Level=$Level + 1;if(!defined$got ||!defined$expect){my$test=!defined$got &&!defined$expect;$self->ok($test,$name);$self->_is_diag($got,'eq',$expect)unless$test;return$test}return$self->cmp_ok($got,'eq',$expect,$name)}sub is_num {my($self,$got,$expect,$name)=@_;local$Level=$Level + 1;if(!defined$got ||!defined$expect){my$test=!defined$got &&!defined$expect;$self->ok($test,$name);$self->_is_diag($got,'==',$expect)unless$test;return$test}return$self->cmp_ok($got,'==',$expect,$name)}sub _diag_fmt {my($self,$type,$val)=@_;if(defined $$val){if($type eq 'eq' or $type eq 'ne'){$$val="'$$val'"}else {$self->_unoverload_num($val)}}else {$$val='undef'}return}sub _is_diag {my($self,$got,$type,$expect)=@_;$self->_diag_fmt($type,$_)for \$got,\$expect;local$Level=$Level + 1;return$self->diag(<<"DIAGNOSTIC")}sub _isnt_diag {my($self,$got,$type)=@_;$self->_diag_fmt($type,\$got);local$Level=$Level + 1;return$self->diag(<<"DIAGNOSTIC")}sub isnt_eq {my($self,$got,$dont_expect,$name)=@_;local$Level=$Level + 1;if(!defined$got ||!defined$dont_expect){my$test=defined$got || defined$dont_expect;$self->ok($test,$name);$self->_isnt_diag($got,'ne')unless$test;return$test}return$self->cmp_ok($got,'ne',$dont_expect,$name)}sub isnt_num {my($self,$got,$dont_expect,$name)=@_;local$Level=$Level + 1;if(!defined$got ||!defined$dont_expect){my$test=defined$got || defined$dont_expect;$self->ok($test,$name);$self->_isnt_diag($got,'!=')unless$test;return$test}return$self->cmp_ok($got,'!=',$dont_expect,$name)}sub like {my($self,$thing,$regex,$name)=@_;local$Level=$Level + 1;return$self->_regex_ok($thing,$regex,'=~',$name)}sub unlike {my($self,$thing,$regex,$name)=@_;local$Level=$Level + 1;return$self->_regex_ok($thing,$regex,'!~',$name)}my%numeric_cmps=map {($_,1)}("<","<=",">",">=","==","!=","<=>");my%cmp_ok_bl=map {($_,1)}("=","+=",".=","x=","^=","|=","||=","&&=","...");sub cmp_ok {my($self,$got,$type,$expect,$name)=@_;if ($cmp_ok_bl{$type}){$self->croak("$type is not a valid comparison operator in cmp_ok()")}my ($test,$succ);my$error;{local($@,$!,$SIG{__DIE__});my($pack,$file,$line)=$self->caller();$succ=eval qq[
  Child ($name) exited without calling finalize()
  FAIL
      You named your test '$name'.  You shouldn't use numbers for your test names.
      Very confusing.
  ERR
           got: $got
      expected: $expect
  DIAGNOSTIC
           got: $got
      expected: anything else
  DIAGNOSTIC
  #line $line "(eval in cmp_ok) $file"
  \$test = (\$got $type \$expect);
  1;
  ];$error=$@}local$Level=$Level + 1;my$ok=$self->ok($test,$name);my$unoverload =$numeric_cmps{$type}? '_unoverload_num' : '_unoverload_str';$self->diag(<<"END")unless$succ;unless($ok){$self->$unoverload(\$got,\$expect);if($type =~ /^(eq|==)$/){$self->_is_diag($got,$type,$expect)}elsif($type =~ /^(ne|!=)$/){$self->_isnt_diag($got,$type)}else {$self->_cmp_diag($got,$type,$expect)}}return$ok}sub _cmp_diag {my($self,$got,$type,$expect)=@_;$got=defined$got ? "'$got'" : 'undef';$expect=defined$expect ? "'$expect'" : 'undef';local$Level=$Level + 1;return$self->diag(<<"DIAGNOSTIC")}sub _caller_context {my$self=shift;my($pack,$file,$line)=$self->caller(1);my$code='';$code .= "#line $line $file\n" if defined$file and defined$line;return$code}sub BAIL_OUT {my($self,$reason)=@_;$self->{Bailed_Out}=1;if ($self->parent){$self->{Bailed_Out_Reason}=$reason;$self->no_ending(1);die bless {}=>'Test::Builder::Exception'}$self->_print("Bail out!  $reason");exit 255}{no warnings 'once';*BAILOUT=\&BAIL_OUT}sub skip {my($self,$why,$name)=@_;$why ||= '';$name='' unless defined$name;$self->_unoverload_str(\$why);lock($self->{Curr_Test});$self->{Curr_Test}++;$self->{Test_Results}[$self->{Curr_Test}- 1 ]=&share({'ok'=>1,actual_ok=>1,name=>$name,type=>'skip',reason=>$why,});my$out="ok";$out .= " $self->{Curr_Test}" if$self->use_numbers;$out .= " # skip";$out .= " $why" if length$why;$out .= "\n";$self->_print($out);return 1}sub todo_skip {my($self,$why)=@_;$why ||= '';lock($self->{Curr_Test});$self->{Curr_Test}++;$self->{Test_Results}[$self->{Curr_Test}- 1 ]=&share({'ok'=>1,actual_ok=>0,name=>'',type=>'todo_skip',reason=>$why,});my$out="not ok";$out .= " $self->{Curr_Test}" if$self->use_numbers;$out .= " # TODO & SKIP $why\n";$self->_print($out);return 1}sub maybe_regex {my($self,$regex)=@_;my$usable_regex=undef;return$usable_regex unless defined$regex;my($re,$opts);if(_is_qr($regex)){$usable_regex=$regex}elsif(($re,$opts)=$regex =~ m{^ /(.*)/ (\w*) $ }sx or (undef,$re,$opts)=$regex =~ m,^ m([^\w\s]) (.+) \1 (\w*) $,sx){$usable_regex=length$opts ? "(?$opts)$re" : $re}return$usable_regex}sub _is_qr {my$regex=shift;return re::is_regexp($regex)if defined&re::is_regexp;return ref$regex eq 'Regexp'}sub _regex_ok {my($self,$thing,$regex,$cmp,$name)=@_;my$ok=0;my$usable_regex=$self->maybe_regex($regex);unless(defined$usable_regex){local$Level=$Level + 1;$ok=$self->ok(0,$name);$self->diag("    '$regex' doesn't look much like a regex to me.");return$ok}{my$test;my$context=$self->_caller_context;{local($@,$!,$SIG{__DIE__});no warnings 'uninitialized';$test=eval$context .q{$test = $thing =~ /$usable_regex/ ? 1 : 0}}$test=!$test if$cmp eq '!~';local$Level=$Level + 1;$ok=$self->ok($test,$name)}unless($ok){$thing=defined$thing ? "'$thing'" : 'undef';my$match=$cmp eq '=~' ? "doesn't match" : "matches";local$Level=$Level + 1;$self->diag(sprintf <<'DIAGNOSTIC',$thing,$match,$regex)}return$ok}sub _try {my($self,$code,%opts)=@_;my$error;my$return;{local $!;local $@;local$SIG{__DIE__};$return=eval {$code->()};$error=$@}die$error if$error and $opts{die_on_fail};return wantarray ? ($return,$error): $return}sub is_fh {my$self=shift;my$maybe_fh=shift;return 0 unless defined$maybe_fh;return 1 if ref$maybe_fh eq 'GLOB';return 1 if ref \$maybe_fh eq 'GLOB';return eval {$maybe_fh->isa("IO::Handle")}|| eval {tied($maybe_fh)->can('TIEHANDLE')}}sub level {my($self,$level)=@_;if(defined$level){$Level=$level}return$Level}sub use_numbers {my($self,$use_nums)=@_;if(defined$use_nums){$self->{Use_Nums}=$use_nums}return$self->{Use_Nums}}for my$attribute (qw(No_Header No_Ending No_Diag)){my$method=lc$attribute;my$code=sub {my($self,$no)=@_;if(defined$no){$self->{$attribute}=$no}return$self->{$attribute}};no strict 'refs';*{__PACKAGE__ .'::' .$method}=$code}sub diag {my$self=shift;$self->_print_comment($self->_diag_fh,@_)}sub note {my$self=shift;$self->_print_comment($self->output,@_)}sub _diag_fh {my$self=shift;local$Level=$Level + 1;return$self->in_todo ? $self->todo_output : $self->failure_output}sub _print_comment {my($self,$fh,@msgs)=@_;return if$self->no_diag;return unless@msgs;return if $^C;my$msg=join '',map {defined($_)? $_ : 'undef'}@msgs;$msg =~ s/^/# /;local$Level=$Level + 1;$self->_print_to_fh($fh,$msg);return 0}sub explain {my$self=shift;return map {ref $_ ? do {$self->_try(sub {require Data::Dumper},die_on_fail=>1);my$dumper=Data::Dumper->new([$_]);$dumper->Indent(1)->Terse(1);$dumper->Sortkeys(1)if$dumper->can("Sortkeys");$dumper->Dump}: $_}@_}sub _print {my$self=shift;return$self->_print_to_fh($self->output,@_)}sub _print_to_fh {my($self,$fh,@msgs)=@_;return if $^C;my$msg=join '',@msgs;my$indent=$self->_indent;local($\,$",$,)=(undef,' ','');$msg =~ s{\n(?!\z)}{\n$indent# }sg;$msg .= "\n" unless$msg =~ /\n\z/;return print$fh $indent,$msg}sub output {my($self,$fh)=@_;if(defined$fh){$self->{Out_FH}=$self->_new_fh($fh)}return$self->{Out_FH}}sub failure_output {my($self,$fh)=@_;if(defined$fh){$self->{Fail_FH}=$self->_new_fh($fh)}return$self->{Fail_FH}}sub todo_output {my($self,$fh)=@_;if(defined$fh){$self->{Todo_FH}=$self->_new_fh($fh)}return$self->{Todo_FH}}sub _new_fh {my$self=shift;my($file_or_fh)=shift;my$fh;if($self->is_fh($file_or_fh)){$fh=$file_or_fh}elsif(ref$file_or_fh eq 'SCALAR'){if($] >= 5.008){open$fh,">>",$file_or_fh or $self->croak("Can't open scalar ref $file_or_fh: $!")}else {$fh=Test::Builder::IO::Scalar->new($file_or_fh)or $self->croak("Can't tie scalar ref $file_or_fh")}}else {open$fh,">",$file_or_fh or $self->croak("Can't open test output log $file_or_fh: $!");_autoflush($fh)}return$fh}sub _autoflush {my($fh)=shift;my$old_fh=select$fh;$|=1;select$old_fh;return}my($Testout,$Testerr);sub _dup_stdhandles {my$self=shift;$self->_open_testhandles;_autoflush($Testout);_autoflush(\*STDOUT);_autoflush($Testerr);_autoflush(\*STDERR);$self->reset_outputs;return}sub _open_testhandles {my$self=shift;return if$self->{Opened_Testhandles};open($Testout,">&STDOUT")or die "Can't dup STDOUT:  $!";open($Testerr,">&STDERR")or die "Can't dup STDERR:  $!";$self->_copy_io_layers(\*STDOUT,$Testout);$self->_copy_io_layers(\*STDERR,$Testerr);$self->{Opened_Testhandles}=1;return}sub _copy_io_layers {my($self,$src,$dst)=@_;$self->_try(sub {require PerlIO;my@src_layers=PerlIO::get_layers($src);_apply_layers($dst,@src_layers)if@src_layers});return}sub _apply_layers {my ($fh,@layers)=@_;my%seen;my@unique=grep {$_ ne 'unix' and!$seen{$_}++}@layers;binmode($fh,join(":","","raw",@unique))}sub reset_outputs {my$self=shift;$self->output ($Testout);$self->failure_output($Testerr);$self->todo_output ($Testout);return}sub _message_at_caller {my$self=shift;local$Level=$Level + 1;my($pack,$file,$line)=$self->caller;return join("",@_)." at $file line $line.\n"}sub carp {my$self=shift;return warn$self->_message_at_caller(@_)}sub croak {my$self=shift;return die$self->_message_at_caller(@_)}sub current_test {my($self,$num)=@_;lock($self->{Curr_Test});if(defined$num){$self->{Curr_Test}=$num;my$test_results=$self->{Test_Results};if($num > @$test_results){my$start=@$test_results ? @$test_results : 0;for($start .. $num - 1){$test_results->[$_]=&share({'ok'=>1,actual_ok=>undef,reason=>'incrementing test number',type=>'unknown',name=>undef })}}elsif($num < @$test_results){$#{$test_results}=$num - 1}}return$self->{Curr_Test}}sub is_passing {my$self=shift;if(@_){$self->{Is_Passing}=shift}return$self->{Is_Passing}}sub summary {my($self)=shift;return map {$_->{'ok'}}@{$self->{Test_Results}}}sub details {my$self=shift;return @{$self->{Test_Results}}}sub todo {my($self,$pack)=@_;return$self->{Todo}if defined$self->{Todo};local$Level=$Level + 1;my$todo=$self->find_TODO($pack);return$todo if defined$todo;return ''}sub find_TODO {my($self,$pack,$set,$new_value)=@_;$pack=$pack || $self->caller(1)|| $self->exported_to;return unless$pack;no strict 'refs';my$old_value=${$pack .'::TODO'};$set and ${$pack .'::TODO'}=$new_value;return$old_value}sub in_todo {my$self=shift;local$Level=$Level + 1;return(defined$self->{Todo}|| $self->find_TODO)? 1 : 0}sub todo_start {my$self=shift;my$message=@_ ? shift : '';$self->{Start_Todo}++;if($self->in_todo){push @{$self->{Todo_Stack}}=>$self->todo}$self->{Todo}=$message;return}sub todo_end {my$self=shift;if(!$self->{Start_Todo}){$self->croak('todo_end() called without todo_start()')}$self->{Start_Todo}--;if($self->{Start_Todo}&& @{$self->{Todo_Stack}}){$self->{Todo}=pop @{$self->{Todo_Stack}}}else {delete$self->{Todo}}return}sub caller {my($self,$height)=@_;$height ||= 0;my$level=$self->level + $height + 1;my@caller;do {@caller=CORE::caller($level);$level--}until@caller;return wantarray ? @caller : $caller[0]}sub _sanity_check {my$self=shift;$self->_whoa($self->{Curr_Test}< 0,'Says here you ran a negative number of tests!');$self->_whoa($self->{Curr_Test}!=@{$self->{Test_Results}},'Somehow you got a different number of results than tests ran!');return}sub _whoa {my($self,$check,$desc)=@_;if($check){local$Level=$Level + 1;$self->croak(<<"WHOA")}return}sub _my_exit {$?=$_[0];return 1}sub _ending {my$self=shift;return if$self->no_ending;return if$self->{Ending}++;my$real_exit_code=$?;if($self->{Original_Pid}!=$$){return}if(!$self->{Have_Plan}and $self->{Curr_Test}){$self->is_passing(0);$self->diag("Tests were run but no plan was declared and done_testing() was not seen.");if($real_exit_code){$self->diag(<<"FAIL");$self->is_passing(0);_my_exit($real_exit_code)&& return}my$test_results=$self->{Test_Results};if(@$test_results){my$num_failed=grep!$_->{'ok'},@{$test_results}[0 .. $self->{Curr_Test}- 1 ];if ($num_failed > 0){my$exit_code=$num_failed <= 254 ? $num_failed : 254;_my_exit($exit_code)&& return}}_my_exit(254)&& return}if(!$self->{Have_Plan}){return}if($self->{Bailed_Out}){$self->is_passing(0);return}my$test_results=$self->{Test_Results};if(@$test_results){if($self->{No_Plan}){$self->_output_plan($self->{Curr_Test})unless$self->no_header;$self->{Expected_Tests}=$self->{Curr_Test}}my$empty_result=&share({});for my$idx (0 .. $self->{Expected_Tests}- 1){$test_results->[$idx]=$empty_result unless defined$test_results->[$idx]}my$num_failed=grep!$_->{'ok'},@{$test_results}[0 .. $self->{Curr_Test}- 1 ];my$num_extra=$self->{Curr_Test}- $self->{Expected_Tests};if($num_extra!=0){my$s=$self->{Expected_Tests}==1 ? '' : 's';$self->diag(<<"FAIL");$self->is_passing(0)}if($num_failed){my$num_tests=$self->{Curr_Test};my$s=$num_failed==1 ? '' : 's';my$qualifier=$num_extra==0 ? '' : ' run';$self->diag(<<"FAIL");$self->is_passing(0)}if($real_exit_code){$self->diag(<<"FAIL");$self->is_passing(0);_my_exit($real_exit_code)&& return}my$exit_code;if($num_failed){$exit_code=$num_failed <= 254 ? $num_failed : 254}elsif($num_extra!=0){$exit_code=255}else {$exit_code=0}_my_exit($exit_code)&& return}elsif($self->{Skip_All}){_my_exit(0)&& return}elsif($real_exit_code){$self->diag(<<"FAIL");$self->is_passing(0);_my_exit($real_exit_code)&& return}else {$self->diag("No tests run!\n");$self->is_passing(0);_my_exit(255)&& return}$self->is_passing(0);$self->_whoa(1,"We fell off the end of _ending()")}END {$Test->_ending if defined$Test}1;
  An error occurred while using $type:
  ------------------------------------
  $error
  ------------------------------------
  END
      $got
          $type
      $expect
  DIAGNOSTIC
                    %s
      %13s '%s'
  DIAGNOSTIC
  WHOA!  $desc
  This should never happen!  Please contact the author immediately!
  WHOA
  Looks like your test exited with $real_exit_code just after $self->{Curr_Test}.
  FAIL
  Looks like you planned $self->{Expected_Tests} test$s but ran $self->{Curr_Test}.
  FAIL
  Looks like you failed $num_failed test$s of $num_tests$qualifier.
  FAIL
  Looks like your test exited with $real_exit_code just after $self->{Curr_Test}.
  FAIL
  Looks like your test exited with $real_exit_code before it could output anything.
  FAIL
TEST_BUILDER

$fatpacked{"Test/Builder/IO/Scalar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_IO_SCALAR';
  package Test::Builder::IO::Scalar;use Carp;use strict;use vars qw($VERSION @ISA);use IO::Handle;use 5.005;$VERSION="2.113";@ISA=qw(IO::Handle);sub new {my$proto=shift;my$class=ref($proto)|| $proto;my$self=bless \do {local*FH},$class;tie *$self,$class,$self;$self->open(@_);$self}sub DESTROY {shift->close}sub open {my ($self,$sref)=@_;defined($sref)or do {my$s='';$sref=\$s};(ref($sref)eq "SCALAR")or croak "open() needs a ref to a scalar";*$self->{Pos}=0;*$self->{SR}=$sref;$self}sub opened {*{shift()}->{SR}}sub close {my$self=shift;%{*$self}=();1}sub flush {"0 but true"}sub getc {my$self=shift;return undef if$self->eof;substr(${*$self->{SR}},*$self->{Pos}++,1)}sub getline {my$self=shift;return undef if$self->eof;my$sr=*$self->{SR};my$i=*$self->{Pos};if (!defined($/)){*$self->{Pos}=length $$sr;return substr($$sr,$i)}elsif ($/ eq "\012"){my$len=length($$sr);for (;$i < $len;++$i){last if ord (substr ($$sr,$i,1))==10}my$line;if ($i < $len){$line=substr ($$sr,*$self->{Pos},$i - *$self->{Pos}+ 1);*$self->{Pos}=$i+1}else {$line=substr ($$sr,*$self->{Pos},$i - *$self->{Pos});*$self->{Pos}=$len}return$line}elsif (ref($/)){my$len=length($$sr);my$i=${$/}+ 0;my$line=substr ($$sr,*$self->{Pos},$i);*$self->{Pos}+= $i;*$self->{Pos}=$len if (*$self->{Pos}> $len);return$line}else {pos($$sr)=$i;length($/)or (($$sr =~ m/\G\n*/g)and ($i=pos($$sr)));if (length($/)? $$sr =~ m,\Q$/\E,g : $$sr =~ m,\n\n,g){*$self->{Pos}=pos $$sr;return substr($$sr,$i,*$self->{Pos}-$i)}else {*$self->{Pos}=length $$sr;return substr($$sr,$i)}}}sub getlines {my$self=shift;wantarray or croak("can't call getlines in scalar context!");my ($line,@lines);push@lines,$line while (defined($line=$self->getline));@lines}sub print {my$self=shift;*$self->{Pos}=length(${*$self->{SR}}.= join('',@_).(defined($\)? $\ : ""));1}sub _unsafe_print {my$self=shift;my$append=join('',@_).$\;${*$self->{SR}}.= $append;*$self->{Pos}+= length($append);1}sub _old_print {my$self=shift;${*$self->{SR}}.= join('',@_).$\;*$self->{Pos}=length(${*$self->{SR}});1}sub read {my$self=$_[0];my$n=$_[2];my$off=$_[3]|| 0;my$read=substr(${*$self->{SR}},*$self->{Pos},$n);$n=length($read);*$self->{Pos}+= $n;($off ? substr($_[1],$off): $_[1])=$read;return$n}sub write {my$self=$_[0];my$n=$_[2];my$off=$_[3]|| 0;my$data=substr($_[1],$off,$n);$n=length($data);$self->print($data);return$n}sub sysread {my$self=shift;$self->read(@_)}sub syswrite {my$self=shift;$self->write(@_)}sub autoflush {}sub binmode {}sub clearerr {1}sub eof {my$self=shift;(*$self->{Pos}>= length(${*$self->{SR}}))}sub seek {my ($self,$pos,$whence)=@_;my$eofpos=length(${*$self->{SR}});if ($whence==0){*$self->{Pos}=$pos}elsif ($whence==1){*$self->{Pos}+= $pos}elsif ($whence==2){*$self->{Pos}=$eofpos + $pos}else {croak "bad seek whence ($whence)"}if (*$self->{Pos}< 0){*$self->{Pos}=0}if (*$self->{Pos}> $eofpos){*$self->{Pos}=$eofpos}return 1}sub sysseek {my$self=shift;$self->seek (@_)}sub tell {*{shift()}->{Pos}}sub use_RS {my ($self,$yesno)=@_;carp "use_RS is deprecated and ignored; \$/ is always consulted\n"}sub setpos {shift->seek($_[0],0)}*getpos=\&tell;sub sref {*{shift()}->{SR}}sub TIEHANDLE {((defined($_[1])&& UNIVERSAL::isa($_[1],__PACKAGE__))? $_[1]: shift->new(@_))}sub GETC {shift->getc(@_)}sub PRINT {shift->print(@_)}sub PRINTF {shift->print(sprintf(shift,@_))}sub READ {shift->read(@_)}sub READLINE {wantarray ? shift->getlines(@_): shift->getline(@_)}sub WRITE {shift->write(@_)}sub CLOSE {shift->close(@_)}sub SEEK {shift->seek(@_)}sub TELL {shift->tell(@_)}sub EOF {shift->eof(@_)}1;
TEST_BUILDER_IO_SCALAR

$fatpacked{"Test/Builder/Module.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_MODULE';
  package Test::Builder::Module;use strict;use Test::Builder 1.00;require Exporter;our@ISA=qw(Exporter);our$VERSION='1.001014';$VERSION=eval$VERSION;sub import {my($class)=shift;return 1 if$class eq 'Test::Builder::Module';my$test=$class->builder;my$caller=caller;$test->exported_to($caller);$class->import_extra(\@_);my(@imports)=$class->_strip_imports(\@_);$test->plan(@_);$class->export_to_level(1,$class,@imports)}sub _strip_imports {my$class=shift;my$list=shift;my@imports=();my@other=();my$idx=0;while($idx <= $#{$list}){my$item=$list->[$idx];if(defined$item and $item eq 'import'){push@imports,@{$list->[$idx + 1 ]};$idx++}else {push@other,$item}$idx++}@$list=@other;return@imports}sub import_extra {}sub builder {return Test::Builder->new}1;
TEST_BUILDER_MODULE

$fatpacked{"Test/Builder/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_TESTER';
  package Test::Builder::Tester;use strict;our$VERSION="1.28";use Test::Builder 0.99;use Symbol;use Carp;my$t=Test::Builder->new;use Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(test_out test_err test_fail test_diag test_test line_num);sub import {my$class=shift;my(@plan)=@_;my$caller=caller;$t->exported_to($caller);$t->plan(@plan);my@imports=();for my$idx (0 .. $#plan){if($plan[$idx]eq 'import'){@imports=@{$plan[$idx + 1 ]};last}}__PACKAGE__->export_to_level(1,__PACKAGE__,@imports)}my$output_handle=gensym;my$error_handle=gensym;my$out=tie *$output_handle,"Test::Builder::Tester::Tie","STDOUT";my$err=tie *$error_handle,"Test::Builder::Tester::Tie","STDERR";my$testing=0;my$testing_num;my$original_is_passing;my$original_output_handle;my$original_failure_handle;my$original_todo_handle;my$original_harness_env;sub _start_testing {$original_harness_env=$ENV{HARNESS_ACTIVE}|| 0;$ENV{HARNESS_ACTIVE}=0;$original_output_handle=$t->output();$original_failure_handle=$t->failure_output();$original_todo_handle=$t->todo_output();$t->output($output_handle);$t->failure_output($error_handle);$t->todo_output($output_handle);$out->reset();$err->reset();$testing=1;$testing_num=$t->current_test;$t->current_test(0);$original_is_passing=$t->is_passing;$t->is_passing(1);$t->no_ending(1)}sub test_out {_start_testing()unless$testing;$out->expect(@_)}sub test_err {_start_testing()unless$testing;$err->expect(@_)}sub test_fail {_start_testing()unless$testing;my($package,$filename,$line)=caller;$line=$line + (shift()|| 0);$err->expect("#     Failed test ($filename at line $line)")}sub test_diag {_start_testing()unless$testing;local $_;$err->expect(map {"# $_"}@_)}sub test_test {my$mess;my%args;if(@_==1){$mess=shift}else {%args=@_;$mess=$args{name}if exists($args{name});$mess=$args{title}if exists($args{title});$mess=$args{label}if exists($args{label})}croak "Not testing.  You must declare output with a test function first." unless$testing;$t->output($original_output_handle);$t->failure_output($original_failure_handle);$t->todo_output($original_todo_handle);$t->current_test($testing_num);$testing=0;$t->is_passing($original_is_passing);$ENV{HARNESS_ACTIVE}=$original_harness_env;unless($t->ok(($args{skip_out}|| $out->check)&& ($args{skip_err}|| $err->check),$mess)){local $_;$t->diag(map {"$_\n"}$out->complaint)unless$args{skip_out}|| $out->check;$t->diag(map {"$_\n"}$err->complaint)unless$args{skip_err}|| $err->check}}sub line_num {my($package,$filename,$line)=caller;return$line + (shift()|| 0)}my$color;sub color {$color=shift if @_;$color}1;package Test::Builder::Tester::Tie;sub expect {my$self=shift;my@checks=@_;for my$check (@checks){$check=$self->_account_for_subtest($check);$check=$self->_translate_Failed_check($check);push @{$self->{wanted}},ref$check ? $check : "$check\n"}}sub _account_for_subtest {my($self,$check)=@_;return ref($check)? $check : $t->_indent .$check}sub _translate_Failed_check {my($self,$check)=@_;if($check =~ /\A(.*)#     (Failed .*test) \((.*?) at line (\d+)\)\Z(?!\n)/){$check="/\Q$1\E#\\s+\Q$2\E.*?\\n?.*?\Qat $3\E line \Q$4\E.*\\n?/"}return$check}sub check {my$self=shift;local $^W=0;my@checks=@{$self->{wanted}};my$got=$self->{got};for my$check (@checks){$check="\Q$check\E" unless($check =~ s,^/(.*)/$,$1, or ref$check);return 0 unless$got =~ s/^$check//}return length$got==0}sub complaint {my$self=shift;my$type=$self->type;my$got=$self->got;my$wanted=join '',@{$self->wanted};if(Test::Builder::Tester::color){eval {require Term::ANSIColor};unless($@){my$green=Term::ANSIColor::color("black").Term::ANSIColor::color("on_green");my$red=Term::ANSIColor::color("black").Term::ANSIColor::color("on_red");my$reset=Term::ANSIColor::color("reset");my$char=0;$char++ while substr($got,$char,1)eq substr($wanted,$char,1);my$start=$green .substr($wanted,0,$char);my$gotend=$red .substr($got,$char).$reset;my$wantedend=$red .substr($wanted,$char).$reset;$start =~ s/\n/$reset\n$green/g;$gotend =~ s/\n/$reset\n$red/g;$wantedend =~ s/\n/$reset\n$red/g;$got=$start .$gotend;$wanted=$start .$wantedend}}return "$type is:\n" ."$got\nnot:\n$wanted\nas expected"}sub reset {my$self=shift;%$self=(type=>$self->{type},got=>'',wanted=>[],)}sub got {my$self=shift;return$self->{got}}sub wanted {my$self=shift;return$self->{wanted}}sub type {my$self=shift;return$self->{type}}sub PRINT {my$self=shift;$self->{got}.= join '',@_}sub TIEHANDLE {my($class,$type)=@_;my$self=bless {type=>$type },$class;$self->reset;return$self}sub READ {}sub READLINE {}sub GETC {}sub FILENO {}1;
TEST_BUILDER_TESTER

$fatpacked{"Test/Builder/Tester/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_BUILDER_TESTER_COLOR';
  package Test::Builder::Tester::Color;use strict;our$VERSION="1.290001";require Test::Builder::Tester;sub import {Test::Builder::Tester::color(1)}1;
TEST_BUILDER_TESTER_COLOR

$fatpacked{"Test/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_EXCEPTION';
  use strict;use warnings;package Test::Exception;use Test::Builder;use Sub::Uplevel qw(uplevel);use base qw(Exporter);our$VERSION='0.43';$VERSION=eval$VERSION;our@EXPORT=qw(dies_ok lives_ok throws_ok lives_and);my$Tester=Test::Builder->new;sub import {my$self=shift;if (@_){my$package=caller;$Tester->exported_to($package);$Tester->plan(@_)};$self->export_to_level(1,$self,$_)foreach@EXPORT}sub _quiet_caller (;$) {my$height=$_[0];$height++;if (CORE::caller()eq 'DB'){package DB;if(wantarray){if (!@_){return (CORE::caller($height))[0..2]}else {my@frame_info=CORE::caller($height);@DB::args=();return@frame_info}}return CORE::caller($height)}else {if(wantarray and!@_){return (CORE::caller($height))[0..2]}else {return CORE::caller($height)}}}sub _try_as_caller {my$coderef=shift;local*CORE::GLOBAL::caller;{no warnings 'redefine';*CORE::GLOBAL::caller=\&_quiet_caller}eval {uplevel 3,$coderef};return $@};sub _is_exception {my$exception=shift;return ref$exception || $exception ne ''};sub _exception_as_string {my ($prefix,$exception)=@_;return "$prefix normal exit" unless _is_exception($exception);my$class=ref$exception;$exception="$class ($exception)" if$class && "$exception" !~ m/^\Q$class/;chomp$exception;return "$prefix $exception"};sub throws_ok (&$;$) {my ($coderef,$expecting,$description)=@_;unless (defined$expecting){require Carp;Carp::croak("throws_ok: must pass exception class/object or regex")}$description=_exception_as_string("threw",$expecting)unless defined$description;my$exception=_try_as_caller($coderef);my$regex=$Tester->maybe_regex($expecting);my$ok=$regex ? ($exception =~ m/$regex/): eval {$exception->isa(ref$expecting ? ref$expecting : $expecting)};$Tester->ok($ok,$description);unless ($ok){$Tester->diag(_exception_as_string("expecting:",$expecting));$Tester->diag(_exception_as_string("found:",$exception))};$@=$exception;return$ok};sub dies_ok (&;$) {my ($coderef,$description)=@_;my$exception=_try_as_caller($coderef);my$ok=$Tester->ok(_is_exception($exception),$description);$@=$exception;return$ok}sub lives_ok (&;$) {my ($coderef,$description)=@_;my$exception=_try_as_caller($coderef);my$ok=$Tester->ok(!_is_exception($exception),$description);$Tester->diag(_exception_as_string("died:",$exception))unless$ok;$@=$exception;return$ok}sub lives_and (&;$) {my ($test,$description)=@_;{my$ok=\&Test::Builder::ok;no warnings;local*Test::Builder::ok=sub {local$Test::Builder::Level=$Test::Builder::Level + 1;$_[2]=$description unless defined $_[2];$ok->(@_)};use warnings;eval {$test->()}and return 1};my$exception=$@;if (_is_exception($exception)){$Tester->ok(0,$description);$Tester->diag(_exception_as_string("died:",$exception))};$@=$exception;return}1;
TEST_EXCEPTION

$fatpacked{"Test/Mojo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_MOJO';
  package Test::Mojo;use Mojo::Base -base;use Mojo::IOLoop;use Mojo::JSON 'j';use Mojo::JSON::Pointer;use Mojo::Server;use Mojo::UserAgent;use Mojo::Util qw(decode encode);use Test::More ();has [qw(message success tx)];has ua=>sub {Mojo::UserAgent->new->ioloop(Mojo::IOLoop->singleton)};$ENV{MOJO_LOG_LEVEL}||= $ENV{HARNESS_IS_VERBOSE}? 'debug' : 'fatal';sub app {my ($self,$app)=@_;return$self->ua->server->app unless$app;$self->ua->server->app($app);return$self}sub content_is {my ($self,$value,$desc)=@_;$desc ||= 'exact match for content';return$self->_test('is',$self->tx->res->text,$value,$desc)}sub content_isnt {my ($self,$value,$desc)=@_;$desc ||= 'no match for content';return$self->_test('isnt',$self->tx->res->text,$value,$desc)}sub content_like {my ($self,$regex,$desc)=@_;$desc ||= 'content is similar';return$self->_test('like',$self->tx->res->text,$regex,$desc)}sub content_type_is {my ($self,$type,$desc)=@_;$desc ||= "Content-Type: $type";return$self->_test('is',$self->tx->res->headers->content_type,$type,$desc)}sub content_type_isnt {my ($self,$type,$desc)=@_;$desc ||= "not Content-Type: $type";return$self->_test('isnt',$self->tx->res->headers->content_type,$type,$desc)}sub content_type_like {my ($self,$regex,$desc)=@_;$desc ||= 'Content-Type is similar';return$self->_test('like',$self->tx->res->headers->content_type,$regex,$desc)}sub content_type_unlike {my ($self,$regex,$desc)=@_;$desc ||= 'Content-Type is not similar';return$self->_test('unlike',$self->tx->res->headers->content_type,$regex,$desc)}sub content_unlike {my ($self,$regex,$desc)=@_;$desc ||= 'content is not similar';return$self->_test('unlike',$self->tx->res->text,$regex,$desc)}sub delete_ok {shift->_build_ok(DELETE=>@_)}sub element_count_is {my ($self,$selector,$count,$desc)=@_;$desc ||= encode 'UTF-8',qq{element count for selector "$selector"};my$size=$self->tx->res->dom->find($selector)->size;return$self->_test('is',$size,$count,$desc)}sub element_exists {my ($self,$selector,$desc)=@_;$desc ||= encode 'UTF-8',qq{element for selector "$selector" exists};return$self->_test('ok',$self->tx->res->dom->at($selector),$desc)}sub element_exists_not {my ($self,$selector,$desc)=@_;$desc ||= encode 'UTF-8',qq{no element for selector "$selector"};return$self->_test('ok',!$self->tx->res->dom->at($selector),$desc)}sub finish_ok {my$self=shift;$self->tx->finish(@_)if$self->tx->is_websocket;Mojo::IOLoop->one_tick while!$self->{finished};return$self->_test('ok',1,'closed WebSocket')}sub finished_ok {my ($self,$code)=@_;Mojo::IOLoop->one_tick while!$self->{finished};Test::More::diag "WebSocket closed with status $self->{finished}[0]" unless my$ok=grep {$self->{finished}[0]==$_}$code,1006;return$self->_test('ok',$ok,"WebSocket closed with status $code")}sub get_ok {shift->_build_ok(GET=>@_)}sub head_ok {shift->_build_ok(HEAD=>@_)}sub header_is {my ($self,$name,$value,$desc)=@_;$desc ||= "$name: " .($value // '');return$self->_test('is',$self->tx->res->headers->header($name),$value,$desc)}sub header_isnt {my ($self,$name,$value,$desc)=@_;$desc ||= "not $name: " .($value // '');return$self->_test('isnt',$self->tx->res->headers->header($name),$value,$desc)}sub header_like {my ($self,$name,$regex,$desc)=@_;$desc ||= "$name is similar";return$self->_test('like',$self->tx->res->headers->header($name),$regex,$desc)}sub header_unlike {my ($self,$name,$regex,$desc)=@_;$desc ||= "$name is not similar";return$self->_test('unlike',$self->tx->res->headers->header($name),$regex,$desc)}sub json_has {my ($self,$p,$desc)=@_;$desc ||= encode 'UTF-8',qq{has value for JSON Pointer "$p"};return$self->_test('ok',!!Mojo::JSON::Pointer->new($self->tx->res->json)->contains($p),$desc)}sub json_hasnt {my ($self,$p,$desc)=@_;$desc ||= encode 'UTF-8',qq{has no value for JSON Pointer "$p"};return$self->_test('ok',!Mojo::JSON::Pointer->new($self->tx->res->json)->contains($p),$desc)}sub json_is {my$self=shift;my ($p,$data)=@_ > 1 ? (shift,shift): ('',shift);my$desc=encode 'UTF-8',shift || qq{exact match for JSON Pointer "$p"};return$self->_test('is_deeply',$self->tx->res->json($p),$data,$desc)}sub json_like {my ($self,$p,$regex,$desc)=@_;$desc ||= encode 'UTF-8',qq{similar match for JSON Pointer "$p"};return$self->_test('like',$self->tx->res->json($p),$regex,$desc)}sub json_message_has {my ($self,$p,$desc)=@_;$desc ||= encode 'UTF-8',qq{has value for JSON Pointer "$p"};return$self->_test('ok',$self->_json(contains=>$p),$desc)}sub json_message_hasnt {my ($self,$p,$desc)=@_;$desc ||= encode 'UTF-8',qq{has no value for JSON Pointer "$p"};return$self->_test('ok',!$self->_json(contains=>$p),$desc)}sub json_message_is {my$self=shift;my ($p,$data)=@_ > 1 ? (shift,shift): ('',shift);my$desc=encode 'UTF-8',shift || qq{exact match for JSON Pointer "$p"};return$self->_test('is_deeply',$self->_json(get=>$p),$data,$desc)}sub json_message_like {my ($self,$p,$regex,$desc)=@_;$desc ||= encode 'UTF-8',qq{similar match for JSON Pointer "$p"};return$self->_test('like',$self->_json(get=>$p),$regex,$desc)}sub json_message_unlike {my ($self,$p,$regex,$desc)=@_;$desc ||= encode 'UTF-8',qq{no similar match for JSON Pointer "$p"};return$self->_test('unlike',$self->_json(get=>$p),$regex,$desc)}sub json_unlike {my ($self,$p,$regex,$desc)=@_;$desc ||= encode 'UTF-8',qq{no similar match for JSON Pointer "$p"};return$self->_test('unlike',$self->tx->res->json($p),$regex,$desc)}sub message_is {my ($self,$value,$desc)=@_;return$self->_message('is',$value,$desc || 'exact match for message')}sub message_isnt {my ($self,$value,$desc)=@_;return$self->_message('isnt',$value,$desc || 'no match for message')}sub message_like {my ($self,$regex,$desc)=@_;return$self->_message('like',$regex,$desc || 'message is similar')}sub message_ok {my ($self,$desc)=@_;return$self->_test('ok',!!$self->_wait,$desc || 'message received')}sub message_unlike {my ($self,$regex,$desc)=@_;return$self->_message('unlike',$regex,$desc || 'message is not similar')}sub new {my$self=shift->SUPER::new;return$self unless my$app=shift;return$self->app(ref$app ? $app : Mojo::Server->new->build_app($app))}sub options_ok {shift->_build_ok(OPTIONS=>@_)}sub or {my ($self,$cb)=@_;$self->$cb unless$self->success;return$self}sub patch_ok {shift->_build_ok(PATCH=>@_)}sub post_ok {shift->_build_ok(POST=>@_)}sub put_ok {shift->_build_ok(PUT=>@_)}sub request_ok {shift->_request_ok($_[0],$_[0]->req->url->to_string)}sub reset_session {my$self=shift;$self->ua->cookie_jar->empty;return$self->tx(undef)}sub send_ok {my ($self,$msg,$desc)=@_;$desc ||= 'send message';return$self->_test('ok',0,$desc)unless$self->tx->is_websocket;$self->tx->send($msg=>sub {Mojo::IOLoop->stop});Mojo::IOLoop->start;return$self->_test('ok',1,$desc)}sub status_is {my ($self,$status,$desc)=@_;$desc ||= "$status " .$self->tx->res->default_message($status);return$self->_test('is',$self->tx->res->code,$status,$desc)}sub status_isnt {my ($self,$status,$desc)=@_;$desc ||= "not $status " .$self->tx->res->default_message($status);return$self->_test('isnt',$self->tx->res->code,$status,$desc)}sub text_is {my ($self,$selector,$value,$desc)=@_;$desc ||= encode 'UTF-8',qq{exact match for selector "$selector"};return$self->_test('is',$self->_text($selector),$value,$desc)}sub text_isnt {my ($self,$selector,$value,$desc)=@_;$desc ||= encode 'UTF-8',qq{no match for selector "$selector"};return$self->_test('isnt',$self->_text($selector),$value,$desc)}sub text_like {my ($self,$selector,$regex,$desc)=@_;$desc ||= encode 'UTF-8',qq{similar match for selector "$selector"};return$self->_test('like',$self->_text($selector),$regex,$desc)}sub text_unlike {my ($self,$selector,$regex,$desc)=@_;$desc ||= encode 'UTF-8',qq{no similar match for selector "$selector"};return$self->_test('unlike',$self->_text($selector),$regex,$desc)}sub websocket_ok {my$self=shift;return$self->_request_ok($self->ua->build_websocket_tx(@_),$_[0])}sub _build_ok {my ($self,$method,$url)=(shift,shift,shift);local$Test::Builder::Level=$Test::Builder::Level + 1;return$self->_request_ok($self->ua->build_tx($method,$url,@_),$url)}sub _json {my ($self,$method,$p)=@_;return Mojo::JSON::Pointer->new(j(@{$self->message // []}[1]))->$method($p)}sub _message {my ($self,$name,$value,$desc)=@_;local$Test::Builder::Level=$Test::Builder::Level + 1;my ($type,$msg)=@{$self->message // []};if (ref$value eq 'HASH'){my$expect=exists$value->{text}? 'text' : 'binary';$value=$value->{$expect};$msg='' unless ($type // '')eq $expect}else {$msg=decode 'UTF-8',$msg if ($type // '')eq 'text'}return$self->_test($name,$msg // '',$value,$desc)}sub _request_ok {my ($self,$tx,$url)=@_;local$Test::Builder::Level=$Test::Builder::Level + 1;if ($tx->req->is_handshake){@$self{qw(finished messages)}=(undef,[]);$self->ua->start($tx=>sub {my ($ua,$tx)=@_;$self->{finished}=[]unless$self->tx($tx)->tx->is_websocket;$tx->on(finish=>sub {shift;$self->{finished}=[@_]});$tx->on(binary=>sub {push @{$self->{messages}},[binary=>pop]});$tx->on(text=>sub {push @{$self->{messages}},[text=>pop]});Mojo::IOLoop->stop});Mojo::IOLoop->start;my$desc=encode 'UTF-8',"WebSocket handshake with $url";return$self->_test('ok',$self->tx->is_websocket,$desc)}$self->tx($self->ua->start($tx));my$err=$self->tx->error;Test::More::diag$err->{message}if!(my$ok=!$err->{message}|| $err->{code})&& $err;my$desc=encode 'UTF-8',"@{[uc $tx->req->method]} $url";return$self->_test('ok',$ok,$desc)}sub _test {my ($self,$name,@args)=@_;local$Test::Builder::Level=$Test::Builder::Level + 2;return$self->success(!!Test::More->can($name)->(@args))}sub _text {return '' unless my$e=shift->tx->res->dom->at(shift);return$e->text}sub _wait {my$self=shift;Mojo::IOLoop->one_tick while!$self->{finished}&&!@{$self->{messages}};return$self->message(shift @{$self->{messages}})->message}1;
TEST_MOJO

$fatpacked{"Test/More.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_MORE';
  package Test::More;use 5.006;use strict;use warnings;sub _carp {my($file,$line)=(caller(1))[1,2 ];return warn @_," at $file line $line\n"}our$VERSION='1.001014';$VERSION=eval$VERSION;use Test::Builder::Module 0.99;our@ISA=qw(Test::Builder::Module);our@EXPORT=qw(ok use_ok require_ok is isnt like unlike is_deeply cmp_ok skip todo todo_skip pass fail eq_array eq_hash eq_set $TODO plan done_testing can_ok isa_ok new_ok diag note explain subtest BAIL_OUT);sub plan {my$tb=Test::More->builder;return$tb->plan(@_)}sub import_extra {my$class=shift;my$list=shift;my@other=();my$idx=0;while($idx <= $#{$list}){my$item=$list->[$idx];if(defined$item and $item eq 'no_diag'){$class->builder->no_diag(1)}else {push@other,$item}$idx++}@$list=@other;return}sub done_testing {my$tb=Test::More->builder;$tb->done_testing(@_)}sub ok ($;$) {my($test,$name)=@_;my$tb=Test::More->builder;return$tb->ok($test,$name)}sub is ($$;$) {my$tb=Test::More->builder;return$tb->is_eq(@_)}sub isnt ($$;$) {my$tb=Test::More->builder;return$tb->isnt_eq(@_)}*isn't=\&isnt;sub like ($$;$) {my$tb=Test::More->builder;return$tb->like(@_)}sub unlike ($$;$) {my$tb=Test::More->builder;return$tb->unlike(@_)}sub cmp_ok($$$;$) {my$tb=Test::More->builder;return$tb->cmp_ok(@_)}sub can_ok ($@) {my($proto,@methods)=@_;my$class=ref$proto || $proto;my$tb=Test::More->builder;unless($class){my$ok=$tb->ok(0,"->can(...)");$tb->diag('    can_ok() called with empty class or reference');return$ok}unless(@methods){my$ok=$tb->ok(0,"$class->can(...)");$tb->diag('    can_ok() called with no methods');return$ok}my@nok=();for my$method (@methods){$tb->_try(sub {$proto->can($method)})or push@nok,$method}my$name=(@methods==1)? "$class->can('$methods[0]')" : "$class->can(...)" ;my$ok=$tb->ok(!@nok,$name);$tb->diag(map "    $class->can('$_') failed\n",@nok);return$ok}sub isa_ok ($$;$) {my($thing,$class,$thing_name)=@_;my$tb=Test::More->builder;my$whatami;if(!defined$thing){$whatami='undef'}elsif(ref$thing){$whatami='reference';local($@,$!);require Scalar::Util;if(Scalar::Util::blessed($thing)){$whatami='object'}}else {$whatami='class'}my($rslt,$error)=$tb->_try(sub {$thing->isa($class)});if($error){die <<WHOA unless$error =~ /^Can't (locate|call) method "isa"/}if($whatami eq 'reference'){$rslt=UNIVERSAL::isa($thing,$class)}my($diag,$name);if(defined$thing_name){$name="'$thing_name' isa '$class'";$diag=defined$thing ? "'$thing_name' isn't a '$class'" : "'$thing_name' isn't defined"}elsif($whatami eq 'object'){my$my_class=ref$thing;$thing_name=qq[An object of class '$my_class'];$name="$thing_name isa '$class'";$diag="The object of class '$my_class' isn't a '$class'"}elsif($whatami eq 'reference'){my$type=ref$thing;$thing_name=qq[A reference of type '$type'];$name="$thing_name isa '$class'";$diag="The reference of type '$type' isn't a '$class'"}elsif($whatami eq 'undef'){$thing_name='undef';$name="$thing_name isa '$class'";$diag="$thing_name isn't defined"}elsif($whatami eq 'class'){$thing_name=qq[The class (or class-like) '$thing'];$name="$thing_name isa '$class'";$diag="$thing_name isn't a '$class'"}else {die}my$ok;if($rslt){$ok=$tb->ok(1,$name)}else {$ok=$tb->ok(0,$name);$tb->diag("    $diag\n")}return$ok}sub new_ok {my$tb=Test::More->builder;$tb->croak("new_ok() must be given at least a class")unless @_;my($class,$args,$object_name)=@_;$args ||= [];my$obj;my($success,$error)=$tb->_try(sub {$obj=$class->new(@$args);1});if($success){local$Test::Builder::Level=$Test::Builder::Level + 1;isa_ok$obj,$class,$object_name}else {$class='undef' if!defined$class;$tb->ok(0,"$class->new() died");$tb->diag("    Error was:  $error")}return$obj}sub subtest {my ($name,$subtests)=@_;my$tb=Test::More->builder;return$tb->subtest(@_)}sub pass (;$) {my$tb=Test::More->builder;return$tb->ok(1,@_)}sub fail (;$) {my$tb=Test::More->builder;return$tb->ok(0,@_)}sub require_ok ($) {my($module)=shift;my$tb=Test::More->builder;my$pack=caller;$module=qq['$module'] unless _is_module_name($module);my$code=<<REQUIRE;my($eval_result,$eval_error)=_eval($code);my$ok=$tb->ok($eval_result,"require $module;");unless($ok){chomp$eval_error;$tb->diag(<<DIAGNOSTIC)}return$ok}sub _is_module_name {my$module=shift;$module =~ s/\b::\b//g;return$module =~ /^[a-zA-Z]\w*$/ ? 1 : 0}sub use_ok ($;@) {my($module,@imports)=@_;@imports=()unless@imports;my$tb=Test::More->builder;my($pack,$filename,$line)=caller;$filename =~ y/\n\r/_/;my$code;if(@imports==1 and $imports[0]=~ /^\d+(?:\.\d+)?$/){$code=<<USE}else {$code=<<USE}my($eval_result,$eval_error)=_eval($code,\@imports);my$ok=$tb->ok($eval_result,"use $module;");unless($ok){chomp$eval_error;$@ =~ s{^BEGIN failed--compilation aborted at .*$}
  WHOA! I tried to call ->isa on your $whatami and got some weird error.
  Here's the error.
  $error
  WHOA
  package $pack;
  require $module;
  1;
  REQUIRE
      Tried to require '$module'.
      Error:  $eval_error
  DIAGNOSTIC
  package $pack;
  
  #line $line $filename
  use $module $imports[0];
  1;
  USE
  package $pack;
  
  #line $line $filename
  use $module \@{\$args[0]};
  1;
  USE
                  {BEGIN failed--compilation aborted at $filename line $line.}m;$tb->diag(<<DIAGNOSTIC)}return$ok}sub _eval {my($code,@args)=@_;my($sigdie,$eval_result,$eval_error);{local($@,$!,$SIG{__DIE__});$eval_result=eval$code;$eval_error=$@;$sigdie=$SIG{__DIE__}|| undef}$SIG{__DIE__}=$sigdie if defined$sigdie;return($eval_result,$eval_error)}our(@Data_Stack,%Refs_Seen);my$DNE=bless [],'Does::Not::Exist';sub _dne {return ref $_[0]eq ref$DNE}sub is_deeply {my$tb=Test::More->builder;unless(@_==2 or @_==3){my$msg=<<'WARNING';chop$msg;_carp sprintf$msg,scalar @_;return$tb->ok(0)}my($got,$expected,$name)=@_;$tb->_unoverload_str(\$expected,\$got);my$ok;if(!ref$got and!ref$expected){$ok=$tb->is_eq($got,$expected,$name)}elsif(!ref$got xor!ref$expected){$ok=$tb->ok(0,$name);$tb->diag(_format_stack({vals=>[$got,$expected ]}))}else {local@Data_Stack=();if(_deep_check($got,$expected)){$ok=$tb->ok(1,$name)}else {$ok=$tb->ok(0,$name);$tb->diag(_format_stack(@Data_Stack))}}return$ok}sub _format_stack {my(@Stack)=@_;my$var='$FOO';my$did_arrow=0;for my$entry (@Stack){my$type=$entry->{type}|| '';my$idx=$entry->{'idx'};if($type eq 'HASH'){$var .= "->" unless$did_arrow++;$var .= "{$idx}"}elsif($type eq 'ARRAY'){$var .= "->" unless$did_arrow++;$var .= "[$idx]"}elsif($type eq 'REF'){$var="\${$var}"}}my@vals=@{$Stack[-1]{vals}}[0,1 ];my@vars=();($vars[0]=$var)=~ s/\$FOO/     \$got/;($vars[1]=$var)=~ s/\$FOO/\$expected/;my$out="Structures begin differing at:\n";for my$idx (0 .. $#vals){my$val=$vals[$idx];$vals[$idx]=!defined$val ? 'undef' : _dne($val)? "Does not exist" : ref$val ? "$val" : "'$val'"}$out .= "$vars[0] = $vals[0]\n";$out .= "$vars[1] = $vals[1]\n";$out =~ s/^/    /msg;return$out}sub _type {my$thing=shift;return '' if!ref$thing;for my$type (qw(Regexp ARRAY HASH REF SCALAR GLOB CODE)){return$type if UNIVERSAL::isa($thing,$type)}return ''}sub diag {return Test::More->builder->diag(@_)}sub note {return Test::More->builder->note(@_)}sub explain {return Test::More->builder->explain(@_)}sub skip {my($why,$how_many)=@_;my$tb=Test::More->builder;unless(defined$how_many){_carp "skip() needs to know \$how_many tests are in the block" unless$tb->has_plan eq 'no_plan';$how_many=1}if(defined$how_many and $how_many =~ /\D/){_carp "skip() was passed a non-numeric number of tests.  Did you get the arguments backwards?";$how_many=1}for(1 .. $how_many){$tb->skip($why)}no warnings 'exiting';last SKIP}sub todo_skip {my($why,$how_many)=@_;my$tb=Test::More->builder;unless(defined$how_many){_carp "todo_skip() needs to know \$how_many tests are in the block" unless$tb->has_plan eq 'no_plan';$how_many=1}for(1 .. $how_many){$tb->todo_skip($why)}no warnings 'exiting';last TODO}sub BAIL_OUT {my$reason=shift;my$tb=Test::More->builder;$tb->BAIL_OUT($reason)}sub eq_array {local@Data_Stack=();_deep_check(@_)}sub _eq_array {my($a1,$a2)=@_;if(grep _type($_)ne 'ARRAY',$a1,$a2){warn "eq_array passed a non-array ref";return 0}return 1 if$a1 eq $a2;my$ok=1;my$max=$#$a1 > $#$a2 ? $#$a1 : $#$a2;for(0 .. $max){my$e1=$_ > $#$a1 ? $DNE : $a1->[$_];my$e2=$_ > $#$a2 ? $DNE : $a2->[$_];next if _equal_nonrefs($e1,$e2);push@Data_Stack,{type=>'ARRAY',idx=>$_,vals=>[$e1,$e2 ]};$ok=_deep_check($e1,$e2);pop@Data_Stack if$ok;last unless$ok}return$ok}sub _equal_nonrefs {my($e1,$e2)=@_;return if ref$e1 or ref$e2;if (defined$e1){return 1 if defined$e2 and $e1 eq $e2}else {return 1 if!defined$e2}return}sub _deep_check {my($e1,$e2)=@_;my$tb=Test::More->builder;my$ok=0;local%Refs_Seen=%Refs_Seen;{$tb->_unoverload_str(\$e1,\$e2);my$same_ref=!(!ref$e1 xor!ref$e2);my$not_ref=(!ref$e1 and!ref$e2);if(defined$e1 xor defined$e2){$ok=0}elsif(!defined$e1 and!defined$e2){$ok=1}elsif(_dne($e1)xor _dne($e2)){$ok=0}elsif($same_ref and($e1 eq $e2)){$ok=1}elsif($not_ref){push@Data_Stack,{type=>'',vals=>[$e1,$e2 ]};$ok=0}else {if($Refs_Seen{$e1}){return$Refs_Seen{$e1}eq $e2}else {$Refs_Seen{$e1}="$e2"}my$type=_type($e1);$type='DIFFERENT' unless _type($e2)eq $type;if($type eq 'DIFFERENT'){push@Data_Stack,{type=>$type,vals=>[$e1,$e2 ]};$ok=0}elsif($type eq 'ARRAY'){$ok=_eq_array($e1,$e2)}elsif($type eq 'HASH'){$ok=_eq_hash($e1,$e2)}elsif($type eq 'REF'){push@Data_Stack,{type=>$type,vals=>[$e1,$e2 ]};$ok=_deep_check($$e1,$$e2);pop@Data_Stack if$ok}elsif($type eq 'SCALAR'){push@Data_Stack,{type=>'REF',vals=>[$e1,$e2 ]};$ok=_deep_check($$e1,$$e2);pop@Data_Stack if$ok}elsif($type){push@Data_Stack,{type=>$type,vals=>[$e1,$e2 ]};$ok=0}else {_whoa(1,"No type in _deep_check")}}}return$ok}sub _whoa {my($check,$desc)=@_;if($check){die <<"WHOA"}}sub eq_hash {local@Data_Stack=();return _deep_check(@_)}sub _eq_hash {my($a1,$a2)=@_;if(grep _type($_)ne 'HASH',$a1,$a2){warn "eq_hash passed a non-hash ref";return 0}return 1 if$a1 eq $a2;my$ok=1;my$bigger=keys %$a1 > keys %$a2 ? $a1 : $a2;for my$k (keys %$bigger){my$e1=exists$a1->{$k}? $a1->{$k}: $DNE;my$e2=exists$a2->{$k}? $a2->{$k}: $DNE;next if _equal_nonrefs($e1,$e2);push@Data_Stack,{type=>'HASH',idx=>$k,vals=>[$e1,$e2 ]};$ok=_deep_check($e1,$e2);pop@Data_Stack if$ok;last unless$ok}return$ok}sub eq_set {my($a1,$a2)=@_;return 0 unless @$a1==@$a2;no warnings 'uninitialized';return eq_array([grep(ref,@$a1),sort(grep(!ref,@$a1))],[grep(ref,@$a2),sort(grep(!ref,@$a2))],)}1;
      Tried to use '$module'.
      Error:  $eval_error
  DIAGNOSTIC
  is_deeply() takes two or three args, you gave %d.
  This usually means you passed an array or hash instead 
  of a reference to it
  WARNING
  WHOA!  $desc
  This should never happen!  Please contact the author immediately!
  WHOA
TEST_MORE

$fatpacked{"Test/NoWarnings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_NOWARNINGS';
  package Test::NoWarnings;use 5.006;use strict;use warnings;use Carp ();use Exporter ();use Test::Builder ();use Test::NoWarnings::Warning ();use vars qw($VERSION @EXPORT_OK @ISA $do_end_test);BEGIN {$VERSION='1.04';@ISA='Exporter';@EXPORT_OK=qw(clear_warnings had_no_warnings warnings);$do_end_test=0}my$TEST=Test::Builder->new;my$PID=$$;my@WARNINGS=();my$EARLY=0;$SIG{__WARN__}=make_catcher(\@WARNINGS);sub import {$do_end_test=1;if (grep {$_ eq ':early'}@_){@_=grep {$_ ne ':early'}@_;$EARLY=1}goto&Exporter::import}END {had_no_warnings()if$do_end_test}sub make_warning {local$SIG{__WARN__};my$msg=shift;my$warning=Test::NoWarnings::Warning->new;$warning->setMessage($msg);$warning->fillTest($TEST);$warning->fillTrace(__PACKAGE__);$Carp::Internal{__PACKAGE__.""}++;local$Carp::CarpLevel=$Carp::CarpLevel + 1;$warning->fillCarp($msg);$Carp::Internal{__PACKAGE__.""}--;return$warning}sub make_catcher {my$array=shift;return sub {my$msg=shift;$Carp::Internal{__PACKAGE__.""}++;push(@$array,make_warning($msg));$Carp::Internal{__PACKAGE__.""}--;if ($EARLY){$TEST->diag($array->[-1]->toString)}return$msg}}sub had_no_warnings {return 0 if $$!=$PID;local$SIG{__WARN__};my$name=shift || "no warnings";my$ok;my$diag;if (@WARNINGS==0){$ok=1}else {$ok=0;$diag="There were " .scalar(@WARNINGS)." warning(s)\n";unless ($EARLY){$diag .= join "----------\n",map {$_->toString}@WARNINGS}}$TEST->ok($ok,$name)|| $TEST->diag($diag);return$ok}sub clear_warnings {local$SIG{__WARN__};@WARNINGS=()}sub warnings {local$SIG{__WARN__};return@WARNINGS}sub builder {local$SIG{__WARN__};if (@_){$TEST=shift}return$TEST}1;
TEST_NOWARNINGS

$fatpacked{"Test/NoWarnings/Warning.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_NOWARNINGS_WARNING';
  package Test::NoWarnings::Warning;use 5.006;use strict;use Carp ();use vars qw{$VERSION};BEGIN {$VERSION='1.04';eval "require Devel::StackTrace"}sub new {my$class=shift;bless {@_ },$class}sub getTrace {$_[0]->{Trace}}sub fillTrace {my$self=shift;$self->{Trace}=Devel::StackTrace->new(ignore_class=>[__PACKAGE__,@_],)if$Devel::StackTrace::VERSION}sub getCarp {$_[0]->{Carp}}sub fillCarp {my$self=shift;my$msg=shift;$Carp::Internal{__PACKAGE__ ."" }++;local$Carp::CarpLevel=$Carp::CarpLevel + 1;$self->{Carp}=Carp::longmess($msg);$Carp::Internal{__PACKAGE__ ."" }--}sub getMessage {$_[0]->{Message}}sub setMessage {$_[0]->{Message}=$_[1]}sub fillTest {my$self=shift;my$builder=shift;my$prev_test=$builder->current_test;$self->{Test}=$prev_test;my@tests=$builder->details;my$prev_test_name=$prev_test ? $tests[$prev_test - 1]->{name}: "";$self->{TestName}=$prev_test_name}sub getTest {$_[0]->{Test}}sub getTestName {$_[0]->{TestName}}sub toString {my$self=shift;return <<EOM}1;
  	Previous test $self->{Test} '$self->{TestName}'
  	$self->{Carp}
  EOM
TEST_NOWARNINGS_WARNING

$fatpacked{"Test/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_SIMPLE';
  package Test::Simple;use 5.006;use strict;our$VERSION='1.001014';$VERSION=eval$VERSION;use Test::Builder::Module 0.99;our@ISA=qw(Test::Builder::Module);our@EXPORT=qw(ok);my$CLASS=__PACKAGE__;sub ok ($;$) {return$CLASS->builder->ok(@_)}1;
TEST_SIMPLE

$fatpacked{"Test/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER';
  use strict;package Test::Tester;BEGIN {if (*Test::Builder::new{CODE}){warn "You should load Test::Tester before Test::Builder (or anything that loads Test::Builder)"}}use Test::Builder;use Test::Tester::CaptureRunner;use Test::Tester::Delegate;require Exporter;use vars qw(@ISA @EXPORT $VERSION);$VERSION="0.114";@EXPORT=qw(run_tests check_tests check_test cmp_results show_space);@ISA=qw(Exporter);my$Test=Test::Builder->new;my$Capture=Test::Tester::Capture->new;my$Delegator=Test::Tester::Delegate->new;$Delegator->{Object}=$Test;my$runner=Test::Tester::CaptureRunner->new;my$want_space=$ENV{TESTTESTERSPACE};sub show_space {$want_space=1}my$colour='';my$reset='';if (my$want_colour=$ENV{TESTTESTERCOLOUR}|| $ENV{TESTTESTERCOLOUR}){if (eval "require Term::ANSIColor"){my ($f,$b)=split(",",$want_colour);$colour=Term::ANSIColor::color($f).Term::ANSIColor::color("on_$b");$reset=Term::ANSIColor::color("reset")}}sub new_new {return$Delegator}sub capture {return Test::Tester::Capture->new}sub fh {$runner=Test::Tester::FHRunner->new;return$Test}sub find_run_tests {my$d=1;my$found=0;while ((not $found)and (my ($sub)=(caller($d))[3])){$found=($sub eq "Test::Tester::run_tests");$d++}return$d}sub run_tests {local($Delegator->{Object})=$Capture;$runner->run_tests(@_);return ($runner->get_premature,$runner->get_results)}sub check_test {my$test=shift;my$expect=shift;my$name=shift;$name="" unless defined($name);@_=($test,[$expect],$name);goto&check_tests}sub check_tests {my$test=shift;my$expects=shift;my$name=shift;$name="" unless defined($name);my ($prem,@results)=eval {run_tests($test,$name)};$Test->ok(!$@,"Test '$name' completed")|| $Test->diag($@);$Test->ok(!length($prem),"Test '$name' no premature diagnostication")|| $Test->diag("Before any testing anything, your tests said\n$prem");local$Test::Builder::Level=$Test::Builder::Level + 1;cmp_results(\@results,$expects,$name);return ($prem,@results)}sub cmp_field {my ($result,$expect,$field,$desc)=@_;if (defined$expect->{$field}){$Test->is_eq($result->{$field},$expect->{$field},"$desc compare $field")}}sub cmp_result {my ($result,$expect,$name)=@_;my$sub_name=$result->{name};$sub_name="" unless defined($name);my$desc="subtest '$sub_name' of '$name'";{local$Test::Builder::Level=$Test::Builder::Level + 1;cmp_field($result,$expect,"ok",$desc);cmp_field($result,$expect,"actual_ok",$desc);cmp_field($result,$expect,"type",$desc);cmp_field($result,$expect,"reason",$desc);cmp_field($result,$expect,"name",$desc)}my$depth=1;if (exists$expect->{depth}){$depth=$expect->{depth}}if (defined$depth){$Test->is_eq($result->{depth},$depth,"checking depth")|| $Test->diag('You need to change $Test::Builder::Level')}if (defined(my$exp=$expect->{diag})){$exp .= "\n" if (length($exp)and $exp !~ /\n$/);if (not $Test->ok($result->{diag}eq $exp,"subtest '$sub_name' of '$name' compare diag")){my$got=$result->{diag};my$glen=length($got);my$elen=length($exp);for ($got,$exp){my@lines=split("\n",$_);$_=join("\n",map {if ($want_space){$_=$colour.escape($_).$reset}else {"'$colour$_$reset'"}}@lines)}$Test->diag(<<EOM)}}}sub escape {my$str=shift;my$res='';for my$char (split("",$str)){my$c=ord($char);if(($c>32 and $c<125)or $c==10){$res .= $char}else {$res .= sprintf('\x{%x}',$c)}}return$res}sub cmp_results {my ($results,$expects,$name)=@_;$Test->is_num(scalar @$results,scalar @$expects,"Test '$name' result count");for (my$i=0;$i < @$expects;$i++){my$expect=$expects->[$i];my$result=$results->[$i];local$Test::Builder::Level=$Test::Builder::Level + 1;cmp_result($result,$expect,$name)}}sub plan {my(@plan)=@_;my$caller=caller;$Test->exported_to($caller);my@imports=();for my$idx (0..$#plan){if($plan[$idx]eq 'import'){my($tag,$imports)=splice@plan,$idx,2;@imports=@$imports;last}}$Test->plan(@plan);__PACKAGE__->_export_to_level(1,__PACKAGE__,@imports)}sub import {my($class)=shift;{no warnings 'redefine';*Test::Builder::new=\&new_new}goto&plan}sub _export_to_level {my$pkg=shift;my$level=shift;(undef)=shift;my$callpkg=caller($level);$pkg->export($callpkg,@_)}1;
  Got diag ($glen bytes):
  $got
  Expected diag ($elen bytes):
  $exp
  EOM
TEST_TESTER

$fatpacked{"Test/Tester/Capture.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_CAPTURE';
  use strict;package Test::Tester::Capture;use Test::Builder;use vars qw(@ISA);@ISA=qw(Test::Builder);BEGIN {use Config;if($] >= 5.008 && $Config{useithreads}){require threads::shared;threads::shared->import}else {*share=sub {0};*lock=sub {0}}}my$Curr_Test=0;share($Curr_Test);my@Test_Results=();share(@Test_Results);my$Prem_Diag={diag=>""};share($Curr_Test);sub new {my$class=shift;return bless {},$class}sub ok {my($self,$test,$name)=@_;$test=$test ? 1 : 0;lock$Curr_Test;$Curr_Test++;my($pack,$file,$line)=$self->caller;my$todo=$self->todo($pack);my$result={};share($result);unless($test){@$result{'ok','actual_ok' }=(($todo ? 1 : 0),0)}else {@$result{'ok','actual_ok' }=(1,$test)}if(defined$name){$name =~ s|#|\\#|g;$result->{name}=$name}else {$result->{name}=''}if($todo){my$what_todo=$todo;$result->{reason}=$what_todo;$result->{type}='todo'}else {$result->{reason}='';$result->{type}=''}$Test_Results[$Curr_Test-1]=$result;unless($test){my$msg=$todo ? "Failed (TODO)" : "Failed";$result->{fail_diag}=("	$msg test ($file at line $line)\n")}$result->{diag}="";$result->{_level}=$Test::Builder::Level;$result->{_depth}=Test::Tester::find_run_tests();return$test ? 1 : 0}sub skip {my($self,$why)=@_;$why ||= '';lock($Curr_Test);$Curr_Test++;my%result;share(%result);%result=('ok'=>1,actual_ok=>1,name=>'',type=>'skip',reason=>$why,diag=>"",_level=>$Test::Builder::Level,_depth=>Test::Tester::find_run_tests(),);$Test_Results[$Curr_Test-1]=\%result;return 1}sub todo_skip {my($self,$why)=@_;$why ||= '';lock($Curr_Test);$Curr_Test++;my%result;share(%result);%result=('ok'=>1,actual_ok=>0,name=>'',type=>'todo_skip',reason=>$why,diag=>"",_level=>$Test::Builder::Level,_depth=>Test::Tester::find_run_tests(),);$Test_Results[$Curr_Test-1]=\%result;return 1}sub diag {my($self,@msgs)=@_;return unless@msgs;return if $^C;for (@msgs){$_='undef' unless defined}push@msgs,"\n" unless$msgs[-1]=~ /\n\Z/;my$result=$Curr_Test ? $Test_Results[$Curr_Test - 1]: $Prem_Diag;$result->{diag}.= join("",@msgs);return 0}sub details {return@Test_Results}sub note {}sub explain {return Test::Builder::explain(@_)}sub premature {return$Prem_Diag->{diag}}sub current_test {if (@_ > 1){die "Don't try to change the test number!"}else {return$Curr_Test}}sub reset {$Curr_Test=0;@Test_Results=();$Prem_Diag={diag=>""}}1;
TEST_TESTER_CAPTURE

$fatpacked{"Test/Tester/CaptureRunner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_CAPTURERUNNER';
  use strict;package Test::Tester::CaptureRunner;use Test::Tester::Capture;require Exporter;sub new {my$pkg=shift;my$self=bless {},$pkg;return$self}sub run_tests {my$self=shift;my$test=shift;capture()->reset;$self->{StartLevel}=$Test::Builder::Level;&$test()}sub get_results {my$self=shift;my@results=capture()->details;my$start=$self->{StartLevel};for my$res (@results){next if defined$res->{depth};my$depth=$res->{_depth}- $res->{_level}- $start - 3;$res->{depth}=$depth}return@results}sub get_premature {return capture()->premature}sub capture {return Test::Tester::Capture->new}
TEST_TESTER_CAPTURERUNNER

$fatpacked{"Test/Tester/Delegate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TESTER_DELEGATE';
  use strict;use warnings;package Test::Tester::Delegate;use vars '$AUTOLOAD';sub new {my$pkg=shift;my$obj=shift;my$self=bless {},$pkg;return$self}sub AUTOLOAD {my ($sub)=$AUTOLOAD =~ /.*::(.*?)$/;return if$sub eq "DESTROY";my$obj=$_[0]->{Object};my$ref=$obj->can($sub);shift(@_);unshift(@_,$obj);goto &$ref}1;
TEST_TESTER_DELEGATE

$fatpacked{"Test/use/ok.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_USE_OK';
  package Test::use::ok;use 5.005;$Test::use::ok::VERSION='0.16';
TEST_USE_OK

$fatpacked{"ojo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OJO';
  package ojo;use Mojo::Base -strict;use Benchmark qw(timeit timestr :hireswallclock);use Mojo::ByteStream 'b';use Mojo::Collection 'c';use Mojo::DOM;use Mojo::JSON 'j';use Mojo::Util qw(dumper monkey_patch);$ENV{MOJO_LOG_LEVEL}||= 'fatal';sub import {my$caller=caller;eval "package $caller; use Mojolicious::Lite; 1" or die $@;my$ua=$caller->app->ua;$ua->server->app->hook(around_action=>sub {local $_=$_[1];$_[0]()});$ua->max_redirects(10)unless defined$ENV{MOJO_MAX_REDIRECTS};$ua->proxy->detect unless defined$ENV{MOJO_PROXY};monkey_patch$caller,a=>sub {$caller->can('any')->(@_)and return$ua->server->app},b=>\&b,c=>\&c,d=>sub {_request($ua,'DELETE',@_)},g=>sub {_request($ua,'GET',@_)},h=>sub {_request($ua,'HEAD',@_)},j=>\&j,n=>sub (&@) {say STDERR timestr timeit($_[1]// 1,$_[0])},o=>sub {_request($ua,'OPTIONS',@_)},p=>sub {_request($ua,'POST',@_)},r=>\&dumper,t=>sub {_request($ua,'PATCH',@_)},u=>sub {_request($ua,'PUT',@_)},x=>sub {Mojo::DOM->new(@_)}}sub _request {my$ua=shift;my$tx=$ua->start($ua->build_tx(@_));my$err=$tx->error;warn qq/Problem loading URL "@{[$tx->req->url]}": $err->{message}\n/ if$err &&!$err->{code};return$tx->res}1;
OJO

$fatpacked{"ok.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OK';
  package ok;$ok::VERSION='0.16';use strict;use Test::More ();sub import {shift;if (@_){goto&Test::More::pass if $_[0]eq 'ok';goto&Test::More::use_ok}my (undef,$file,$line)=caller();($file =~ /^\(eval/)or die "Not enough arguments for 'use ok' at $file line $line\n"}
OK

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;
use 5.010001;
use Data::Dumper;
use IPC::ConcurrencyLimit;
use Log::Unrotate;
use Mojo::UserAgent;

sub DEBUG { 1 }

my $buffer      = '100';                # flush buffer to influx after $buffer lines
my $mmin        = '-2';                 # find files modified in last 2 mins
my $monitor     = '/var/lib/pushflux';  # folder to monitor
my $monitor_ext = 'log';                # file extension to include in pushes
my $symlinks    = '-L';                 # find will follow symlinks
$monitor .= '/' unless $monitor =~ m,/$,;

run();
exit(0);

sub run {
  my $limit
    = IPC::ConcurrencyLimit->new(max_procs => 1, path => '/var/run/pushflux');

  my $id = $limit->get_lock;
  if (not $id) {
    warn "Another process appears to be still running. Exiting.\n";
    exit(0);
  }
  else {
    my @changed = `find $symlinks $monitor -type f -name '*.$monitor_ext' -mmin $mmin`;
    for my $filename (@changed) {
        chomp $filename;
        say "pushflux: $filename";
        pushflux(args_from_filename($monitor, $filename));
    }
  }

  # lock released with $limit going out of scope here
}

sub args_from_filename {
  my ($monitor, $filename) = @_;
  die "$monitor does not exist within $filename"
    unless $filename =~ m,^$monitor,;

  my ($host, $database, $log) = ($filename =~ m,^$monitor(.*?)/(.*?)/(.*?)$,);
  return ($host, $database, $log, $filename);
}

sub influx {
  my ($host, $database, $payload) = @_;

  say "Writing payload:";
  say $payload;

  state $ua = Mojo::UserAgent->new;
  my $tx = $ua->post("http://$host:8086/write?db=$database" => $payload);
  if (my $res = $tx->success) { return 0 }
  else {
    my $err = $tx->error;
    die("$err->{code} response: $err->{message}") if $err->{code};
    die("Connection error: $err->{message}");
  }
}

sub pushflux {
  my ($host, $database, $log, $filename) = @_;
  my $reader   = Log::Unrotate->new(
    {log => $filename, pos => "/tmp/$host-$database-$log.pos"});

  my $payload = undef;
  my $count   = 0;

  while (my $line = $reader->read()) {
    $payload .= $line;

    # every 100 lines are submitted to influx
    if (++$count % $buffer == 0) {
      if (influx($host, $database, $payload) == 0) {
        $payload = undef;
        $reader->commit();
      }
    }
  }

  if ($payload) {
    if (influx($host, $database, $payload) == 0) {
      $reader->commit();
    }
  }
}

__END__

# TODO
#
# Notify on all errors
# Notify if there's an error pushing to an influxdb
# Handle influxdbs which non-default (8086) ports
#
